<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial (CLI) · MCMRSimulator.jl</title><meta name="title" content="Tutorial (CLI) · MCMRSimulator.jl"/><meta property="og:title" content="Tutorial (CLI) · MCMRSimulator.jl"/><meta property="twitter:title" content="Tutorial (CLI) · MCMRSimulator.jl"/><meta name="description" content="Documentation for MCMRSimulator.jl: a Monte Carlo MRI simulator in Julia"/><meta property="og:description" content="Documentation for MCMRSimulator.jl: a Monte Carlo MRI simulator in Julia"/><meta property="twitter:description" content="Documentation for MCMRSimulator.jl: a Monte Carlo MRI simulator in Julia"/><meta property="og:url" content="https://open.win.ox.ac.uk/pages/ndcn0236/mcmrsimulator.jl/stable/tutorial_cli/"/><meta property="twitter:url" content="https://open.win.ox.ac.uk/pages/ndcn0236/mcmrsimulator.jl/stable/tutorial_cli/"/><link rel="canonical" href="https://open.win.ox.ac.uk/pages/ndcn0236/mcmrsimulator.jl/stable/tutorial_cli/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MCMRSimulator.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial_julia/">Tutorial (Julia)</a></li><li class="is-active"><a class="tocitem" href>Tutorial (CLI)</a><ul class="internal"><li><a class="tocitem" href="#Defining-the-geometry"><span>Defining the geometry</span></a></li><li><a class="tocitem" href="#Defining-the-sequence"><span>Defining the sequence</span></a></li><li><a class="tocitem" href="#Running-the-simulation"><span>Running the simulation</span></a></li></ul></li><li><a class="tocitem" href="../geometry/">Geometry</a></li><li><a class="tocitem" href="../sequence/">Sequence</a></li><li><a class="tocitem" href="../properties/">MRI/collision properties</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial (CLI)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial (CLI)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl" title="View the repository"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-navbar-link" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/-/tree/main/docs/src/tutorial_cli.md" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial_cli"><a class="docs-heading-anchor" href="#tutorial_cli">Tutorial</a><a id="tutorial_cli-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial_cli" title="Permalink"></a></h1><p>This tutorial will walk through an example of modelling the MRI signal evolution for a diffusion-weighted sequence. The spins in this simulation will be constrained by regularly packed cylinders. This tutorial will use the command line interface, which we assume is available through the <code>mcmr</code> command (see <a href="../installation/#installation">installation instructions</a>). If you would prefer to interact with MCMRSimulator in Julia, you can find a tutorial doing the same analysis <a href="../tutorial_julia/#tutorial_julia">here</a>.</p><p>In general, running a simulation will consist of the following three steps:</p><ul><li>Creating a geometry using one or more calls to <code>mcmr geometry</code> (<a href="../geometry/#geometry">full description</a>)</li><li>Defining a sequence using <code>mcmr sequence</code> (<a href="../sequence/#sequence">full description</a>)</li><li>Running the actual simulation using <code>mcmr run</code></li></ul><p>We will look through each of these steps below.</p><h2 id="Defining-the-geometry"><a class="docs-heading-anchor" href="#Defining-the-geometry">Defining the geometry</a><a id="Defining-the-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-geometry" title="Permalink"></a></h2><p>First we will define a geometry formed of regularly packed axons. This is represented by a single cylinder pointing in the z-direction with a radius of 1 micrometer that repeats itself every 2.5 micrometer (in both the x-, and y-direction).</p><pre><code class="language-bash hljs">mcmr geometry create cylinders 1 geometry.json --radius 1 --repeats 2.5 2.5</code></pre><p>This will create a JSON file with the full information on the geometry:</p><pre><code class="language-json hljs">  {
     &quot;type&quot;: &quot;Cylinders&quot;,
     &quot;number&quot;: 1,
    &quot;#radius_description&quot;: &quot;Radius of the cylinder. Field is required. Expected type: Float64.&quot;,
    &quot;radius&quot;: 1.0,
    &quot;#rotation_description&quot;: &quot;Rotation applied to all obstructions in group. Can be set to a matrix or one of :x, :y, or, :z (see [`get_rotation`](@ref)). Field is required. Expected type: StaticArraysCore.SMatrix{3, 2, Float64, 6}.&quot;,
    &quot;rotation&quot;: [[1.0,0.0,0.0],[0.0,1.0,0.0]],
    &quot;#grid_resolution_description&quot;: &quot;Resolution of the grid that the volume is split up into (um). Field is required. Expected type: Float64.&quot;,
    &quot;grid_resolution&quot;: 1.0,
    &quot;#R1_surface_description&quot;: &quot;Additional longitudinal relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.&quot;,
    &quot;R1_surface&quot;: 0.0,
    &quot;#R1_inside_description&quot;: &quot;Additional longitudinal relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.&quot;,
    &quot;R1_inside&quot;: 0.0,
    &quot;#R2_surface_description&quot;: &quot;Additional transverse relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.&quot;,
    &quot;R2_surface&quot;: 0.0,
    &quot;#R2_inside_description&quot;: &quot;Additional transverse relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.&quot;,
    &quot;R2_inside&quot;: 0.0,
    &quot;#off_resonance_surface_description&quot;: &quot;Additional off-resonance field offset (kHz). Surface property. Field is required. Expected type: Float64.&quot;,
    &quot;off_resonance_surface&quot;: 0.0,
    &quot;#off_resonance_inside_description&quot;: &quot;Additional off-resonance field offset (kHz). Inside property. Field is required. Expected type: Float64.&quot;,
    &quot;off_resonance_inside&quot;: 0.0,
    &quot;#position_description&quot;: &quot;Spatial offset of obstruction from origin. Field is required. Expected type: StaticArraysCore.MVector{2, Float64}.&quot;,
    &quot;position&quot;: [0.0,0.0],
    &quot;#g_ratio_description&quot;: &quot;Inner/outer radius used for susceptibility calculation Field can be null. Expected type: Float64.&quot;,
    &quot;g_ratio&quot;: 1.0,
    &quot;#susceptibility_iso_description&quot;: &quot;Isotropic component of the susceptibility (in ppm). Field can be null. Expected type: Float64.&quot;,
    &quot;susceptibility_iso&quot;: -0.1,
    &quot;#susceptibility_aniso_description&quot;: &quot;Ansotropic component of the susceptibility (in ppm). Field can be null. Expected type: Float64.&quot;,
    &quot;susceptibility_aniso&quot;: -0.1,
    &quot;#lorentz_radius_description&quot;: &quot;Only compute field explicitly for cylinders with this Lorentz radius. Field can be null. Expected type: Float64.&quot;,
    &quot;lorentz_radius&quot;: 5.0,
    &quot;#repeats_description&quot;: &quot;Length scale on which the obstructions are repeated (um). Field can be null. Expected type: StaticArraysCore.MVector{2, Float64}.&quot;,
    &quot;repeats&quot;: [2.5,2.5],
    &quot;#use_boundingbox_description&quot;: &quot;Use bounding boxes for an initial filtering of possible intersections. Field can be null. Expected type: Bool.&quot;,
    &quot;use_boundingbox&quot;: true,
    &quot;#dwell_time_description&quot;: &quot;Average time a particle stays stuck to the surface (ms). Surface property. Field can be null. Expected type: Float64.&quot;,
    &quot;dwell_time&quot;: null,
    &quot;#density_description&quot;: &quot;Surface density of stuck particles relative to the volume density (um). Surface property. Field can be null. Expected type: Float64.&quot;,
    &quot;density&quot;: null,
    &quot;#permeability_description&quot;: &quot;Probability of particle passing through the obstruction. Surface property. Field can be null. Expected type: Float64.&quot;,
    &quot;permeability&quot;: null,
    &quot;#relaxivity_description&quot;: &quot;Fraction of transverse spin lost each time it hits the obstruction. Surface property. Field can be null. Expected type: Float64.&quot;,
    &quot;relaxivity&quot;: null
  }</code></pre><p>You can see how that the <code>repeats</code> and <code>radius</code> keywords have been set to our predefined values. You can alter these and other geometry properties by editing this JSON directly or using the flags when creating the geometry. For a full overview of these flags, you can run:</p><pre><code class="nohighlight hljs">mcmr geometry create cylinders --help</code></pre><p>How these various properties affect the simulation is described <a href="../properties/#properties">here</a>.</p><p>The procedure to create <a href="../api/#MCMRSimulator.Geometries.User.Obstructions.Walls"><code>Walls</code></a>, <a href="../api/#MCMRSimulator.Geometries.User.Obstructions.Spheres"><code>Spheres</code></a>, or <a href="../api/#MCMRSimulator.Geometries.User.Obstructions.Annuli"><code>Annuli</code></a> is very similar as for the <a href="../api/#MCMRSimulator.Geometries.User.Obstructions.Cylinders"><code>Cylinders</code></a> illustrated above. Randomly distributed cylinders, annuli, and spheres can be created using <code>mcmr geometry create-random</code>.</p><h2 id="Defining-the-sequence"><a class="docs-heading-anchor" href="#Defining-the-sequence">Defining the sequence</a><a id="Defining-the-sequence-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-sequence" title="Permalink"></a></h2><p>The next step is to define a sequence (see <a href="../sequence/#sequence">here</a> for more details).  There are several built-in sequences available, which you can see listed by running:</p><pre><code class="language-bash hljs">mcmr sequence</code></pre><p>Alternatively, you can skip this step and use a sequence defined using <a href="https://pulseq.github.io">pulseq</a> instead.</p><p>Here, we will create a diffusion-weighted sequence:</p><pre><code class="language-bash hljs">mcmr sequence dwi dwi.json --bval=2 --TR=1000 --TE=80 --B0=3</code></pre><p>This produces another JSON:</p><pre><code class="language-json hljs">{&quot;scanner&quot;:{&quot;B0&quot;:3.0,&quot;gradient&quot;:null,&quot;slew_rate&quot;:null},&quot;gradients&quot;:[{&quot;shape&quot;:{&quot;times&quot;:[0.0,5.0e-324,39.99999999999999,40.0],&quot;amplitudes&quot;:[[0.0,0.0,0.0],[0.0010896594058735262,0.0,0.0],[0.0010896594058735262,0.0,0.0],[0.0,0.0,0.0]]},&quot;origin&quot;:[0.0,0.0,0.0]},{&quot;shape&quot;:{&quot;times&quot;:[40.0,40.00000000000001,79.99999999999999,80.0],&quot;amplitudes&quot;:[[0.0,0.0,0.0],[0.0010896594058735262,0.0,0.0],[0.0010896594058735262,0.0,0.0],[0.0,0.0,0.0]]},&quot;origin&quot;:[0.0,0.0,0.0]}],&quot;instants&quot;:[{&quot;time&quot;:0.0,&quot;flip_angle&quot;:90.0,&quot;cf&quot;:6.123233995736766e-17,&quot;sf&quot;:1.0,&quot;phase&quot;:-90.0,&quot;cp&quot;:6.123233995736766e-17,&quot;sp&quot;:-1.0},{&quot;time&quot;:40.0,&quot;flip_angle&quot;:180.0,&quot;cf&quot;:-1.0,&quot;sf&quot;:1.2246467991473532e-16,&quot;phase&quot;:0.0,&quot;cp&quot;:1.0,&quot;sp&quot;:0.0}],&quot;pulses&quot;:[],&quot;TR&quot;:1000.0,&quot;readout_times&quot;:[80.0]}</code></pre><p>This one is less readable or editable by users, but basically describes the sequence diagram.</p><h2 id="Running-the-simulation"><a class="docs-heading-anchor" href="#Running-the-simulation">Running the simulation</a><a id="Running-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-simulation" title="Permalink"></a></h2><p>To get instructions on running the simulations, we can check the help message of <code>mcmr run</code>:</p><pre><code class="language-bash hljs">mcmr run --help</code></pre><p>We can see that in addition to defining the geometry and the sequence, we can also control the simulation properties such as the <code>--diffusivity</code>, <code>--R1</code>, and <code>--R2</code>.</p><p>The simulation is initialised by randomly distributing a number of spins (set by <code>--Nspins</code>) uniformly across a bounding box with size given by <code>--voxel-size</code>. This initial state might also contain bound spins (if the <code>--density</code> flag was set to a non-zero value during the geometry generation).</p><p>The DWI sequence defined above contains a <a href="../api/#MCMRSimulator.Sequences.Instants.Readout"><code>Readout</code></a> object at the echo time (80 ms). By default, this is used for readout:</p><pre><code class="language-bash hljs">mcmr run geometry.json dwi.json -o signal.csv</code></pre><p>This produces the CSV file, which looks like</p><pre><code class="language-csv hljs">sequence,TR,readout,subset,nspins,longitudinal,transverse,phase,Sx,Sy
1,1,1,0,10000,-1.1262102361797588e-12,9997.399612964802,-0.006154308518773632,9997.399555292097,-1.0738501510661669</code></pre><p>The columns in this file store the following information:</p><ul><li>&quot;sequence&quot;: integer; index of the sequence (always 1 if only single sequence used)</li><li>&quot;TR&quot;: integer; index of the repetition time that this data was acquired (between 1 and the value of <code>--nTR</code>)</li><li>&quot;readout&quot;: integer; index of the readout within a TR.</li><li>&quot;subset&quot;: integer; index of the subset of the total signal (e.g., intra-axonal) that has been output (see the <code>--subset</code> flag). The total signal will always be included with &quot;subset&quot; of 0.</li><li>&quot;nspins&quot;: total number of spins contributing to the signal (might change for certain subsets of spins)</li><li>&quot;longitudinal&quot;: average longitudinal signal</li><li>&quot;transverse&quot;: average transverse signal</li><li>&quot;phase&quot;: average phase of the signal (in degrees)</li><li>&quot;Sx&quot;: signal strength in the x-direction</li><li>&quot;Sy&quot;: signal strength in the y-direction</li></ul><p>We can also output the signal of specific subsets of spins. For example, in the following we request to separately the output for just the spins inside the cylinders and just the spins outside of the cylinders.</p><pre><code class="language-bash hljs">mcmr run geometry.json dwi.json -o signal.csv --subset inside --subset outside</code></pre><p>We can see two additional rows in the output.  These new rows are the in same order as the <code>--subset</code> flags provided to <code>mcmr run</code> and can be distinguished based on the &quot;subset&quot; column.</p><pre><code class="language-csv hljs">sequence,TR,readout,subset,nspins,longitudinal,transverse,phase,Sx,Sy
1,1,1,0,10000,-1.1159961843532074e-12,5766.699443791598,-0.35729630492630804,5766.587317438051,-35.96088693214867
1,1,1,1,5061,-5.6710192097853e-13,5059.681276894357,-0.012819017299705138,5059.681150258304,-1.1320230186175206
1,1,1,2,4939,-5.488942633746774e-13,707.7636462536609,-2.820649519317783,706.9061671797538,-34.82886391353121</code></pre><p>We can see in the second row that inside the cylinders the transverse signal is very close to the number of spins (5059.68 out of 5061),  indicating that there has been very little dephasing due to the diffusion weighting inside the cylinders. On the other hand, we did lose most of the signal outside of the cylinders (707.76 out of 4939). All the spins are either inside or outside the cylinders, so in this case the first row is simply the sum of the next two.</p><p>A more complete state of all the spins can be produced using the <code>--output-snapshot</code> flag. For example, the command</p><pre><code class="language-bash hljs">mcmr run geometry.json dwi.json -output-snapshot snapshot.csv</code></pre><p>will produce a file named &quot;snapshot.csv&quot; with:</p><pre><code class="language-csv hljs">sequence,TR,readout,spin,x,y,z,longitudinal,transverse,phase,Sx,Sy
1,1,1,1,0.5049228156370124,0.05412808852066652,6.442542415589706,-2.220446049250313e-16,0.9999999999999942,0.25379615194714045,0.9999901894332786,0.004429563994801518
1,1,1,2,-0.9688485879911409,0.09305926325698886,-1.724633930537917,-2.220446049250313e-16,0.9999999999999917,-0.0047769059448796725,0.999999996524485,-8.337273670013147e-5
1,1,1,3,0.2629314013825268,-0.6671294575623549,-17.506721187691674,-2.220446049250313e-16,0.9999999999999946,0.6082085693901605,0.9999436588469045,0.010615042715627557
1,1,1,4,-0.9924343175166189,-0.051930346020524064,-11.845895413220594,0.0,0.9999999999999928,-0.11879290332484516,0.9999978506577348,-0.0020733258055911637
1,1,1,5,0.08578653895854582,0.5766674996691633,2.905211448847795,-2.220446049250313e-16,0.9999999999999931,-0.28110585975525737,0.9999879645130568,-0.004906203116436347
1,1,1,6,0.5283705886599059,-0.6771241777295106,18.97063962214857,-2.220446049250313e-16,0.9999999999999921,-1.2036996551270818,0.999779329114167,-0.021006976841285743
1,1,1,7,0.2676027006707101,0.27872400783545637,21.212386477239814,0.0,0.999999999999992,1.8741387410642074,0.9994650791902853,0.03270405906215431
...</code></pre><p>Each row corresponds to the state of a single spin. In addition to all the columns listed above, we now have 4 more columns:</p><ul><li>&quot;spin&quot;: integer; index of the spin</li><li>&quot;x&quot;/&quot;y&quot;/&quot;z&quot;: floats; position of the spin at the time of the readout</li></ul><p>The readout times can be adjusted using the <code>--nTR</code>, <code>--time</code>, and <code>--skip-TR</code> flags. For more examples of this, see the end of the <a href="../tutorial_julia/#tutorial_julia">tutorial using the Julia interface</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_julia/">« Tutorial (Julia)</a><a class="docs-footer-nextpage" href="../geometry/">Geometry »</a><div class="flexbox-break"></div></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Wednesday 4 October 2023 17:37">Wednesday 4 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
