<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MCMRSimulator.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MCMRSimulator.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../geometry/">Geometry</a></li><li><a class="tocitem" href="../sequence/">Sequence</a></li><li><a class="tocitem" href="../properties/">MRI/collision properties</a></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/main/docs/src/api.md#" title="Edit source"><span class="docs-icon fa"></span><span class="docs-label is-hidden-touch">Edit source</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="api"><a class="docs-heading-anchor" href="#api">MCMRSimulator.jl API</a><a id="api-1"></a><a class="docs-heading-anchor-permalink" href="#api" title="Permalink"></a></h1><p>This is the API for <a href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl">MCMRSimulator</a>. For a more user-friendly introduction, click <a href="../#Introduction">here</a>.</p><ul><li><a href="#MCMRSimulator.MCMRSimulator"><code>MCMRSimulator.MCMRSimulator</code></a></li><li><a href="#MCMRSimulator.Siemens_Connectom"><code>MCMRSimulator.Siemens_Connectom</code></a></li><li><a href="#MCMRSimulator.Siemens_Prisma"><code>MCMRSimulator.Siemens_Prisma</code></a></li><li><a href="#MCMRSimulator.Siemens_Terra"><code>MCMRSimulator.Siemens_Terra</code></a></li><li><a href="#MCMRSimulator.gyromagnetic_ratio"><code>MCMRSimulator.gyromagnetic_ratio</code></a></li><li><a href="#MCMRSimulator.Annulus"><code>MCMRSimulator.Annulus</code></a></li><li><a href="#MCMRSimulator.BaseObstruction"><code>MCMRSimulator.BaseObstruction</code></a></li><li><a href="#MCMRSimulator.BoundingBox"><code>MCMRSimulator.BoundingBox</code></a></li><li><a href="#MCMRSimulator.BuildingBlock"><code>MCMRSimulator.BuildingBlock</code></a></li><li><a href="#MCMRSimulator.BuildingBlock-Tuple{AbstractVector}"><code>MCMRSimulator.BuildingBlock</code></a></li><li><a href="#MCMRSimulator.BuildingBlock-Tuple{Union{Readout, MCMRSimulator.InstantComponent, MRGradients, RFPulse}}"><code>MCMRSimulator.BuildingBlock</code></a></li><li><a href="#MCMRSimulator.BuildingBlock-Tuple{Number}"><code>MCMRSimulator.BuildingBlock</code></a></li><li><a href="#MCMRSimulator.Collision"><code>MCMRSimulator.Collision</code></a></li><li><a href="#MCMRSimulator.CollisionProperties"><code>MCMRSimulator.CollisionProperties</code></a></li><li><a href="#MCMRSimulator.Cylinder"><code>MCMRSimulator.Cylinder</code></a></li><li><a href="#MCMRSimulator.FixedXoshiro"><code>MCMRSimulator.FixedXoshiro</code></a></li><li><a href="#MCMRSimulator.Float"><code>MCMRSimulator.Float</code></a></li><li><a href="#MCMRSimulator.Geometry"><code>MCMRSimulator.Geometry</code></a></li><li><a href="#MCMRSimulator.GlobalProperties"><code>MCMRSimulator.GlobalProperties</code></a></li><li><a href="#MCMRSimulator.GridShape"><code>MCMRSimulator.GridShape</code></a></li><li><a href="#MCMRSimulator.InstantGradient"><code>MCMRSimulator.InstantGradient</code></a></li><li><a href="#MCMRSimulator.InstantRFPulse"><code>MCMRSimulator.InstantRFPulse</code></a></li><li><a href="#MCMRSimulator.MRGradients"><code>MCMRSimulator.MRGradients</code></a></li><li><a href="#MCMRSimulator.MRIProperties"><code>MCMRSimulator.MRIProperties</code></a></li><li><a href="#MCMRSimulator.Mesh"><code>MCMRSimulator.Mesh</code></a></li><li><a href="#MCMRSimulator.Movement"><code>MCMRSimulator.Movement</code></a></li><li><a href="#MCMRSimulator.Obstruction"><code>MCMRSimulator.Obstruction</code></a></li><li><a href="#MCMRSimulator.ObstructionProperties"><code>MCMRSimulator.ObstructionProperties</code></a></li><li><a href="#MCMRSimulator.PlotPlane"><code>MCMRSimulator.PlotPlane</code></a></li><li><a href="#MCMRSimulator.PosVector"><code>MCMRSimulator.PosVector</code></a></li><li><a href="#MCMRSimulator.RFPulse"><code>MCMRSimulator.RFPulse</code></a></li><li><a href="#MCMRSimulator.Readout"><code>MCMRSimulator.Readout</code></a></li><li><a href="#MCMRSimulator.Reflection"><code>MCMRSimulator.Reflection</code></a></li><li><a href="#MCMRSimulator.Scanner"><code>MCMRSimulator.Scanner</code></a></li><li><a href="#MCMRSimulator.Sequence"><code>MCMRSimulator.Sequence</code></a></li><li><a href="#MCMRSimulator.SequencePart"><code>MCMRSimulator.SequencePart</code></a></li><li><a href="#MCMRSimulator.Shape-Tuple{MCMRSimulator.CompressedPulseqShape}"><code>MCMRSimulator.Shape</code></a></li><li><a href="#MCMRSimulator.Shape"><code>MCMRSimulator.Shape</code></a></li><li><a href="#MCMRSimulator.ShapePart"><code>MCMRSimulator.ShapePart</code></a></li><li><a href="#MCMRSimulator.Simulation"><code>MCMRSimulator.Simulation</code></a></li><li><a href="#MCMRSimulator.Snapshot"><code>MCMRSimulator.Snapshot</code></a></li><li><a href="#MCMRSimulator.Sphere"><code>MCMRSimulator.Sphere</code></a></li><li><a href="#MCMRSimulator.Spin"><code>MCMRSimulator.Spin</code></a></li><li><a href="#MCMRSimulator.SpinOrientation"><code>MCMRSimulator.SpinOrientation</code></a></li><li><a href="#MCMRSimulator.Spiral"><code>MCMRSimulator.Spiral</code></a></li><li><a href="#MCMRSimulator.TimeController"><code>MCMRSimulator.TimeController</code></a></li><li><a href="#MCMRSimulator.TransformObstruction"><code>MCMRSimulator.TransformObstruction</code></a></li><li><a href="#MCMRSimulator.Wall"><code>MCMRSimulator.Wall</code></a></li><li><a href="#MCMRSimulator.B0-Tuple{Scanner}"><code>MCMRSimulator.B0</code></a></li><li><a href="#MCMRSimulator.MT_fraction-Tuple{ObstructionProperties, Any}"><code>MCMRSimulator.MT_fraction</code></a></li><li><a href="#MCMRSimulator.R1"><code>MCMRSimulator.R1</code></a></li><li><a href="#MCMRSimulator.R2"><code>MCMRSimulator.R2</code></a></li><li><a href="#MCMRSimulator.T1"><code>MCMRSimulator.T1</code></a></li><li><a href="#MCMRSimulator.T2"><code>MCMRSimulator.T2</code></a></li><li><a href="#MCMRSimulator.add_TR-Tuple{MCMRSimulator.Shape, Number}"><code>MCMRSimulator.add_TR</code></a></li><li><a href="#MCMRSimulator.add_linear_diffusion_weighting-Tuple{Any, Any, Any}"><code>MCMRSimulator.add_linear_diffusion_weighting</code></a></li><li><a href="#MCMRSimulator.amplitude-Tuple{RFPulse, Vararg{Any}}"><code>MCMRSimulator.amplitude</code></a></li><li><a href="#MCMRSimulator.annuli-Tuple"><code>MCMRSimulator.annuli</code></a></li><li><a href="#MCMRSimulator.apply!-Tuple{InstantRFPulse, SpinOrientation}"><code>MCMRSimulator.apply!</code></a></li><li><a href="#MCMRSimulator.collided-Tuple{MCMRSimulator.BaseObstruction, MCMRSimulator.Collision}"><code>MCMRSimulator.collided</code></a></li><li><a href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>MCMRSimulator.color</code></a></li><li><a href="#MCMRSimulator.constant_pulse-Tuple{Number, Number, Number}"><code>MCMRSimulator.constant_pulse</code></a></li><li><a href="#MCMRSimulator.corners-Tuple{BoundingBox{3}}"><code>MCMRSimulator.corners</code></a></li><li><a href="#MCMRSimulator.correct_for_timestep-Tuple{Any, Any}"><code>MCMRSimulator.correct_for_timestep</code></a></li><li><a href="#MCMRSimulator.current_gradient-Tuple{Any, Any}"><code>MCMRSimulator.current_gradient</code></a></li><li><a href="#MCMRSimulator.current_instant-Tuple{Any, Any}"><code>MCMRSimulator.current_instant</code></a></li><li><a href="#MCMRSimulator.current_pulse-Tuple{Any, Any}"><code>MCMRSimulator.current_pulse</code></a></li><li><a href="#MCMRSimulator.cylinders-Tuple"><code>MCMRSimulator.cylinders</code></a></li><li><a href="#MCMRSimulator.detect_collision"><code>MCMRSimulator.detect_collision</code></a></li><li><a href="#MCMRSimulator.detect_collision"><code>MCMRSimulator.detect_collision</code></a></li><li><a href="#MCMRSimulator.direction-Tuple{MCMRSimulator.Reflection}"><code>MCMRSimulator.direction</code></a></li><li><a href="#MCMRSimulator.draw_step!-Union{Tuple{N}, Tuple{Spin{N}, StaticArraysCore.SVector{N, MCMRSimulator.SequencePart}, Float64, Float64, GlobalProperties, Geometry{0}}} where N"><code>MCMRSimulator.draw_step!</code></a></li><li><a href="#MCMRSimulator.duration-Tuple{AbstractVector}"><code>MCMRSimulator.duration</code></a></li><li><a href="#MCMRSimulator.dwell_time-Tuple{ObstructionProperties, Any}"><code>MCMRSimulator.dwell_time</code></a></li><li><a href="#MCMRSimulator.dwi-Tuple{}"><code>MCMRSimulator.dwi</code></a></li><li><a href="#MCMRSimulator.dyad_snapshot-Tuple"><code>MCMRSimulator.dyad_snapshot</code></a></li><li><a href="#MCMRSimulator.dyad_snapshot!-Tuple"><code>MCMRSimulator.dyad_snapshot!</code></a></li><li><a href="#MCMRSimulator.effective_pulse-Tuple{RFPulse, Number, Number}"><code>MCMRSimulator.effective_pulse</code></a></li><li><a href="#MCMRSimulator.effective_pulse-Tuple{Sequence, Number, Number}"><code>MCMRSimulator.effective_pulse</code></a></li><li><a href="#MCMRSimulator.empty_mri_properties-Tuple{MRIProperties}"><code>MCMRSimulator.empty_mri_properties</code></a></li><li><a href="#MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>MCMRSimulator.evolve</code></a></li><li><a href="#MCMRSimulator.evolve_to_time-Union{Tuple{N}, Tuple{Snapshot{N}, Simulation{N}, Float64}} where N"><code>MCMRSimulator.evolve_to_time</code></a></li><li><a href="#MCMRSimulator.evolve_to_time!-Union{Tuple{N}, Tuple{Spin{N}, Simulation{N}, StaticArraysCore.SVector{N, MCMRSimulator.SequencePart}, Float64, Float64}} where N"><code>MCMRSimulator.evolve_to_time!</code></a></li><li><a href="#MCMRSimulator.expand"><code>MCMRSimulator.expand</code></a></li><li><a href="#MCMRSimulator.fit_time-NTuple{6, Any}"><code>MCMRSimulator.fit_time</code></a></li><li><a href="#MCMRSimulator.flip_angle-Tuple{RFPulse}"><code>MCMRSimulator.flip_angle</code></a></li><li><a href="#MCMRSimulator.flip_angle-Tuple{InstantRFPulse}"><code>MCMRSimulator.flip_angle</code></a></li><li><a href="#MCMRSimulator.get_rotation-Tuple{Rotations.Rotation, Int64}"><code>MCMRSimulator.get_rotation</code></a></li><li><a href="#MCMRSimulator.get_sequence-Tuple{Spin, Any}"><code>MCMRSimulator.get_sequence</code></a></li><li><a href="#MCMRSimulator.get_time-Tuple{Snapshot}"><code>MCMRSimulator.get_time</code></a></li><li><a href="#MCMRSimulator.gradient-Tuple{MRGradients, Number}"><code>MCMRSimulator.gradient</code></a></li><li><a href="#MCMRSimulator.gradient-Tuple{AbstractVector, Sequence, Number}"><code>MCMRSimulator.gradient</code></a></li><li><a href="#MCMRSimulator.gradient_echo-Tuple{Any}"><code>MCMRSimulator.gradient_echo</code></a></li><li><a href="#MCMRSimulator.image_snapshot-Tuple"><code>MCMRSimulator.image_snapshot</code></a></li><li><a href="#MCMRSimulator.image_snapshot!-Tuple"><code>MCMRSimulator.image_snapshot!</code></a></li><li><a href="#MCMRSimulator.inside_MRI_properties-Union{Tuple{N}, Tuple{MCMRSimulator.BaseObstruction{N}, StaticArraysCore.SVector{N, Float64}}} where N"><code>MCMRSimulator.inside_MRI_properties</code></a></li><li><a href="#MCMRSimulator.inside_MRI_properties-Union{Tuple{N}, Tuple{Geometry{N}, StaticArraysCore.SVector{3, Float64}, MRIProperties}} where N"><code>MCMRSimulator.inside_MRI_properties</code></a></li><li><a href="#MCMRSimulator.isempty_block-Tuple{AbstractVector}"><code>MCMRSimulator.isempty_block</code></a></li><li><a href="#MCMRSimulator.isinside-Tuple{Any, AbstractVector}"><code>MCMRSimulator.isinside</code></a></li><li><a href="#MCMRSimulator.load_mesh-Tuple{IO}"><code>MCMRSimulator.load_mesh</code></a></li><li><a href="#MCMRSimulator.longitudinal"><code>MCMRSimulator.longitudinal</code></a></li><li><a href="#MCMRSimulator.lorentz_off_resonance"><code>MCMRSimulator.lorentz_off_resonance</code></a></li><li><a href="#MCMRSimulator.max_gradient"><code>MCMRSimulator.max_gradient</code></a></li><li><a href="#MCMRSimulator.max_slew_rate"><code>MCMRSimulator.max_slew_rate</code></a></li><li><a href="#MCMRSimulator.max_timestep_sticking-Tuple{MCMRSimulator.BaseObstruction, GlobalProperties, Number}"><code>MCMRSimulator.max_timestep_sticking</code></a></li><li><a href="#MCMRSimulator.merge_mri_parameters"><code>MCMRSimulator.merge_mri_parameters</code></a></li><li><a href="#MCMRSimulator.mesh_grid_intersection-Tuple{MCMRSimulator.GridShape, Vector{StaticArraysCore.SVector{3, Float64}}, Vector{StaticArraysCore.SVector{3, Int64}}}"><code>MCMRSimulator.mesh_grid_intersection</code></a></li><li><a href="#MCMRSimulator.next_gradient-Tuple{Any, Any}"><code>MCMRSimulator.next_gradient</code></a></li><li><a href="#MCMRSimulator.next_instant-Tuple{Any, Any}"><code>MCMRSimulator.next_instant</code></a></li><li><a href="#MCMRSimulator.next_pulse-Tuple{Any, Any}"><code>MCMRSimulator.next_pulse</code></a></li><li><a href="#MCMRSimulator.norm_angle-Tuple{Any}"><code>MCMRSimulator.norm_angle</code></a></li><li><a href="#MCMRSimulator.normal-Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}"><code>MCMRSimulator.normal</code></a></li><li><a href="#MCMRSimulator.off_resonance-Tuple{Cylinder, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}"><code>MCMRSimulator.off_resonance</code></a></li><li><a href="#MCMRSimulator.off_resonance"><code>MCMRSimulator.off_resonance</code></a></li><li><a href="#MCMRSimulator.off_resonance-Tuple{RFPulse, Vararg{Any}}"><code>MCMRSimulator.off_resonance</code></a></li><li><a href="#MCMRSimulator.off_resonance_gradient-Tuple{MCMRSimulator.BaseObstruction}"><code>MCMRSimulator.off_resonance_gradient</code></a></li><li><a href="#MCMRSimulator.orientation"><code>MCMRSimulator.orientation</code></a></li><li><a href="#MCMRSimulator.permeability-Tuple{ObstructionProperties, Any}"><code>MCMRSimulator.permeability</code></a></li><li><a href="#MCMRSimulator.phase-Tuple{RFPulse, Vararg{Any}}"><code>MCMRSimulator.phase</code></a></li><li><a href="#MCMRSimulator.phase-Tuple{InstantRFPulse}"><code>MCMRSimulator.phase</code></a></li><li><a href="#MCMRSimulator.phase"><code>MCMRSimulator.phase</code></a></li><li><a href="#MCMRSimulator.plot_geometry-Tuple"><code>MCMRSimulator.plot_geometry</code></a></li><li><a href="#MCMRSimulator.plot_geometry!-Tuple"><code>MCMRSimulator.plot_geometry!</code></a></li><li><a href="#MCMRSimulator.plot_off_resonance-Tuple"><code>MCMRSimulator.plot_off_resonance</code></a></li><li><a href="#MCMRSimulator.plot_off_resonance!-Tuple"><code>MCMRSimulator.plot_off_resonance!</code></a></li><li><a href="#MCMRSimulator.plot_snapshot"><code>MCMRSimulator.plot_snapshot</code></a></li><li><a href="#MCMRSimulator.plot_trajectory2d-Tuple"><code>MCMRSimulator.plot_trajectory2d</code></a></li><li><a href="#MCMRSimulator.plot_trajectory2d!-Tuple"><code>MCMRSimulator.plot_trajectory2d!</code></a></li><li><a href="#MCMRSimulator.plot_trajectory3d-Tuple"><code>MCMRSimulator.plot_trajectory3d</code></a></li><li><a href="#MCMRSimulator.plot_trajectory3d!-Tuple"><code>MCMRSimulator.plot_trajectory3d!</code></a></li><li><a href="#MCMRSimulator.ply_from_mesh-Tuple{Any}"><code>MCMRSimulator.ply_from_mesh</code></a></li><li><a href="#MCMRSimulator.position-Tuple{Snapshot}"><code>MCMRSimulator.position</code></a></li><li><a href="#MCMRSimulator.position-Tuple{Spin}"><code>MCMRSimulator.position</code></a></li><li><a href="#MCMRSimulator.previous_gradient-Tuple{Any, Any}"><code>MCMRSimulator.previous_gradient</code></a></li><li><a href="#MCMRSimulator.previous_instant-Tuple{Any, Any}"><code>MCMRSimulator.previous_instant</code></a></li><li><a href="#MCMRSimulator.previous_pulse-Tuple{Any, Any}"><code>MCMRSimulator.previous_pulse</code></a></li><li><a href="#MCMRSimulator.produces_off_resonance-Tuple{Geometry}"><code>MCMRSimulator.produces_off_resonance</code></a></li><li><a href="#MCMRSimulator.produces_off_resonance-Tuple{MCMRSimulator.BaseObstruction}"><code>MCMRSimulator.produces_off_resonance</code></a></li><li><a href="#MCMRSimulator.project-Tuple{PlotPlane, StaticArraysCore.SVector{3, Float64}}"><code>MCMRSimulator.project</code></a></li><li><a href="#MCMRSimulator.project-Union{Tuple{M}, Tuple{N}, Tuple{TransformObstruction{N, M, K, B, O} where {K, B&lt;:BoundingBox{N}, O&lt;:MCMRSimulator.BaseObstruction{N}}, StaticArraysCore.SVector{3, Float64}}} where {N, M}"><code>MCMRSimulator.project</code></a></li><li><a href="#MCMRSimulator.project-Union{Tuple{N}, Tuple{MCMRSimulator.GridShape{N}, StaticArraysCore.SVector{N, Float64}}} where N"><code>MCMRSimulator.project</code></a></li><li><a href="#MCMRSimulator.project_geometry-Union{Tuple{N}, Tuple{PlotPlane, TransformObstruction{N, M, K, B, O} where {M, K, B&lt;:BoundingBox{N}, O&lt;:MCMRSimulator.BaseObstruction{N}}}} where N"><code>MCMRSimulator.project_geometry</code></a></li><li><a href="#MCMRSimulator.project_on_grid-Tuple{PlotPlane, Snapshot{1}, Int64}"><code>MCMRSimulator.project_on_grid</code></a></li><li><a href="#MCMRSimulator.propose_times-Tuple{TimeController, Number, Number, AbstractVector{&lt;:Sequence}, Number}"><code>MCMRSimulator.propose_times</code></a></li><li><a href="#MCMRSimulator.random_annuli-Tuple{Any}"><code>MCMRSimulator.random_annuli</code></a></li><li><a href="#MCMRSimulator.random_cylinders-Tuple{Any}"><code>MCMRSimulator.random_cylinders</code></a></li><li><a href="#MCMRSimulator.random_on_sphere-Tuple{}"><code>MCMRSimulator.random_on_sphere</code></a></li><li><a href="#MCMRSimulator.random_positions_radii-Tuple{Any, Real, Int64}"><code>MCMRSimulator.random_positions_radii</code></a></li><li><a href="#MCMRSimulator.random_spheres-Tuple{Any}"><code>MCMRSimulator.random_spheres</code></a></li><li><a href="#MCMRSimulator.random_spirals-Tuple{Any}"><code>MCMRSimulator.random_spirals</code></a></li><li><a href="#MCMRSimulator.random_surface_positions-Tuple{MCMRSimulator.BaseObstruction{2}, BoundingBox{3}, Number, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}"><code>MCMRSimulator.random_surface_positions</code></a></li><li><a href="#MCMRSimulator.random_surface_spins-Union{Tuple{N}, Tuple{MCMRSimulator.BaseObstruction{N}, BoundingBox{3}, Number, StaticArraysCore.SVector{N, Float64}, Number, StaticArraysCore.SVector{N, Float64}}} where N"><code>MCMRSimulator.random_surface_spins</code></a></li><li><a href="#MCMRSimulator.ray_grid_intersections-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Float64}, StaticArraysCore.SVector{N, Float64}}} where N"><code>MCMRSimulator.ray_grid_intersections</code></a></li><li><a href="#MCMRSimulator.read_pulseq-Tuple{Any}"><code>MCMRSimulator.read_pulseq</code></a></li><li><a href="#MCMRSimulator.readout-Union{Tuple{N}, Tuple{Any, Simulation{N}}} where N"><code>MCMRSimulator.readout</code></a></li><li><a href="#MCMRSimulator.relax!"><code>MCMRSimulator.relax!</code></a></li><li><a href="#MCMRSimulator.rotate-Union{Tuple{M}, Tuple{N}, Tuple{BoundingBox{N}, StaticArraysCore.SMatrix{M, N}}} where {N, M}"><code>MCMRSimulator.rotate</code></a></li><li><a href="#MCMRSimulator.rotate_bvec-Tuple{AbstractVector{&lt;:Tuple{Real, Real}}, Any}"><code>MCMRSimulator.rotate_bvec</code></a></li><li><a href="#MCMRSimulator.sample-Union{Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}} where T"><code>MCMRSimulator.sample</code></a></li><li><a href="#MCMRSimulator.sample-Tuple{MCMRSimulator.Shape, Number, Number}"><code>MCMRSimulator.sample</code></a></li><li><a href="#MCMRSimulator.sample_derivative-Union{Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}} where T"><code>MCMRSimulator.sample_derivative</code></a></li><li><a href="#MCMRSimulator.sample_integral-Union{Tuple{T}, Tuple{MCMRSimulator.Shape, T, AbstractVector{T}}} where T&lt;:Number"><code>MCMRSimulator.sample_integral</code></a></li><li><a href="#MCMRSimulator.sample_integral-Union{Tuple{MCMRSimulator.Shape{T}}, Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}, Tuple{MCMRSimulator.Shape{T}, Number, Number}} where T"><code>MCMRSimulator.sample_integral</code></a></li><li><a href="#MCMRSimulator.sample_integral_step"><code>MCMRSimulator.sample_integral_step</code></a></li><li><a href="#MCMRSimulator.scatter_snapshot-Tuple"><code>MCMRSimulator.scatter_snapshot</code></a></li><li><a href="#MCMRSimulator.scatter_snapshot!-Tuple"><code>MCMRSimulator.scatter_snapshot!</code></a></li><li><a href="#MCMRSimulator.sequence_plot"><code>MCMRSimulator.sequence_plot</code></a></li><li><a href="#MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N"><code>MCMRSimulator.signal</code></a></li><li><a href="#MCMRSimulator.size_scale"><code>MCMRSimulator.size_scale</code></a></li><li><a href="#MCMRSimulator.spheres-Tuple"><code>MCMRSimulator.spheres</code></a></li><li><a href="#MCMRSimulator.spin_echo-Tuple{Any}"><code>MCMRSimulator.spin_echo</code></a></li><li><a href="#MCMRSimulator.spiral_theta-Tuple{Spiral, StaticArraysCore.SVector{2, Float64}}"><code>MCMRSimulator.spiral_theta</code></a></li><li><a href="#MCMRSimulator.spirals-Tuple"><code>MCMRSimulator.spirals</code></a></li><li><a href="#MCMRSimulator.stick_probability-NTuple{4, Number}"><code>MCMRSimulator.stick_probability</code></a></li><li><a href="#MCMRSimulator.stuck-Tuple{Spin}"><code>MCMRSimulator.stuck</code></a></li><li><a href="#MCMRSimulator.surface_MRI_properties-Tuple{MCMRSimulator.Collision, MRIProperties}"><code>MCMRSimulator.surface_MRI_properties</code></a></li><li><a href="#MCMRSimulator.surface_density-Tuple{ObstructionProperties, Any}"><code>MCMRSimulator.surface_density</code></a></li><li><a href="#MCMRSimulator.total_susceptibility-Tuple{MCMRSimulator.BaseObstruction}"><code>MCMRSimulator.total_susceptibility</code></a></li><li><a href="#MCMRSimulator.trajectory-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N"><code>MCMRSimulator.trajectory</code></a></li><li><a href="#MCMRSimulator.transfer!-Tuple{SpinOrientation, Float64}"><code>MCMRSimulator.transfer!</code></a></li><li><a href="#MCMRSimulator.transverse"><code>MCMRSimulator.transverse</code></a></li><li><a href="#MCMRSimulator.triangle_size-Tuple{Any, Any, Any}"><code>MCMRSimulator.triangle_size</code></a></li><li><a href="#MCMRSimulator.walls-Tuple{}"><code>MCMRSimulator.walls</code></a></li><li><a href="#MakieCore.plot!-Tuple{MakieCore.Combined{MCMRSimulator.dyad_snapshot}}"><code>MakieCore.plot!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.MCMRSimulator" href="#MCMRSimulator.MCMRSimulator"><code>MCMRSimulator.MCMRSimulator</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This package supports the running of MR Monte Carlo simulations.</p><p>In these simulations hundreds of thousands or millions of <a href="#MCMRSimulator.Spin"><code>Spin</code></a> particles randomly diffuse through some tissue microstructure. At each timepoint these spins are represented as a <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> object. The spin diffusion is constrained by a set of <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a> objects stored in a <a href="#MCMRSimulator.Geometry"><code>Geometry</code></a> object. The spins of these particles will be evolved based on the Bloch equations with the field strength and relaxation rates set by the local geometry and the effect of one or more <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> objects. All these variables are combined into a single <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> object.  See <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> for how to run the simulation.</p><p>Plotting support for the sequence and resulting signal is also available based on <a href="https://makie.juliaplots.org/stable/">Makie.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/MCMRSimulator.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Siemens_Connectom" href="#MCMRSimulator.Siemens_Connectom"><code>MCMRSimulator.Siemens_Connectom</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Siemens 3T Connectom MRI scanner (<a href="../references/#fan22_MappingHumanConnectome">Qiuyun Fan, Cornelius Eichner, Maryam Afzali, Lars Mueller, Chantal M. W. Tax, Mathias Davids, Mirsad Mahmutovic, Boris Keil, Berkin Bilgic, Kawin Setsompop, Hong-Hsi Lee, Qiyuan Tian, Chiara Maffei, Gabriel {Ramos-Llord{\&#39;e}n}, Aapo Nummenmaa, Thomas Witzel, Anastasia Yendiki, Yi-Qiao Song, Chu-Chung Huang, Ching-Po Lin, Nikolaus Weiskopf, Alfred Anwander, Derek K. Jones, Bruce R. Rosen, Lawrence L. Wald, Susie Y. Huang (2022)</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/scanner.jl#L63-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Siemens_Prisma" href="#MCMRSimulator.Siemens_Prisma"><code>MCMRSimulator.Siemens_Prisma</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Siemens MAGNETOM 3T Prisma MRI scanner (https://www.siemens-healthineers.com/en-uk/magnetic-resonance-imaging/3t-mri-scanner/magnetom-prisma).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/scanner.jl#L53-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Siemens_Terra" href="#MCMRSimulator.Siemens_Terra"><code>MCMRSimulator.Siemens_Terra</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Siemens MAGNETOM 7T Terra MRI scanner (https://www.siemens-healthineers.com/en-uk/magnetic-resonance-imaging/7t-mri-scanner/magnetom-terra)</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/scanner.jl#L58-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.gyromagnetic_ratio" href="#MCMRSimulator.gyromagnetic_ratio"><code>MCMRSimulator.gyromagnetic_ratio</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>gyromagnetic ratio of a proton (1H) in water in kHz/T</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/constants.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Annulus" href="#MCMRSimulator.Annulus"><code>MCMRSimulator.Annulus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Annulus(inner_radius, outer_radius; chi_I=-0.1, chi_A=-0.1, myelin=false)</code></pre><p>Create an annulus with an inner and outer radius. Using <a href="#MCMRSimulator.annuli-Tuple"><code>annuli</code></a> is recommended. Water can freely diffuse within the inner radius, and between the inner and outer radius, but not in between. Myelin can be added by setting <code>myelin</code> to true. Restrictions are only present at the inner and outer cylinder, not in the myelin in between.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/annulus.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.BaseObstruction" href="#MCMRSimulator.BaseObstruction"><code>MCMRSimulator.BaseObstruction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Base obstruction type hindering free diffusion.</p><p>These obstructions are always perfectly aligned with the main axes and centered at the origin (except for <a href="#MCMRSimulator.Mesh"><code>Mesh</code></a>). They can be moved/rotated/repeated by applying <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a>.</p><p>The dimensionality N indicates the dimensionality of the input data  (1 for <a href="#MCMRSimulator.Wall"><code>Wall</code></a>, 2 for <a href="#MCMRSimulator.Cylinder"><code>Cylinder</code></a>, 3 for <a href="#MCMRSimulator.Sphere"><code>Sphere</code></a> or <a href="#MCMRSimulator.Mesh"><code>Mesh</code></a>).</p><p>Each obstruction needs to define the following interface:</p><ul><li><a href="#MCMRSimulator.detect_collision"><code>detect_collision</code></a>(movement, obstruction, previous_collision): returns any interesection between the movement and the obstruction</li><li><a href="#MCMRSimulator.produces_off_resonance-Tuple{Geometry}"><code>produces_off_resonance</code></a>(obstruction), optional: whether the obstruction produces an off-resonance field (false by default). If true, the obstruction should also define:<ul><li><a href="#MCMRSimulator.lorentz_off_resonance"><code>lorentz_off_resonance</code></a>(obstruction, position, ...): computes the off-resonance due to the obstruction at position</li><li><a href="#MCMRSimulator.total_susceptibility-Tuple{MCMRSimulator.BaseObstruction}"><code>total_susceptibility</code></a>(obstruction): computes total susceptibility caused by this obstruction</li><li><a href="#MCMRSimulator.off_resonance_gradient-Tuple{MCMRSimulator.BaseObstruction}"><code>off_resonance_gradient</code></a>(obstruction): computes the maximum off-resonance gradient induced by this obstruction</li></ul></li><li><a href="#MCMRSimulator.isinside-Tuple{Any, AbstractVector}"><code>isinside</code></a>(obstruction, position): true if position is inside the obstruction</li><li><a href="#MCMRSimulator.BoundingBox"><code>BoundingBox</code></a>(obstruction): returns a [<code>BoundingBox</code>] fully containing the obstruction</li><li><a href="#MCMRSimulator.size_scale"><code>size_scale</code></a>(obstruction): returns a scale of the size of the object; used to estimate a maximum size step in the simulation</li><li><a href="#MCMRSimulator.random_surface_positions-Tuple{MCMRSimulator.BaseObstruction{2}, BoundingBox{3}, Number, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}"><code>random_surface_positions</code></a>(obstruction, density): returns a set of random positions (and associated normals/indices) along the obstruction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.BoundingBox" href="#MCMRSimulator.BoundingBox"><code>MCMRSimulator.BoundingBox</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundingBox(lower::PosVector, upper::PosVector)
BoundingBox(radius::Number)
BoundingBox(obstruction::Obstruction)
BoundingBox(obstructions)</code></pre><p>Creates a bounding box containing one or more <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a>. For infinitely repeated objects (using <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a>) the bounding box of the central object is returned.</p><p>Check whether particles are inside using <a href="#MCMRSimulator.isinside-Tuple{Any, AbstractVector}"><code>isinside</code></a>.</p><p>For symmetric obstructions centered at origin (e.g., base cylinders, spheres, walls, annuli, and spirals), a <code>SymmetricBoundingBox</code> is used, which only stores the radius (0 for a wall). For all other cases a <code>GenericBoundingBox</code> is used, which stores the lower and upper bounds as vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/bounding_box.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.BuildingBlock" href="#MCMRSimulator.BuildingBlock"><code>MCMRSimulator.BuildingBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BuildingBlock(; components=vector of pulses/gradients, duration=minimum)</code></pre><p>Creates a sequence building block by overlapping zero or more pulses/gradients.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence_builder/building_blocks.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.BuildingBlock-Tuple{AbstractVector}" href="#MCMRSimulator.BuildingBlock-Tuple{AbstractVector}"><code>MCMRSimulator.BuildingBlock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BuildingBlock([building block like objects...])</code></pre><p>Creates a sequence building block by concatenating all the <a href="#MCMRSimulator.BuildingBlock"><code>BuildingBlock</code></a>-like objects in the vector. Each building block will play out sequenctially.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence_builder/building_blocks.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.BuildingBlock-Tuple{Number}" href="#MCMRSimulator.BuildingBlock-Tuple{Number}"><code>MCMRSimulator.BuildingBlock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BuildingBlock(delay::Number)</code></pre><p>Creates an empty sequence building block representing a delay of <code>delay</code> ms.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence_builder/building_blocks.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.BuildingBlock-Tuple{Union{Readout, MCMRSimulator.InstantComponent, MRGradients, RFPulse}}" href="#MCMRSimulator.BuildingBlock-Tuple{Union{Readout, MCMRSimulator.InstantComponent, MRGradients, RFPulse}}"><code>MCMRSimulator.BuildingBlock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BuildingBlock(pulse/gradient)</code></pre><p>Creates an building block containing just the <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a>, <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a>, <a href="#MCMRSimulator.MRGradients"><code>MRGradients</code></a>, <a href="#MCMRSimulator.InstantGradient"><code>InstantGradient</code></a>, or [<code>Readout</code>]. The duration will be set to the length of the pulse/gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence_builder/building_blocks.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Collision" href="#MCMRSimulator.Collision"><code>MCMRSimulator.Collision</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Collision(distance, normal, properties; index=0, inside=false)</code></pre><p>A detected collision along the movement.</p><p><strong>Parameters</strong></p><ul><li><code>distance</code>: number between 0 and 1 indicating the distance of the collision from the origin (0) to the destination point (1)</li><li><code>normal</code>: normal of the obstruction at the collision site. To get correct reflection the normal should point in the direction of the incoming particle.</li><li><code>properties</code>: <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a> of the obstruction the spin collided with.</li><li><code>index</code>: Index of which triangle in <a href="#MCMRSimulator.Mesh"><code>Mesh</code></a> got hit</li><li><code>inside</code>: Whether the obstruction was hit on the inside or the outside. For a mesh triangle the outside is considered in the direction of the normal. For a wall the outside is in the positive direction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/collision.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.CollisionProperties" href="#MCMRSimulator.CollisionProperties"><code>MCMRSimulator.CollisionProperties</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CollisionProperties(MT_fraction, permeability, surface_density, dwell_time)</code></pre><p>Object used to define the collision properties within a <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a> or a [<code>GlobalProperties</code>] object. Values of NaN are used in [<code>ObstructionProperties</code>] to indicate that the default collision parameter should be used.</p><p>These properties can be retrieved using:</p><ul><li><a href="#MCMRSimulator.MT_fraction-Tuple{ObstructionProperties, Any}"><code>MT_fraction</code></a></li><li><a href="#MCMRSimulator.permeability-Tuple{ObstructionProperties, Any}"><code>permeability</code></a></li><li><a href="#MCMRSimulator.surface_density-Tuple{ObstructionProperties, Any}"><code>surface_density</code></a></li><li><a href="#MCMRSimulator.dwell_time-Tuple{ObstructionProperties, Any}"><code>dwell_time</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L131-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Cylinder" href="#MCMRSimulator.Cylinder"><code>MCMRSimulator.Cylinder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cylinder(radius; chi_I=-0.1, chi_A=-0.1, g_ratio=1)</code></pre><p>Creates a hollow cylinder with a radius of <code>radius</code> micrometer (default 1 micrometer) at the given <code>location</code> (default: origin). Generate cylinders using <a href="#MCMRSimulator.cylinders-Tuple"><code>cylinders</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/cylinder.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.FixedXoshiro" href="#MCMRSimulator.FixedXoshiro"><code>MCMRSimulator.FixedXoshiro</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Immutable version of the Xoshiro random number generator state</p><p>Used to store the current state in the Spin object. To evolve the spin in a predictable manner set the seed using <code>copy!(spin.rng, Random.TaskLocalRNG)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Float" href="#MCMRSimulator.Float"><code>MCMRSimulator.Float</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Float type used during the simulation (default: Float64). This has to be changed in the code.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/constants.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Geometry" href="#MCMRSimulator.Geometry"><code>MCMRSimulator.Geometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Geometry(obstructions...)</code></pre><p>Represents the tissue geometry as one or more <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a> objects. Any <a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a> passed on will be converted into a <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a> before being added to the geometry.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/geometry_struct.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.GlobalProperties" href="#MCMRSimulator.GlobalProperties"><code>MCMRSimulator.GlobalProperties</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GlobalProperties(; MT_fraction=0, permeability=0, R1=0, T1=Inf, R2=0, T2=Inf, off_resonance=0)</code></pre><p>Defines a default set of collision and relaxation parameters for a simulation. These parameters can be locally overriden by <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p><p>Parameters can be accessed using their accessors:</p><ul><li><a href="#MCMRSimulator.MT_fraction-Tuple{ObstructionProperties, Any}"><code>MT_fraction</code></a></li><li><a href="#MCMRSimulator.permeability-Tuple{ObstructionProperties, Any}"><code>permeability</code></a></li><li><a href="#MCMRSimulator.surface_density-Tuple{ObstructionProperties, Any}"><code>surface_density</code></a></li><li><a href="#MCMRSimulator.dwell_time-Tuple{ObstructionProperties, Any}"><code>dwell_time</code></a></li><li><a href="#MCMRSimulator.T1"><code>T1</code></a></li><li><a href="#MCMRSimulator.R1"><code>R1</code></a></li><li><a href="#MCMRSimulator.T2"><code>T2</code></a></li><li><a href="#MCMRSimulator.R2"><code>R2</code></a></li><li><a href="#MCMRSimulator.off_resonance"><code>off_resonance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L191-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.GridShape" href="#MCMRSimulator.GridShape"><code>MCMRSimulator.GridShape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridShape(bounding_box::BoundingBox, size::SVector{3, Int})
GridShape(bounding_box::BoundingBox, size::Int)</code></pre><p>Defines a 3D grid within the <a href="#MCMRSimulator.BoundingBox"><code>BoundingBox</code></a>.  <code>size</code> sets the number of voxels along each dimension. Setting <code>size</code> to a single integer will set that number along each dimension  (except dimensions of infinite size, which are always just one voxel wide).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/grid.jl#L76-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.InstantGradient" href="#MCMRSimulator.InstantGradient"><code>MCMRSimulator.InstantGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InstantGradient(; qvec=[0, 0, 0], q_origin=0, time=0.)</code></pre><p>Infinitely short gradient pulse that encodes phase information given by <code>qvec</code> (units: number of rotations/um) and <code>q_origin</code> (units: number of rotations).</p><p>The number of time a spins at given <code>position</code> is rotated is given by <code>qvec ⋅ position + q_origin</code>.</p><p>The pulse is applied at given <code>time</code> (in milliseconds). Retrieve this time using <a href="#MCMRSimulator.get_time-Tuple{Snapshot}"><code>get_time</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/instants.jl#L89-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.InstantRFPulse" href="#MCMRSimulator.InstantRFPulse"><code>MCMRSimulator.InstantRFPulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InstantRFPulse(;time=0., flip_angle=0., phase=0.)</code></pre><p>Instantaneous radio-frequency pulse that flips the spins by <code>flip_angle</code> degrees in a plane perpendicular to an axis in the x-y plane with an angle of <code>phase</code> degrees with respect to the x-axis at given <code>time</code>. Angles are in degrees and the <code>time</code> is in milliseconds. Angles can be retrieved using <a href="#MCMRSimulator.flip_angle-Tuple{InstantRFPulse}"><code>flip_angle</code></a> and <a href="#MCMRSimulator.phase"><code>phase</code></a>. Time can be retrieved using <a href="#MCMRSimulator.get_time-Tuple{Snapshot}"><code>get_time</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/instants.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.MRGradients" href="#MCMRSimulator.MRGradients"><code>MCMRSimulator.MRGradients</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MRGradients(times, amplitudes; origin=[0, 0, 0])
MRGradients([(time0, amplitude0), (time1, amplitude1), ...]; origin=[0, 0, 0])</code></pre><p>Defines a gradient profile with the gradients (unit: kHz/um) linearly interpolated between the given times (unit: ms). Amplitudes can be a 3D vector or a single value. In the latter case the gradients are assumed to point in the z-direction (can be rotated using <a href="#MCMRSimulator.rotate_bvec-Tuple{AbstractVector{&lt;:Tuple{Real, Real}}, Any}"><code>rotate_bvec</code></a>). The gradients are centered on given <code>origin</code> (unit: um). They can be sampled using <a href="#MCMRSimulator.gradient-Tuple{AbstractVector, Sequence, Number}"><code>gradient</code></a>.</p><pre><code class="nohighlight hljs">MRGradients(Gx, Gy, Gz; origin=[0, 0, 0])</code></pre><p>Builds the MR gradients out of 3 <a href="#MCMRSimulator.Shape"><code>Shape</code></a> objects each describing the gradient profile in 1 dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/gradients.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.MRIProperties" href="#MCMRSimulator.MRIProperties"><code>MCMRSimulator.MRIProperties</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MRIProperties(; R1=, R2=, T1=, T2=, off_resonance=)</code></pre><p>Object used to define the MRI relaxation properties within a <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a> or a [<code>GlobalProperties</code>] object. Either the relaxation rate (R1/R2) or the relaxation time (T1/T2) should be set (or neither).</p><p>Values of NaN are used in [<code>ObstructionProperties</code>] to indicate that the default relaxation parameter should be used.</p><p>These relaxation variables can be retrieved using:</p><ul><li><a href="#MCMRSimulator.T1"><code>T1</code></a></li><li><a href="#MCMRSimulator.R1"><code>R1</code></a></li><li><a href="#MCMRSimulator.T2"><code>T2</code></a></li><li><a href="#MCMRSimulator.R2"><code>R2</code></a></li><li><a href="#MCMRSimulator.off_resonance"><code>off_resonance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Mesh" href="#MCMRSimulator.Mesh"><code>MCMRSimulator.Mesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Mesh(vertices, triangles)</code></pre><p>An <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a> formed from a triangular mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/mesh.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Movement" href="#MCMRSimulator.Movement"><code>MCMRSimulator.Movement</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Intermediate object used internally to represent a movement from one position to another</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/movement.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Obstruction" href="#MCMRSimulator.Obstruction"><code>MCMRSimulator.Obstruction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of any obstruction to the free diffusion of water. Some might also generate off-resonance fields.</p><p>There are two types of obstructions:</p><ul><li><a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a> with the basic obstructions (walls, sphere, cylinders, meshes)</li><li><a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a>, which transform the base obstructions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/geometry.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.ObstructionProperties" href="#MCMRSimulator.ObstructionProperties"><code>MCMRSimulator.ObstructionProperties</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObstructionProperties(; MT_fraction, permeability, relative_density, dwell_time, R1_inside, T1_inside, R2_inside, T2_inside, off_resonance_inside, R1_surface, T1_surface, R2_surface, T2_surface, off_resonance_surface)</code></pre><p>Defines the collision and relaxation properties for an obstruction. Either the relaxation rate (R1/R2) or the relaxation time (T1/T2) should be set (or neither).</p><p>Collision parameters can be retreived using their accessors: <a href="#MCMRSimulator.MT_fraction-Tuple{ObstructionProperties, Any}"><code>MT_fraction</code></a>, <a href="#MCMRSimulator.permeability-Tuple{ObstructionProperties, Any}"><code>permeability</code></a>, <a href="#MCMRSimulator.surface_density-Tuple{ObstructionProperties, Any}"><code>surface_density</code></a>, and <a href="#MCMRSimulator.dwell_time-Tuple{ObstructionProperties, Any}"><code>dwell_time</code></a>.</p><p>MRI relaxation parameters within the obstruction can be retrieved by calling their accessor on <code>obstruction_properties.inside</code> (for spins inside the obstruction) or <code>obstruction_properties.surface</code> (for spins stuck at the surface of the obstruction). The accessors are <a href="#MCMRSimulator.T1"><code>T1</code></a>, <a href="#MCMRSimulator.R1"><code>R1</code></a>, <a href="#MCMRSimulator.T2"><code>T2</code></a>, <a href="#MCMRSimulator.R2"><code>R2</code></a>, and <a href="#MCMRSimulator.off_resonance"><code>off_resonance</code></a>.</p><p>For any property not set (or set to NaN) the default values will be used (i.e., from the <a href="#MCMRSimulator.GlobalProperties"><code>GlobalProperties</code></a>, which is set during the creation of the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L150-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.PlotPlane" href="#MCMRSimulator.PlotPlane"><code>MCMRSimulator.PlotPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a finite plane in the 3D space used for plotting.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PlotPlane(normal::PosVector=[0, 0, 1], position::PosVector=[0, 0, 0]; size=10., sizex=&lt;size&gt;, sizey=&lt;size&gt;, ngrid=100)</code></pre><p>Arguments:</p><ul><li><code>normal</code>: length-3 vector with the orientation perpendicular to the plane (default to z-direction).</li><li><code>position</code>: position of plane as a length-3 vector (defaults to origin).</li><li><code>sizex</code>: size of the plane in the x-direction (before rotating to <code>normal</code>).</li><li><code>sizey</code>: size of the plane in the y-direction (before rotating to <code>normal</code>).</li><li><code>size</code>: set default value for <code>sizex</code> and <code>sizey</code>.</li><li><code>ngrid</code>: number of grid elements to split the plane up into for plotting.</li></ul><p><strong>Spin projection onto plane</strong></p><p>See <a href="#MCMRSimulator.project-Tuple{PlotPlane, StaticArraysCore.SVector{3, Float64}}"><code>project</code></a> for details on how spins are projected onto the <code>PlotPlane</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/plot_plane.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.PosVector" href="#MCMRSimulator.PosVector"><code>MCMRSimulator.PosVector</code></a> — <span class="docstring-category">Type</span></header><section><div><p>General definition used for length-3 vectors. Mostly used for positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/constants.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.RFPulse" href="#MCMRSimulator.RFPulse"><code>MCMRSimulator.RFPulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RFPulse(times, amplitudes[, phases]; phase0=0, off_resonance=0)</code></pre><p>Creates a radio-frequency block between times <code>t0</code> and <code>t1</code>. At time <code>t0</code> the phase of the transverse B1 magnetic field is equal to <code>phase0</code> (given in degrees).</p><p>The amplitude and frequency modulation profile of the RF pulse are provided as functions:</p><ul><li>The amplitude represents the strength of the magnetic field in kHz within the transverse plane as a function of time (between t0 and t1). This should always be positive.</li><li>The phase represents the offset from the Larmor frequency in degrees as a function of time (between t0 and t1). If not provided explicitly, the phase is presumed to be a linear function starting with an initial <code>phase0</code> (in degrees) and increasing by the <code>off_resonance</code> (in kHz).</li></ul><p>The functions <a href="#MCMRSimulator.amplitude-Tuple{RFPulse, Vararg{Any}}"><code>amplitude</code></a>, <a href="#MCMRSimulator.phase"><code>phase</code></a>, and <a href="#MCMRSimulator.off_resonance"><code>off_resonance</code></a> are used to get the value at a specific <code>t</code> or averaged between two times. <a href="#MCMRSimulator.flip_angle-Tuple{InstantRFPulse}"><code>flip_angle</code></a> computes the total flip angle for particles perfectly in phase with the RF pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/radio_frequency.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Readout" href="#MCMRSimulator.Readout"><code>MCMRSimulator.Readout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Readout(;time=0)</code></pre><p>Readout the spins at the given <code>time</code> (in milliseconds) each TR</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/instants.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Reflection" href="#MCMRSimulator.Reflection"><code>MCMRSimulator.Reflection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Reflection(collision, movement, timestep)
Reflection(collision, timestep, fraction_used, direction)</code></pre><p>Represents a reflection of a particle after colliding (see <a href="#MCMRSimulator.Collision"><code>Collision</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/reflection.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Scanner" href="#MCMRSimulator.Scanner"><code>MCMRSimulator.Scanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Scanner(;B0=3., max_gradient=Inf, max_slew_rate=Inf, units=:kHz)</code></pre><p>Properties of an MRI scanner relevant for the MR signal simulations.</p><ul><li><a href="#MCMRSimulator.B0-Tuple{Scanner}"><code>B0</code></a>: magnetic field strength (in Tesla)</li><li><a href="#MCMRSimulator.max_gradient"><code>max_gradient</code></a>: maximum gradient strength long each axis.</li><li><a href="#MCMRSimulator.max_slew_rate"><code>max_slew_rate</code></a>: maximum rate of change in the gradient strength</li></ul><p>By default <code>gradient</code> and <code>slew_rate</code> are expected to be provided in units of, respectively, kHz/um and kHz/um/ms. However, if the keyword <code>units=:Tesla</code> is set, the <code>gradient</code> and <code>slew_rate</code> should be provided in units of, respectively, mT/m and T/m/s.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/scanner.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Sequence" href="#MCMRSimulator.Sequence"><code>MCMRSimulator.Sequence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sequence(;TR, components=[], scanner=Scanner(B0), B0=3., interplate_gradients=:step)</code></pre><p>An MR sequence represented by a series of components repeated with a given repetition time (<code>TR</code>).</p><p>Possible sequence components are:</p><ul><li><a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a>: Radio-frequency pulse with user-provided amplitude and phase profile.</li><li><a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a>: instantaneous approximation of a radio-frequency pulse flipping the spin orientations.</li><li><a href="#MCMRSimulator.MRGradients"><code>MRGradients</code></a>: MRI gradient profiles</li><li><a href="#MCMRSimulator.InstantGradient"><code>InstantGradient</code></a>: instantaneous gradients encoding spatial patterns in the spin phase distribution.</li><li><a href="#MCMRSimulator.Readout"><code>Readout</code></a>: Store the spins at this timepoint.</li></ul><p>The previous/current/next [<code>RFPulse</code>] at a specific time is given by <a href="#MCMRSimulator.previous_pulse-Tuple{Any, Any}"><code>previous_pulse</code></a>, <a href="#MCMRSimulator.current_pulse-Tuple{Any, Any}"><code>current_pulse</code></a>, or <a href="#MCMRSimulator.next_pulse-Tuple{Any, Any}"><code>next_pulse</code></a>.  Equivalent functions are available to [<code>MRGradients</code>] called <a href="#MCMRSimulator.previous_gradient-Tuple{Any, Any}"><code>previous_gradient</code></a>, <a href="#MCMRSimulator.current_gradient-Tuple{Any, Any}"><code>current_gradient</code></a>, or <a href="#MCMRSimulator.next_gradient-Tuple{Any, Any}"><code>next_gradient</code></a>. All of these will return <code>nothing</code> if there is no previous/current/next gradient/RF pulse.</p><p>The same functions exist for the previous/current/next instantaneous gradient/RF pulse (i.e., <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a> or <a href="#MCMRSimulator.InstantGradient"><code>InstantGradient</code></a>), namely <a href="#MCMRSimulator.previous_instant-Tuple{Any, Any}"><code>previous_instant</code></a>, <a href="#MCMRSimulator.current_instant-Tuple{Any, Any}"><code>current_instant</code></a>, or <a href="#MCMRSimulator.next_instant-Tuple{Any, Any}"><code>next_instant</code></a>. </p><p>Note that all gradients/pulses repeat every <code>TR</code> milliseconds.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L6-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.SequencePart" href="#MCMRSimulator.SequencePart"><code>MCMRSimulator.SequencePart</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SequencePart(sequence, t1, t2)</code></pre><p>Represents a small part of a <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> between times <code>t1</code> and <code>t2</code>. During this time the RF pulse and gradients are assumed to change linearly and hence can be represented as <a href="#MCMRSimulator.ShapePart"><code>ShapePart</code></a> objects. This is used to guide the spin evolution during the timestep between times <code>t1</code> and <code>t2</code> in the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L178-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Shape" href="#MCMRSimulator.Shape"><code>MCMRSimulator.Shape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Shape(times, amplitudes; normalise=false)</code></pre><p>Defines a <a href="#MCMRSimulator.Shape"><code>Shape</code></a> profile for an RF pulse or gradient profile. The <code>Shape</code> is parametrised by the number of control points <code>N</code> and the type of the amplitude object <code>T</code>. This amplitude type will be <code>Float</code> for the amplitude and phase of the <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a>. It will be <code>SVector{3, Float}</code> for <a href="#MCMRSimulator.MRGradients"><code>MRGradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/shape.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Shape-Tuple{MCMRSimulator.CompressedPulseqShape}" href="#MCMRSimulator.Shape-Tuple{MCMRSimulator.CompressedPulseqShape}"><code>MCMRSimulator.Shape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Shape(shape::CompressedPulseqShape)</code></pre><p>Create a <code>Shape</code> object based on the pulseq Shape format.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/pulseq.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.ShapePart" href="#MCMRSimulator.ShapePart"><code>MCMRSimulator.ShapePart</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShapePart(shape, t0, t1)</code></pre><p>Represents a small part of a <a href="#MCMRSimulator.Shape"><code>Shape</code></a> between <code>t0</code> and <code>t1</code> during which the amplitude varies linearly. This object is used to store the relevant part of the RF and gradient profiles within a single timestep (see <a href="#MCMRSimulator.SequencePart"><code>SequencePart</code></a>).</p><p>Like the full shape values can be extracted using <a href="#MCMRSimulator.sample-Tuple{MCMRSimulator.Shape, Number, Number}"><code>sample</code></a>, <a href="#MCMRSimulator.sample_derivative-Union{Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}} where T"><code>sample_derivative</code></a>, <a href="#MCMRSimulator.sample_integral-Union{Tuple{MCMRSimulator.Shape{T}}, Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}, Tuple{MCMRSimulator.Shape{T}, Number, Number}} where T"><code>sample_integral</code></a>. The time passed on to these functions should be between 0 (for <code>t0</code>) and 1 (for <code>t1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/shape.jl#L164-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Simulation" href="#MCMRSimulator.Simulation"><code>MCMRSimulator.Simulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Simulation(
    sequences; geometry=Obstruction[], diffusivity=0.,
    R1=0, T1=Inf, R2=0, T2=Inf, off_resonance=0, MT_fraction=0, permeability=0,, 
    max_timestep=&lt;geometry-based default&gt;, gradient_precision=1, rf_rotation=1.,
)</code></pre><p>Defines the setup of the simulation and stores the output of the run.</p><p><strong>Argument</strong></p><p><strong>General parameters:</strong></p><ul><li><code>sequences</code>: Vector of <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> objects. During the spin random walk the simulation will keep track of the spin magnetisations for all of the provided sequences.</li><li><code>geometry</code>: Set of obstructions, which can be used to restrict the diffusion, produce off-resonance fields, alter the local T1/T2 relaxation, and as sources of magnetisation transfer.</li><li><code>diffusivity</code>: Rate of the random motion of the spins in um^2/ms.</li></ul><p><strong>MRI properties</strong></p><p>These parameters determine the evolution and relaxation of the spin magnetisation.</p><ul><li><code>R1</code>/<code>T1</code>: sets the longitudinal relaxation rate (R1 in kHz) or relaxation time (T1=1/R1 in ms). This determines how fast the longitudinal magnetisation returns to its equilibrium value of 1.</li><li><code>R2</code>/<code>T2</code>: sets the transverse relaxation rate (R2 in kHz) or relaxation time (T2=1/R2 in ms). This determines how fast the transverse magnetisation is lost.</li><li><code>off_resonance</code>: Size of the off-resonance field in this voxel in kHz.</li></ul><p>These MRI properties can be overriden for spins inside the <a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a> objects of the <code>geoemtry</code>.</p><p><strong>Collision parameters</strong></p><p>These parameters determine how parameters behave when hitting the <a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a> objects of the <code>geoemtry</code>. They can be overriden for individual [<code>BaseObstruction</code>] objects.</p><ul><li><code>MT_fraction</code>: the fraction of magnetisation transfered between the obstruction and the water spin at each collision.</li><li><code>permeability</code>: the probability that the spin will pass through the obstruction.</li><li><code>surface_density</code>: Density of spins stuck on the surface relative to the volume density of hte free water.</li><li><code>dwell_time</code>: Typical time that spins will stay at the surface after getting stuck.</li></ul><p>Note that <code>MT_fraction</code> and <code>permeability</code> are internally adjusted to make their effect independent of the timestep (see <a href="#MCMRSimulator.correct_for_timestep-Tuple{Any, Any}"><code>correct_for_timestep</code></a>).</p><p><strong>Timestep parameters</strong></p><p>These parameters (<code>max_timestep</code>, <code>gradient_precision</code>, and <code>rf_rotation</code>) control the timepoints at which the simulation is evaluated. The default values should work well. For more details on how to adjust them, see <a href="#MCMRSimulator.TimeController"><code>TimeController</code></a>.</p><p><strong>Running the simulation</strong></p><p>To run a <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> of spins through the simulations you can use one of the following functions:</p><ul><li><a href="#MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>evolve</code></a>: evolves the spins in the snapshot until a single given time and returns that state in a new <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a>.</li><li><a href="#MCMRSimulator.trajectory-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N"><code>trajectory</code></a>: returns full spin trajectory (recommended only for small number of spins).</li><li><a href="#MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N"><code>signal</code></a>: returns signal variation over time.</li><li><a href="#MCMRSimulator.readout-Union{Tuple{N}, Tuple{Any, Simulation{N}}} where N"><code>readout</code></a>: returns the snapshots at the sequence readouts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/readout.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Snapshot" href="#MCMRSimulator.Snapshot"><code>MCMRSimulator.Snapshot</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents the positions and orientations of multiple <a href="#MCMRSimulator.Spin"><code>Spin</code></a> objects at a specific <code>time</code>.</p><p>Note that times are in milliseconds and positions in micrometer.  The equilibrium longitudinal spin (after T1 relaxation) is always 1.</p><p><strong>Useful constructors</strong></p><pre><code class="nohighlight hljs">Snapshot(positions; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)
Snapshot(nspins[, bounding_box[, geometry, default_surface_density]]; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)
Snapshot(nspins, simulation[, bounding_box; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)</code></pre><p>Creates a new Snapshot at the given <code>time</code> with spins initialised for simulating <code>nsequences</code> sequences. All spins will start out in equilibrium, but that can be changed using the <code>longitudinal</code>, <code>transverse</code>, and/or <code>phase</code> flags. This initial spin locations are given by <code>positions</code> (Nx3 matrix or sequence of vectors of size 3). Alternatively the number of spins can be given in which case the spins are randomly distributed in the given <code>bounding_box</code> (default: 1x1x1 mm box centered on origin). The bounding_box can be a <a href="#MCMRSimulator.BoundingBox"><code>BoundingBox</code></a> object, a tuple with the lower and upper bounds (i.e., two vectors of length 3) or a number <code>r</code> (resulting in spins filling a cube from <code>-r</code> to <code>+r</code>)</p><pre><code class="nohighlight hljs">Snapshot(snap::Snapshot{1}, nsequences)</code></pre><p>Replicates the positions and orientations for a single sequence in the input snapshot across <code>nsequences</code>.</p><p><strong>Extracting summary information</strong></p><ul><li><a href="#MCMRSimulator.longitudinal"><code>longitudinal</code></a>(snapshot) to get the <code>nsequences</code> spin magnitudes in the z-direction (equilibrium of 1) averaged over all spins</li><li><a href="#MCMRSimulator.transverse"><code>transverse</code></a>(snapshot) to get the <code>nsequences</code> spin magnitudes in the x-y-plane averaged over all spins</li><li><a href="#MCMRSimulator.phase"><code>phase</code></a>(snapshot) to get the <code>nsequences</code> spin angles in x-y plane (in degrees) averaged over all spins</li><li><a href="#MCMRSimulator.orientation"><code>orientation</code></a>(snapshot) to get a (<code>nsequences</code>x3) matrix with the spin orientations in 3D space averaged over all spins</li><li><a href="#MCMRSimulator.SpinOrientation"><code>SpinOrientation</code></a>(snapshot) to get a <code>nsequences</code> vector of [<code>SpinOrientation</code>] objects with the average spin orientation across all spins</li><li><a href="#MCMRSimulator.position-Tuple{Snapshot}"><code>position</code></a>.(snapshot) to get a the position for each spin in a vector (no averaging applied)</li></ul><p>Information for a single sequence can be extracted by calling <a href="#MCMRSimulator.get_sequence-Tuple{Spin, Any}"><code>get_sequence</code></a> first.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L218-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Sphere" href="#MCMRSimulator.Sphere"><code>MCMRSimulator.Sphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sphere([radius[, location]])</code></pre><p>Creates a hollow sphere with a radius of <code>radius</code> micrometer (default 1 micrometer) at the given <code>location</code> (default: origin). Generate spheres using <a href="#MCMRSimulator.spheres-Tuple"><code>spheres</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/sphere.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Spin" href="#MCMRSimulator.Spin"><code>MCMRSimulator.Spin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Spin particle with a position and <code>nsequences</code> spin orientations (stored as <a href="#MCMRSimulator.SpinOrientation"><code>SpinOrientation</code></a>).</p><p>A random number generator is stored in the <code>Spin</code> object as well, which will be used for evolving the spin into the future in a reproducible manner.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">Spin(;nsequences=1, position=[0, 0, 0], longitudinal=1., transverse=0., phase=0.)</code></pre><p>Creates a new spin with <code>nsequences</code> identical spin orientations (given by <code>longitudinal</code>, <code>transverse</code>, and <code>phase</code> flags). The spin will start at given position.</p><pre><code class="nohighlight hljs">Spin(reference_spin::Spin{1}, nsequences)</code></pre><p>Create a new spin with the same position as <code>reference_spin</code> with the orientation of <code>reference_spin</code> replicated <code>nsequences</code> times.</p><p><strong>Extracting spin information</strong></p><ul><li><a href="#MCMRSimulator.longitudinal"><code>longitudinal</code></a> to get the <code>nsequences</code> spin magnitudes in the z-direction (equilibrium of 1)</li><li><a href="#MCMRSimulator.transverse"><code>transverse</code></a> to get the <code>nsequences</code> spin magnitudes in the x-y-plane</li><li><a href="#MCMRSimulator.phase"><code>phase</code></a> to get the <code>nsequences</code> spin angles in x-y plane (in degrees)</li><li><a href="#MCMRSimulator.orientation"><code>orientation</code></a> to get a (<code>nsequences</code>x3) matrix with the spin orientations in 3D space</li><li><a href="#MCMRSimulator.position-Tuple{Snapshot}"><code>position</code></a> to get a length-3 vector with spin location</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L73-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.SpinOrientation" href="#MCMRSimulator.SpinOrientation"><code>MCMRSimulator.SpinOrientation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpinOrientation(longitudinal, transverse, phase)</code></pre><p>The spin orientation. Usually created as part of a <a href="#MCMRSimulator.Spin"><code>Spin</code></a> object.</p><pre><code class="nohighlight hljs">SpinOrientation(snapshot::Snapshot)</code></pre><p>Returns the average spin orientations of all <a href="#MCMRSimulator.Spin"><code>Spin</code></a> objects in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a>.</p><p>This information can be extracted using:</p><ul><li><a href="#MCMRSimulator.longitudinal"><code>longitudinal</code></a> to get the spin in the z-direction (equilibrium of 1)</li><li><a href="#MCMRSimulator.transverse"><code>transverse</code></a> to get the spin in the x-y-plane</li><li><a href="#MCMRSimulator.phase"><code>phase</code></a> to get the spin angle in x-y plane (in degrees)</li><li><a href="#MCMRSimulator.orientation"><code>orientation</code></a> to get the spin orientation as a length-3 vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L42-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Spiral" href="#MCMRSimulator.Spiral"><code>MCMRSimulator.Spiral</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Spiral(inner, outer; theta0=0., thickness=0.014)</code></pre><p>Creates a spiral starting from <code>inner</code> to <code>outer</code> radius. The distance between subsequent wraps is <code>thickness</code> micrometer. The angle of the start of the wraps is <code>theta0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/spiral.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.TimeController" href="#MCMRSimulator.TimeController"><code>MCMRSimulator.TimeController</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeController(geometry, B0, diffusivity; max_stepsize=&lt;see docs&gt;, gradient_precision=1, rf_rotation=1)</code></pre><p>Stores the settings controlling the maximum timestep during the simulation, namely:</p><ul><li><code>max_timestep</code>: Generic maximum timestep that is considered throughout the simulation. By default this is set by the minimum of the following three options:<ol><li><span>$\Delta t_1 = l^2/(2 D)$</span>, where <code>l</code> is the <a href="#MCMRSimulator.size_scale"><code>size_scale</code></a> of the geometry, and <span>$D$</span> is the <code>diffusivity</code>.</li><li><span>$\Delta t_2 = D^{-1/3} (360 * G)^{-2/3} / p$</span>, where <span>$p$</span> is the <code>gradient_precision</code>, and <span>$G$</span> is the maximum off-resonance gradient due to the geometry (see <a href="#MCMRSimulator.off_resonance_gradient-Tuple{MCMRSimulator.BaseObstruction}"><code>off_resonance_gradient</code></a>).</li><li>The timestep required to keep the probability of the spins getting stuck on the surface at a collision below 1.</li></ol></li><li><code>gradient_precision</code>: maximum error in the phase that a spin should incur while a gradient is active in any of the sequences (units: degrees).    If <code>max_stepsize</code> is not set by the user, it is also applied to any geometry-applied gradients (see point 2 above).</li><li><code>rf_rotation</code>: Maximum amount of rotation that an RF pulse should be able to apply in a single timestep (units: degrees).   This constraint is only active if there is an RF pulse active in any of the sequences.</li></ul><p>More details about how these settings are used can be found in <a href="#MCMRSimulator.propose_times-Tuple{TimeController, Number, Number, AbstractVector{&lt;:Sequence}, Number}"><code>propose_times</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/timestep.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.TransformObstruction" href="#MCMRSimulator.TransformObstruction"><code>MCMRSimulator.TransformObstruction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransformObstruction(base; positions=nothing, repeats=0., rotation=I(3), lorentz_radius=10.)
TransformObstruction(base_type, args...; positions=nothing, repeats=0., rotation=I(3), lorentz_radius=10., kwargs...)</code></pre><p>Transforms the <a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a> objects in <code>base</code> in one of several ways:</p><ul><li>Apply the shifts defined by <code>positions</code> (none applied by default).</li><li>Infinitely repeat the base obstruction every <code>repeats</code>.</li><li>Rotate the base obstructions by <code>rotation</code>.</li></ul><p>If a <a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a> type is given instead it will be initialised using any <code>args</code> and <code>kwargs</code> not used by <code>TransformObstruction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/transform.jl#L8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Wall" href="#MCMRSimulator.Wall"><code>MCMRSimulator.Wall</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Wall()</code></pre><p>Wall stretching to infinite along two dimensions. Generate walls using <a href="#MCMRSimulator.walls-Tuple{}"><code>walls</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/wall.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.B0-Tuple{Scanner}" href="#MCMRSimulator.B0-Tuple{Scanner}"><code>MCMRSimulator.B0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">B0(scanner)
B0(sequence)</code></pre><p>Returns the magnetic field strength of the scanner in Tesla.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/scanner.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.MT_fraction-Tuple{ObstructionProperties, Any}" href="#MCMRSimulator.MT_fraction-Tuple{ObstructionProperties, Any}"><code>MCMRSimulator.MT_fraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MT_fraction(properties)
MT_fraction(obstruction_properties, global_properties)</code></pre><p>The MT_fraction, which affects the spin when colliding with an obstruction. It can be either set when creating a <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>, in which case it is stored in <a href="#MCMRSimulator.GlobalProperties"><code>GlobalProperties</code></a> or when creating any <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a>, in which case it is stored in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L259-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.R1" href="#MCMRSimulator.R1"><code>MCMRSimulator.R1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R1(properties)</code></pre><p>The longitudinal relaxation rate (kHz) stored in <a href="#MCMRSimulator.MRIProperties"><code>MRIProperties</code></a>. It is the inverse of T1. T1 and R1 cannot both be set.</p><p>It can be set by the user when creating a <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>, in which case it will be stored in the <a href="#MCMRSimulator.GlobalProperties"><code>GlobalProperties</code></a>. When creating objects in this geometry, the R1 can be updated in two ways:</p><ul><li>setting the <code>R1_inside</code> keyword affecting spins within the object</li><li>setting the <code>R1_surface</code> keyword affecting spins stuck on the surface of the object</li></ul><p>Both will be stored within a <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.R2" href="#MCMRSimulator.R2"><code>MCMRSimulator.R2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R2(properties)</code></pre><p>The transverse relaxation rate (kHz) stored in <a href="#MCMRSimulator.MRIProperties"><code>MRIProperties</code></a>. It is the inverse of T2. T2 and R2 cannot both be set.</p><p>It can be set by the user when creating a <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>, in which case it will be stored in the <a href="#MCMRSimulator.GlobalProperties"><code>GlobalProperties</code></a>. When creating objects in this geometry, the R2 can be updated in two ways:</p><ul><li>setting the <code>R2_inside</code> keyword affecting spins within the object</li><li>setting the <code>R2_surface</code> keyword affecting spins stuck on the surface of the object</li></ul><p>Both will be stored within a <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.T1" href="#MCMRSimulator.T1"><code>MCMRSimulator.T1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">T1(properties)</code></pre><p>The longitudinal relaxation time (ms) stored in <a href="#MCMRSimulator.MRIProperties"><code>MRIProperties</code></a>. It is the inverse of R1. R1 and T1 cannot both be set.</p><p>It can be set by the user when creating a <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>, in which case it will be stored in the <a href="#MCMRSimulator.GlobalProperties"><code>GlobalProperties</code></a>. When creating objects in this geometry, the T1 can be updated in two ways:</p><ul><li>setting the <code>T1_inside</code> keyword affecting spins within the object</li><li>setting the <code>T1_surface</code> keyword affecting spins stuck on the surface of the object</li></ul><p>Both will be stored within a <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.T2" href="#MCMRSimulator.T2"><code>MCMRSimulator.T2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">T2(properties)</code></pre><p>The transverse relaxation time (ms) stored in <a href="#MCMRSimulator.MRIProperties"><code>MRIProperties</code></a>. It is the inverse of R2. R2 and T2 cannot both be set.</p><p>It can be set by the user when creating a <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>, in which case it will be stored in the <a href="#MCMRSimulator.GlobalProperties"><code>GlobalProperties</code></a>. When creating objects in this geometry, the T2 can be updated in two ways:</p><ul><li>setting the <code>T2_inside</code> keyword affecting spins within the object</li><li>setting the <code>T2_surface</code> keyword affecting spins stuck on the surface of the object</li></ul><p>Both will be stored within a <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.add_TR-Tuple{MCMRSimulator.Shape, Number}" href="#MCMRSimulator.add_TR-Tuple{MCMRSimulator.Shape, Number}"><code>MCMRSimulator.add_TR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_TR(shape/gradient/rf_pulse, TR)</code></pre><p>Shifts the generic [<code>Shape</code>], [<code>MRGradients</code>], or [<code>RFPulse</code>] by a time <code>TR</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/shape.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.add_linear_diffusion_weighting-Tuple{Any, Any, Any}" href="#MCMRSimulator.add_linear_diffusion_weighting-Tuple{Any, Any, Any}"><code>MCMRSimulator.add_linear_diffusion_weighting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_linear_diffusion_weighting(blocks, replace1, replace2, refocus=true, bval/qval/gradient_strength, diffusion_time=max, gradient_duration=max, scanner=3T, orientation=:x)</code></pre><p>Replaces two empty <a href="#MCMRSimulator.BuildingBlock"><code>BuildingBlock</code></a>-like objects with diffusion-weighting gradients. Both diffusion-weighted gradients are identical trapezia. The second one will be flipped if <code>refocus</code> is set to false.</p><p>The other flags control the timings and size of the diffusion weighting. The timings are determined by:</p><ul><li><code>diffusion_time</code>: defaults to time between the start of the two blocks</li><li><code>gradient_duration</code>: defaults to the largest value possible. Setting the <code>gradient_duration</code> to zero will cause [<code>InstantGradient</code>] objects to be used.</li><li><code>ramp_time</code>: defaults to the maximum gradient / maximum slew rate of the scanner.</li></ul><p>The gradient strength is set by <code>bval</code>, <code>qval</code>, or <code>gradient_strength</code>. At least one of these should be provided.</p><p>By default, the timings of the existing <a href="#MCMRSimulator.BuildingBlock"><code>BuildingBlock</code></a> objects are respected. If <code>max_bval</code> or <code>max_qval</code> are set these timings are adjusted to the minimum duration required to reach that b-value or q-value.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence_builder/diffusion.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.amplitude-Tuple{RFPulse, Vararg{Any}}" href="#MCMRSimulator.amplitude-Tuple{RFPulse, Vararg{Any}}"><code>MCMRSimulator.amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude(rf_pulse, t1[, t2])</code></pre><p>Computes the amplitude of the <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a> at time <code>t1</code> in kHz. If <code>t2</code> is also provided, the average amplitude between times <code>t1</code> and <code>t2</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/radio_frequency.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.annuli-Tuple" href="#MCMRSimulator.annuli-Tuple"><code>MCMRSimulator.annuli</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">annuli(inner, outer; myelin=false, chi_I=-0.1, chi_A=-0.1, positions=[0, 0], repeats=[Inf, Inf], rotation=I(3)</code></pre><p>Creates one or more <a href="#MCMRSimulator.Annulus"><code>Annulus</code></a> with given <code>inner</code> and <code>outer</code> radii. Myelinated annuli can be created by setting the <code>myelin</code> to true. All parameters can be either a single value or a vector of values.</p><p>The <code>positions</code>, <code>repeats</code>, and <code>rotation</code> control the annulus position and orientation and is explained in  more detail in <a href="../geometry/#Defining-the-geometry">Defining the geometry</a>. Additional keyword arguments are available to set generic obstruction settings as described in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/annulus.jl#L39-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.apply!-Tuple{InstantRFPulse, SpinOrientation}" href="#MCMRSimulator.apply!-Tuple{InstantRFPulse, SpinOrientation}"><code>MCMRSimulator.apply!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply!(sequence_component, spin_orientation[, position])</code></pre><p>Applies given sequence component to the spin orientation. This updates the existing spin orientation. Some pulses (e.g., <a href="#MCMRSimulator.InstantGradient"><code>InstantGradient</code></a>) require positional information as well.</p><pre><code class="nohighlight hljs">apply!(sequence_components, spin)
apply!(sequence_components, snapshot)</code></pre><p>Apply all sequence components to the spin orientation in the <a href="#MCMRSimulator.Spin"><code>Spin</code></a> or to all the spins in <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a>. Sequence components (see <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a>) can be <code>nothing</code> if there is no sequence component at this time.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/instants.jl#L50-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.collided-Tuple{MCMRSimulator.BaseObstruction, MCMRSimulator.Collision}" href="#MCMRSimulator.collided-Tuple{MCMRSimulator.BaseObstruction, MCMRSimulator.Collision}"><code>MCMRSimulator.collided</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collided(o::BaseObstruction, c::Collision)</code></pre><p>Returns true if the collision <code>c</code> hit the obstruction <code>o</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}" href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>MCMRSimulator.color</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">color(orient::SpinOrientation; saturation=1.)</code></pre><p>Returns a color representing the spin orientation in the transverse (x-y) plane. Brighter colors have a larger transverse component, so that spins with no transverse component are black. The actual color encodes the spin orientation.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/plot.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.constant_pulse-Tuple{Number, Number, Number}" href="#MCMRSimulator.constant_pulse-Tuple{Number, Number, Number}"><code>MCMRSimulator.constant_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constant_pulse([t0=0, ]t1, flip_angle; phase0=0., off_resonance=0.)</code></pre><p>Creates an RF pulse with a constant amplitude resulting in given <code>flip_angle</code> (for spins at <code>off_resonance</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/radio_frequency.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.corners-Tuple{BoundingBox{3}}" href="#MCMRSimulator.corners-Tuple{BoundingBox{3}}"><code>MCMRSimulator.corners</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">corners(bb::BoundingBox)</code></pre><p>Returns a vector of all corners of the <a href="#MCMRSimulator.BoundingBox"><code>BoundingBox</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/bounding_box.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.correct_for_timestep-Tuple{Any, Any}" href="#MCMRSimulator.correct_for_timestep-Tuple{Any, Any}"><code>MCMRSimulator.correct_for_timestep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">correct_for_timestep(MT_fraction/permeability, timestep)</code></pre><p>Corrects the MT fraction or permeability for the variability in the timestep during the simulation.</p><p>In Monte Carlo simulations the rate of collisions depends on the size of the timestep. This means that as the timestep changes, the effect of MT fraction and permeability will depend on the timestep. This function corrects the MT fraction and permeability values, so that their effect does not depend on timestep. The user-provided MT fraction and permeability will be used as is if the timestep is 1 milliseconds.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L298-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.current_gradient-Tuple{Any, Any}" href="#MCMRSimulator.current_gradient-Tuple{Any, Any}"><code>MCMRSimulator.current_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">current_gradient(sequence, time)</code></pre><p>Returns the current <a href="#MCMRSimulator.MRGradients"><code>MRGradients</code></a> in the <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> relative to <code>time</code>. If there is no current gradient <code>nothing</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.current_instant-Tuple{Any, Any}" href="#MCMRSimulator.current_instant-Tuple{Any, Any}"><code>MCMRSimulator.current_instant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">current_instant(sequence, time)</code></pre><p>Returns the current <a href="#MCMRSimulator.InstantGradient"><code>InstantGradient</code></a> or <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a> in the <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> relative to <code>time</code>. If there is no current instant <code>nothing</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.current_pulse-Tuple{Any, Any}" href="#MCMRSimulator.current_pulse-Tuple{Any, Any}"><code>MCMRSimulator.current_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">current_pulse(sequence, time)</code></pre><p>Returns the current <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a> in the <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> relative to <code>time</code>. If there is no current pulse <code>nothing</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.cylinders-Tuple" href="#MCMRSimulator.cylinders-Tuple"><code>MCMRSimulator.cylinders</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cylinders(radii; g_ratio=1, chi_I=-0.1, chi_A=-0.1, positions=[0, 0], repeats=[Inf, Inf], rotation=I(3)</code></pre><p>Creates one or more <a href="#MCMRSimulator.Cylinder"><code>Cylinder</code></a>s with given radius (or vector of <code>radii</code>). Myelinated cylinders can be created by setting the <code>g_ratio</code> to a different value that 1. All parameters can be either a single value or a vector of values. The <code>positions</code>, <code>repeats</code>, and <code>rotation</code> control the cylinder position and orientation and is explained in  more detail in <a href="../geometry/#Defining-the-geometry">Defining the geometry</a>. Additional keyword arguments are available to set generic obstruction settings as described in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/cylinder.jl#L36-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.detect_collision" href="#MCMRSimulator.detect_collision"><code>MCMRSimulator.detect_collision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">detect_collision(movement, base_obstruction, previous_collision)</code></pre><p>Returns any intersection between the <a href="#MCMRSimulator.Movement"><code>Movement</code></a> and the [<code>BaseObstruction</code>].</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.detect_collision" href="#MCMRSimulator.detect_collision"><code>MCMRSimulator.detect_collision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">detect_collision(movement, geometry[, previous])</code></pre><p>Returns a <a href="#MCMRSimulator.Collision"><code>Collision</code></a> object if the given <code>movement</code> crosses any obstructions. The first collision is always returned. If no collision is detected, <code>empty_collision</code> will be returned</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/geometry_struct.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.direction-Tuple{MCMRSimulator.Reflection}" href="#MCMRSimulator.direction-Tuple{MCMRSimulator.Reflection}"><code>MCMRSimulator.direction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">direction(reflection[, remaining_time])</code></pre><p>Returns the displacement that the spin should end up if it has <code>remaining_time</code> ms left in this timestep.</p><p>If <code>remaining_time</code> is not provided, the time remaining is assumed to be the time remaining in this timestep.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/reflection.jl#L26-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.draw_step!-Union{Tuple{N}, Tuple{Spin{N}, StaticArraysCore.SVector{N, MCMRSimulator.SequencePart}, Float64, Float64, GlobalProperties, Geometry{0}}} where N" href="#MCMRSimulator.draw_step!-Union{Tuple{N}, Tuple{Spin{N}, StaticArraysCore.SVector{N, MCMRSimulator.SequencePart}, Float64, Float64, GlobalProperties, Geometry{0}}} where N"><code>MCMRSimulator.draw_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_step!(spin, sequence_parts, diffusivity, timestep, default_properties, geometry])</code></pre><p>Updates the spin based on a random movement through the given geometry for a given <code>timestep</code>:</p><ul><li>draws the next location of the particle after <code>timestep</code> with given <code>diffusivity</code>.   This displacement will take into account the obstructions in <code>geometry</code>.</li><li>The spin orientation will be affected by relaxation (see <a href="#MCMRSimulator.relax!"><code>relax!</code></a>) and potentially by magnetisation transfer during collisions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/evolve.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.duration-Tuple{AbstractVector}" href="#MCMRSimulator.duration-Tuple{AbstractVector}"><code>MCMRSimulator.duration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">duration(building_block)</code></pre><p>Returns how long each sequence <a href="#MCMRSimulator.BuildingBlock"><code>BuildingBlock</code></a> lasts.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence_builder/building_blocks.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.dwell_time-Tuple{ObstructionProperties, Any}" href="#MCMRSimulator.dwell_time-Tuple{ObstructionProperties, Any}"><code>MCMRSimulator.dwell_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dwell_time(properties)
dwell_time(obstruction_properties, global_properties)</code></pre><p>The dwell_time, which affects the spin when colliding with an obstruction. It can be either set when creating a <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>, in which case it is stored in <a href="#MCMRSimulator.GlobalProperties"><code>GlobalProperties</code></a> or when creating any <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a>, in which case it is stored in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L259-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.dwi-Tuple{}" href="#MCMRSimulator.dwi-Tuple{}"><code>MCMRSimulator.dwi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spin_echo(TE; 
    TR=&lt;TE&gt;, scanner=&lt;3T scanner&gt;, 
    excitation_pulse=Instant, excitation_time=&lt;half pulse duration&gt;, 
    refocus_pulse=Instant, refocus_time=&lt;half pulse duration&gt;,
    readout_time=0, diffusion_time=&lt;maximum&gt;, gradient_duration=&lt;maximum&gt;,
    bval/qval/gradient_strength=&lt;one is required&gt;, orientation=:x,
    )</code></pre><p>Creates a gradient echo sequence consisting of:</p><ul><li><code>excitation_pulse</code>: by default this is an <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a>, but can be replaced with an <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a>. If the excitation does not take place halfway the RF pulse, <code>excitation_time</code> should be set as well.</li><li>diffusion weighting</li><li><code>refocus_pulse</code>: by default this is an <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a>, but can be replaced with an <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a>. If the refocus does not take place halfway the RF pulse, <code>refocus_time</code> should be set as well.</li><li>identical diffusion weighting cancelling out the first one</li><li>a readout <code>TE</code> ms after the excitation.</li></ul><p>The refocus time is always halfway the excitation time and the readout.</p><p>The timings of the RF pulses is set by <code>TE</code> and <code>TR</code>. The gradient timings will also be affected by <code>gradient_duration</code>, <code>diffusion_time</code>, <code>scanner</code> (which sets the ramp time) and readout_time:</p><ul><li>By default the gradient durations are set to the maximum value possible within the echo time (<code>TE</code>) keeping in mind the time needed for the MR readout (<code>readout_time</code>) and the time needed to ramp to the maximum gradient strength (set by the <code>scanner</code>).</li><li>When gradient<em>duration is set to 0, the gradient pulses are assumed to be instanteneous (i.e., using <a href="#MCMRSimulator.InstantGradient"><code>InstantGradient</code></a>). The time between these instant gradients can be set using diffusion</em>time (defaults to TE/2).</li></ul><p>The strength of the diffusion gradients is set by one of <code>bval</code> (units: ms/um^2), <code>qval</code> (units: 1/um), or <code>gradient_strength</code> (units: kHz/um). If the resulting gradient strength exceeds the maximum allowed for the <code>scanner</code> an AssertionError is raised. The gradient orientation is set by <code>orientation</code>.</p><p>For more details of how the diffusion weighting is inserted in the <a href="#MCMRSimulator.spin_echo-Tuple{Any}"><code>spin_echo</code></a> sequence, see <a href="#MCMRSimulator.add_linear_diffusion_weighting-Tuple{Any, Any, Any}"><code>add_linear_diffusion_weighting</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence_builder/sequences/spin_echo.jl#L32-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.dyad_snapshot!-Tuple" href="#MCMRSimulator.dyad_snapshot!-Tuple"><code>MCMRSimulator.dyad_snapshot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)</code></pre><p>Plots the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> projected onto given <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a> as arrows.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/snapshot.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.dyad_snapshot-Tuple" href="#MCMRSimulator.dyad_snapshot-Tuple"><code>MCMRSimulator.dyad_snapshot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)</code></pre><p>Plots the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> projected onto given <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a> as arrows.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/snapshot.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.effective_pulse-Tuple{RFPulse, Number, Number}" href="#MCMRSimulator.effective_pulse-Tuple{RFPulse, Number, Number}"><code>MCMRSimulator.effective_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">effective_pulse(RFPulse, t0, t1)
effective_pulse(sequence, t0, t1)</code></pre><p>Represents the effect of the RF pulse between times <code>t0</code> and <code>t1</code> as an <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/radio_frequency.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.effective_pulse-Tuple{Sequence, Number, Number}" href="#MCMRSimulator.effective_pulse-Tuple{Sequence, Number, Number}"><code>MCMRSimulator.effective_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">effective_pulse(sequence, t1, t2)</code></pre><p>Returns the <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a> that has the same effect as the radio-frequency pulses (<a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a>) in the provided sequence will have between <code>t1</code> and <code>t2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.empty_mri_properties-Tuple{MRIProperties}" href="#MCMRSimulator.empty_mri_properties-Tuple{MRIProperties}"><code>MCMRSimulator.empty_mri_properties</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empty_mri_properties(properties)</code></pre><p>Returns true if none of the parameters have been set</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N" href="#MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>MCMRSimulator.evolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve(snapshot, simulation[, new_time]; bounding_box=&lt;1x1x1 mm box&gt;)</code></pre><p>Evolves the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> through the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> to a new time. Returns a <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> at the new time, which can be used as a basis for further simulation. By default it will simulate till the start of the next TR.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/readout.jl#L247-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.evolve_to_time!-Union{Tuple{N}, Tuple{Spin{N}, Simulation{N}, StaticArraysCore.SVector{N, MCMRSimulator.SequencePart}, Float64, Float64}} where N" href="#MCMRSimulator.evolve_to_time!-Union{Tuple{N}, Tuple{Spin{N}, Simulation{N}, StaticArraysCore.SVector{N, MCMRSimulator.SequencePart}, Float64, Float64}} where N"><code>MCMRSimulator.evolve_to_time!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve_to_time(spin, simulation, current_time, new_time)</code></pre><p>Evolve a single spin to the next time of interest. This takes into account both random diffusion of the spin&#39;s position and relaxation of the MR spin orientation. It is used internally when evolving <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/evolve.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.evolve_to_time-Union{Tuple{N}, Tuple{Snapshot{N}, Simulation{N}, Float64}} where N" href="#MCMRSimulator.evolve_to_time-Union{Tuple{N}, Tuple{Snapshot{N}, Simulation{N}, Float64}} where N"><code>MCMRSimulator.evolve_to_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve_to_time(snapshot, simulation, new_time)</code></pre><p>Evolves the full <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> through the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> to the given <code>new_time</code>. Multi-threading is used to evolve multiple spins in parallel. This is used internally when calling any of the snapshot evolution methods (e.g., <a href="#MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>evolve</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/evolve.jl#L124-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.expand" href="#MCMRSimulator.expand"><code>MCMRSimulator.expand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expand(bb::BoundingBox, ratio=1.)</code></pre><p>Expand or shrink the <a href="#MCMRSimulator.BoundingBox"><code>BoundingBox</code></a> so that it grows/shrinks by <code>ratio</code> along each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/bounding_box.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.fit_time-NTuple{6, Any}" href="#MCMRSimulator.fit_time-NTuple{6, Any}"><code>MCMRSimulator.fit_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit_time(duration1, duration_wait, duration2, gradient_duration, diffusion_time, ramp_time)</code></pre><p>Arranges the timing of gradients given the duration of gradient, diffusion time, ramp time, readout time and TE. By default it will try to arrange to gradients symmetrically arround the 180 degree pulse. If not feasible, it will make readout right after the rephasing gradient and calculate the dephasing gradient&#39;s timing based on the rephasing gradient.</p><p>This function is not supposed to be called individually! So no check for the arguments will happen, assuming all have been checked by <code>get_diffusion_trapeziums</code> and all will not be nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence_builder/diffusion.jl#L144-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.flip_angle-Tuple{InstantRFPulse}" href="#MCMRSimulator.flip_angle-Tuple{InstantRFPulse}"><code>MCMRSimulator.flip_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flip_angle(instant_pulse)</code></pre><p>Returns the flip angle of the <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a> in degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/instants.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.flip_angle-Tuple{RFPulse}" href="#MCMRSimulator.flip_angle-Tuple{RFPulse}"><code>MCMRSimulator.flip_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flip_angle(pulse)</code></pre><p>Computes the total flip angle of a <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a> for spins that are in phase with the pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/radio_frequency.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.get_rotation-Tuple{Rotations.Rotation, Int64}" href="#MCMRSimulator.get_rotation-Tuple{Rotations.Rotation, Int64}"><code>MCMRSimulator.get_rotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_rotation(vector, ndim)</code></pre><p>Returns the (3, <code>ndim</code>) rotation matrix mapping the x-direction to <code>vector</code> (if <code>ndim</code> is 1) or the z-direction to <code>vector</code> (if <code>ndim</code> is 3). Vector can be a length 3 array or one of the symbols :x, :y, or :z (representing vectors in those cardinal directions).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/transform.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.get_sequence-Tuple{Spin, Any}" href="#MCMRSimulator.get_sequence-Tuple{Spin, Any}"><code>MCMRSimulator.get_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_sequence(spin, sequence_index)
get_sequence(snapshot, sequence_index)</code></pre><p>Extracts the spin orientation corresponding to a specific sequence, where the sequence index uses the order in which the sequences where provided in the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L198-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.get_time-Tuple{Snapshot}" href="#MCMRSimulator.get_time-Tuple{Snapshot}"><code>MCMRSimulator.get_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_time(snapshot)
get_time(sequence_component)
get_time(sequence, sequence_index)</code></pre><p>Returns the time in milliseconds that a snapshot was taken or that a sequence component will have effect.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L287-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.gradient-Tuple{AbstractVector, Sequence, Number}" href="#MCMRSimulator.gradient-Tuple{AbstractVector, Sequence, Number}"><code>MCMRSimulator.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient([position, ], sequence, t1)</code></pre><p>Gets the off-resonance field (units: kHz) at given <code>position</code> at time <code>t1</code>. If position is not supplied the MR gradient is returned as a <a href="#MCMRSimulator.PosVector"><code>PosVector</code></a> (units: kHz/um).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.gradient-Tuple{MRGradients, Number}" href="#MCMRSimulator.gradient-Tuple{MRGradients, Number}"><code>MCMRSimulator.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient([position, ]sequence/grad, time)
gradient([position, ]sequence/grad, t1, t2)</code></pre><p>Get gradient strength generated by <code>grad</code> (<a href="#MCMRSimulator.MRGradients"><code>MRGradients</code></a> object) at a specific <code>time</code> or averaged over a period between <code>t1</code> and <code>t2</code>. If no position is provided, the gradient is returned as a length-3 vector in units of mT/m. If a position is provided, the gradient is returned at that position as a float quantifying the off-resonance field in units of microTesla.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/gradients.jl#L62-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.gradient_echo-Tuple{Any}" href="#MCMRSimulator.gradient_echo-Tuple{Any}"><code>MCMRSimulator.gradient_echo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient_echo(TE; TR=&lt;TE&gt;, scanner=&lt;3T scanner&gt;, excitation_pulse=Instant, excitation_time=&lt;half pulse duration&gt;)</code></pre><p>Creates a gradient echo sequence consisting of:</p><ul><li><code>excitation_pulse</code>: by default this is an <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a>, but can be replaced with an <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a>. If the excitation does not take place halfway the RF pulse, <code>excitation_time</code> should be set as well.</li><li>a delay</li><li>a readout <code>TE</code> ms after the excitation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence_builder/sequences/gradient_echo.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.image_snapshot!-Tuple" href="#MCMRSimulator.image_snapshot!-Tuple"><code>MCMRSimulator.image_snapshot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">image_snapshot(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)
image_snapshot!(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)</code></pre><p>Plots the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> projected onto given <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>. The average spin orientation across the plot plane is plotted using the colour coding from <a href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>color</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/snapshot.jl#L60-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.image_snapshot-Tuple" href="#MCMRSimulator.image_snapshot-Tuple"><code>MCMRSimulator.image_snapshot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">image_snapshot(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)
image_snapshot!(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)</code></pre><p>Plots the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> projected onto given <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>. The average spin orientation across the plot plane is plotted using the colour coding from <a href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>color</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/snapshot.jl#L60-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.inside_MRI_properties-Union{Tuple{N}, Tuple{Geometry{N}, StaticArraysCore.SVector{3, Float64}, MRIProperties}} where N" href="#MCMRSimulator.inside_MRI_properties-Union{Tuple{N}, Tuple{Geometry{N}, StaticArraysCore.SVector{3, Float64}, MRIProperties}} where N"><code>MCMRSimulator.inside_MRI_properties</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inside_MRI_properties(geometry, spin/position, global_props)</code></pre><p>Computes the MRI parameters for the spin based on some global settings (<code>global_props</code>) and any overriding of those settings in the <code>geometry</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/geometry_struct.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.inside_MRI_properties-Union{Tuple{N}, Tuple{MCMRSimulator.BaseObstruction{N}, StaticArraysCore.SVector{N, Float64}}} where N" href="#MCMRSimulator.inside_MRI_properties-Union{Tuple{N}, Tuple{MCMRSimulator.BaseObstruction{N}, StaticArraysCore.SVector{N, Float64}}} where N"><code>MCMRSimulator.inside_MRI_properties</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inside_MRI_properties(obstruction, position)</code></pre><p>Returns the inside MRI properties of the obstruction only if the position is within the property. For positions outside of the MRI properties an empty <a href="#MCMRSimulator.MRIProperties"><code>MRIProperties</code></a> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.isempty_block-Tuple{AbstractVector}" href="#MCMRSimulator.isempty_block-Tuple{AbstractVector}"><code>MCMRSimulator.isempty_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isempty_block(building_block)</code></pre><p>Returns whether a sequence <a href="#MCMRSimulator.BuildingBlock"><code>BuildingBlock</code></a> is empty (i.e., does not contain RF pulses, readouts or MRI gradients).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence_builder/building_blocks.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.isinside-Tuple{Any, AbstractVector}" href="#MCMRSimulator.isinside-Tuple{Any, AbstractVector}"><code>MCMRSimulator.isinside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinside(obstruction/geometry/bounding_box, position)
isinside(obstructions/geometry/bounding_box, spin)
isinside(obstructions/geometry/bounding_box, snapshot)</code></pre><p>Test whether the particles are inside a <a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a>, <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a>, <a href="#MCMRSimulator.Geometry"><code>Geometry</code></a> or <a href="#MCMRSimulator.BoundingBox"><code>BoundingBox</code></a> object.</p><p>This can be used to filter a <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> using:</p><pre><code class="language-julia hljs">only_inside = filter(s -&gt; isinside(geometry, s) &gt; 0, snapshot)
only_outside = filter(s -&gt; isinside(geometry, s) == 0, snapshot)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L72-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.load_mesh-Tuple{IO}" href="#MCMRSimulator.load_mesh-Tuple{IO}"><code>MCMRSimulator.load_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_mesh(file)</code></pre><p>Loads a <a href="#MCMRSimulator.Mesh"><code>Mesh</code></a> from a file.</p><p>Currently only PLY files are supported (see <a href="#MCMRSimulator.ply_from_mesh-Tuple{Any}"><code>ply_from_mesh</code></a>)</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/mesh.jl#L266-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.longitudinal" href="#MCMRSimulator.longitudinal"><code>MCMRSimulator.longitudinal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transverse(spin)
transverse(snapshot)</code></pre><p>Returns the longitudinal magnitude of the spin (i.e., magnitude aligned with the magnetic field) for a single particle (<a href="#MCMRSimulator.Spin"><code>Spin</code></a>) or averaged across a group of particles in a [<code>Snapshot</code>]. When orientations for multiple sequences are available an array of longitudinal values is returned with a value for each sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L147-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.lorentz_off_resonance" href="#MCMRSimulator.lorentz_off_resonance"><code>MCMRSimulator.lorentz_off_resonance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lorentz_off_resonance(base_obstruction, position, b0_field, repeat_dist, radius, nrepeats)</code></pre><p>Computes the off-resonance field produced by the obstruction (<a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a>) at the given <code>position</code> given the <code>b0_field</code>. The field generated by any repeats of the base obstruction within a distance of <code>radius</code> will also be considered (presuming the obstruction repeats every <code>repeat_dist</code>). This maximum number of repeats that need to be considered is precomputed as <code>nrepeats</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.max_gradient" href="#MCMRSimulator.max_gradient"><code>MCMRSimulator.max_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">max_gradient(scanner[, units])</code></pre><p>Returns the maximum magnetic field gradient of the scanner in kHz/um. By setting <code>units</code> to :Tesla, the gradient strength can be returned in mT/m instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/scanner.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.max_slew_rate" href="#MCMRSimulator.max_slew_rate"><code>MCMRSimulator.max_slew_rate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">max_slew_rate(scanner[, units])</code></pre><p>Returns the maximum magnetic field slew rate of the scanner in kHz/um/ms. By setting <code>units</code> to :Tesla, the slew rate can be returned in T/m/s instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/scanner.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.max_timestep_sticking-Tuple{MCMRSimulator.BaseObstruction, GlobalProperties, Number}" href="#MCMRSimulator.max_timestep_sticking-Tuple{MCMRSimulator.BaseObstruction, GlobalProperties, Number}"><code>MCMRSimulator.max_timestep_sticking</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_timestep_sticking(obstruction, default_properties, diffusivity)
max_timestep_sticking(geometry, default_properties, diffusivity)</code></pre><p>Computes the maximum timestep that a simulation can have before <a href="#MCMRSimulator.stick_probability-NTuple{4, Number}"><code>stick_probability</code></a> goes above 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L120-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.merge_mri_parameters" href="#MCMRSimulator.merge_mri_parameters"><code>MCMRSimulator.merge_mri_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">merge_mri_parameters(properties[, default_values=&lt;empty&gt;])</code></pre><p>Merges multiple MRI properties into one. An error is raised if they are inconsistent with each other</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.mesh_grid_intersection-Tuple{MCMRSimulator.GridShape, Vector{StaticArraysCore.SVector{3, Float64}}, Vector{StaticArraysCore.SVector{3, Int64}}}" href="#MCMRSimulator.mesh_grid_intersection-Tuple{MCMRSimulator.GridShape, Vector{StaticArraysCore.SVector{3, Float64}}, Vector{StaticArraysCore.SVector{3, Int64}}}"><code>MCMRSimulator.mesh_grid_intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mesh_grid_intersection(shape, vertices, triangles)</code></pre><p>Determines for each voxel in the grid with which triangles it intersects.</p><p><strong>Algorithm</strong></p><p>We follow the algorithm proposed by https://fileadmin.cs.lth.se/cs/Personal/Tomas<em>Akenine-Moller/code/tribox</em>tam.pdf, which is based on the separating axis theorem.</p><p>We project each voxel in the grid and each triangle on a series of 9 axes:</p><ul><li>the normals of the cube ([1, 0, 0], [0, 1, 0], [0, 0, 1])</li><li>the normal of the triangle</li><li>the cross products of any edge of the cube (same as normals) and the edges of the triangle (total of 9 tests)</li></ul><p>If the cube and triangle do not overlap along any of these axes, they are non-overlapping. If they overlap along all axes, the triangle and cube overlap</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/mesh.jl#L95-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.next_gradient-Tuple{Any, Any}" href="#MCMRSimulator.next_gradient-Tuple{Any, Any}"><code>MCMRSimulator.next_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">next_gradient(sequence, time)</code></pre><p>Returns the next <a href="#MCMRSimulator.MRGradients"><code>MRGradients</code></a> in the <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> relative to <code>time</code>. If there is no next gradient <code>nothing</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.next_instant-Tuple{Any, Any}" href="#MCMRSimulator.next_instant-Tuple{Any, Any}"><code>MCMRSimulator.next_instant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">next_instant(sequence, time)</code></pre><p>Returns the next <a href="#MCMRSimulator.InstantGradient"><code>InstantGradient</code></a> or <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a> in the <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> relative to <code>time</code>. If there is no next instant <code>nothing</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.next_pulse-Tuple{Any, Any}" href="#MCMRSimulator.next_pulse-Tuple{Any, Any}"><code>MCMRSimulator.next_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">next_pulse(sequence, time)</code></pre><p>Returns the next <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a> in the <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> relative to <code>time</code>. If there is no next pulse <code>nothing</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.norm_angle-Tuple{Any}" href="#MCMRSimulator.norm_angle-Tuple{Any}"><code>MCMRSimulator.norm_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm_angle(angle)</code></pre><p>Normalises an angle in degrees, so that it is between it is in the range (-180, 180]</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.normal-Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}" href="#MCMRSimulator.normal-Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}"><code>MCMRSimulator.normal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal(p1, p2, p3)</code></pre><p>Computes the normal of a triangle formed by the three points</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/mesh.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.off_resonance" href="#MCMRSimulator.off_resonance"><code>MCMRSimulator.off_resonance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">off_resonance(properties)</code></pre><p>The off-resonance field (kHz) stored in <a href="#MCMRSimulator.MRIProperties"><code>MRIProperties</code></a>.</p><p>It can be set by the user when creating a <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>, in which case it will be stored in the <a href="#MCMRSimulator.GlobalProperties"><code>GlobalProperties</code></a>. When creating objects in this geometry, the off_resonance can be updated in two ways:</p><ul><li>setting the <code>off_resonance_inside</code> keyword affecting spins within the object</li><li>setting the <code>off_resonance_surface</code> keyword affecting spins stuck on the surface of the object</li></ul><p>Both will be stored within a <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.off_resonance-Tuple{Cylinder, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}" href="#MCMRSimulator.off_resonance-Tuple{Cylinder, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}"><code>MCMRSimulator.off_resonance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">off_resonance(cylinder, position, b0_field)</code></pre><p>Computed by the hollow cylinder fiber model from <a href="../references/#Wharton_2012">Samuel Wharton, Richard Bowtell (2012)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/cylinder.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.off_resonance-Tuple{RFPulse, Vararg{Any}}" href="#MCMRSimulator.off_resonance-Tuple{RFPulse, Vararg{Any}}"><code>MCMRSimulator.off_resonance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">off_resonance(rf_pulse, t1[, t2])</code></pre><p>Computes the off<em>resonance of the <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a> at time <code>t1</code> in kHz. If <code>t2</code> is also provided, the average off</em>resonance between times <code>t1</code> and <code>t2</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/radio_frequency.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.off_resonance_gradient-Tuple{MCMRSimulator.BaseObstruction}" href="#MCMRSimulator.off_resonance_gradient-Tuple{MCMRSimulator.BaseObstruction}"><code>MCMRSimulator.off_resonance_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">off_resonance_gradient(obstruction[, B0])
off_resonance_gradient(geometry[, B0])</code></pre><p>Computes the maximum off-resonance gradient produced by this obstruction. For a geometry with multiple obstructions, the maximum value is returned. If a B0 field is provided the result is returned in kHz/um, otherwise in ppm/um.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.orientation" href="#MCMRSimulator.orientation"><code>MCMRSimulator.orientation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orientation(spin)
orientation(snapshot)</code></pre><p>Returns the spin orientation as a length-3 vector for a single particle (<a href="#MCMRSimulator.Spin"><code>Spin</code></a>) or averaged across a group of particles in a [<code>Snapshot</code>]. When orientations for multiple sequences are available an array of vectors is returned with a value for each sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L174-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.permeability-Tuple{ObstructionProperties, Any}" href="#MCMRSimulator.permeability-Tuple{ObstructionProperties, Any}"><code>MCMRSimulator.permeability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permeability(properties)
permeability(obstruction_properties, global_properties)</code></pre><p>The permeability, which affects the spin when colliding with an obstruction. It can be either set when creating a <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>, in which case it is stored in <a href="#MCMRSimulator.GlobalProperties"><code>GlobalProperties</code></a> or when creating any <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a>, in which case it is stored in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L259-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.phase" href="#MCMRSimulator.phase"><code>MCMRSimulator.phase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase(spin)
phase(snapshot)</code></pre><p>Returns the phase in the x-y plane of the spin for a single particle (<a href="#MCMRSimulator.Spin"><code>Spin</code></a>) or averaged across a group of particles in a [<code>Snapshot</code>]. When orientations for multiple sequences are available  an array of phase values is returned with a value for each sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L165-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.phase-Tuple{InstantRFPulse}" href="#MCMRSimulator.phase-Tuple{InstantRFPulse}"><code>MCMRSimulator.phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phase(instant_pulse)</code></pre><p>Returns the angle in the x-y plane of the axis around with the <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a> rotates in degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/instants.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.phase-Tuple{RFPulse, Vararg{Any}}" href="#MCMRSimulator.phase-Tuple{RFPulse, Vararg{Any}}"><code>MCMRSimulator.phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phase(rf_pulse, t1[, t2])</code></pre><p>Computes the phase of the <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a> at time <code>t1</code> in degrees. If <code>t2</code> is also provided, the average phase between times <code>t1</code> and <code>t2</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/radio_frequency.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_geometry!-Tuple" href="#MCMRSimulator.plot_geometry!-Tuple"><code>MCMRSimulator.plot_geometry!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(plot_plane, geometry)
plot!(plot_plane, geometry)
plot_geometry(plot_plane, geometry)
plot_geometry!(plot_plane, geometry)</code></pre><p>Plots the intersections of <code>geometry</code> in the <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/geometry.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_geometry-Tuple" href="#MCMRSimulator.plot_geometry-Tuple"><code>MCMRSimulator.plot_geometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(plot_plane, geometry)
plot!(plot_plane, geometry)
plot_geometry(plot_plane, geometry)
plot_geometry!(plot_plane, geometry)</code></pre><p>Plots the intersections of <code>geometry</code> in the <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/geometry.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_off_resonance!-Tuple" href="#MCMRSimulator.plot_off_resonance!-Tuple"><code>MCMRSimulator.plot_off_resonance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_off_resonance(plot_plane, geometry)
plot_off_resonance(plot_plane, geometry)</code></pre><p>Plots the off-resonance of <code>geometry</code> in the <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/off_resonance.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_off_resonance-Tuple" href="#MCMRSimulator.plot_off_resonance-Tuple"><code>MCMRSimulator.plot_off_resonance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_off_resonance(plot_plane, geometry)
plot_off_resonance(plot_plane, geometry)</code></pre><p>Plots the off-resonance of <code>geometry</code> in the <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/off_resonance.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_snapshot" href="#MCMRSimulator.plot_snapshot"><code>MCMRSimulator.plot_snapshot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot(plot_plane, snapshot; kwargs...)
plot!(plot_plane, snapshot; kwargs...)
plot_snapshot(plot_plane, snapshot; kwargs...)
plot_snapshot!(plot_plane, snapshot; kwargs...)</code></pre><p>Plots the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> projected onto given <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>. Each spin is represented by an arrow showing the transverse component of the spin (for a total of the first <code>ndyads</code> spins). The average spin orientation across the plot plane is plotted using the colour coding from <a href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>color</code></a>.</p><p>This combines the plotting from <a href="#MCMRSimulator.image_snapshot-Tuple"><code>image_snapshot</code></a> and <a href="#MCMRSimulator.dyad_snapshot-Tuple"><code>dyad_snapshot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/snapshot.jl#L97-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_trajectory2d!-Tuple" href="#MCMRSimulator.plot_trajectory2d!-Tuple"><code>MCMRSimulator.plot_trajectory2d!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(snapshots)
plot!(snapshots)
plot_trajectory3d(snapshots)
plot_trajectory3d!(snapshots)</code></pre><p>Plots trajectory of the spins in a sequence of <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/trajectory.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_trajectory2d-Tuple" href="#MCMRSimulator.plot_trajectory2d-Tuple"><code>MCMRSimulator.plot_trajectory2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(snapshots)
plot!(snapshots)
plot_trajectory3d(snapshots)
plot_trajectory3d!(snapshots)</code></pre><p>Plots trajectory of the spins in a sequence of <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/trajectory.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_trajectory3d!-Tuple" href="#MCMRSimulator.plot_trajectory3d!-Tuple"><code>MCMRSimulator.plot_trajectory3d!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(snapshots)
plot!(snapshots)
plot_trajectory3d(snapshots)
plot_trajectory3d!(snapshots)</code></pre><p>Plots trajectory of the spins in a sequence of <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/trajectory.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_trajectory3d-Tuple" href="#MCMRSimulator.plot_trajectory3d-Tuple"><code>MCMRSimulator.plot_trajectory3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(snapshots)
plot!(snapshots)
plot_trajectory3d(snapshots)
plot_trajectory3d!(snapshots)</code></pre><p>Plots trajectory of the spins in a sequence of <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/trajectory.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.ply_from_mesh-Tuple{Any}" href="#MCMRSimulator.ply_from_mesh-Tuple{Any}"><code>MCMRSimulator.ply_from_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ply_from_mesh(file)</code></pre><p>Loads a <a href="#MCMRSimulator.Mesh"><code>Mesh</code></a> from a PLY file. PLY stands for Polygon File Format (http://paulbourke.net/dataformats/ply/). PLY IO is handled by PlyIO.jl (https://github.com/JuliaGeometry/PlyIO.jl).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/mesh.jl#L247-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.position-Tuple{Snapshot}" href="#MCMRSimulator.position-Tuple{Snapshot}"><code>MCMRSimulator.position</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">position.(s::Snapshot)</code></pre><p>Returns all the positions of the spin particles as a vector of length-3 vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L314-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.position-Tuple{Spin}" href="#MCMRSimulator.position-Tuple{Spin}"><code>MCMRSimulator.position</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">position(s::Spin)</code></pre><p>Returns the position of the spin particle as a vector of length 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.previous_gradient-Tuple{Any, Any}" href="#MCMRSimulator.previous_gradient-Tuple{Any, Any}"><code>MCMRSimulator.previous_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">previous_gradient(sequence, time)</code></pre><p>Returns the previous <a href="#MCMRSimulator.MRGradients"><code>MRGradients</code></a> in the <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> relative to <code>time</code>. If there is no previous gradient <code>nothing</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.previous_instant-Tuple{Any, Any}" href="#MCMRSimulator.previous_instant-Tuple{Any, Any}"><code>MCMRSimulator.previous_instant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">previous_instant(sequence, time)</code></pre><p>Returns the previous <a href="#MCMRSimulator.InstantGradient"><code>InstantGradient</code></a> or <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a> in the <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> relative to <code>time</code>. If there is no previous instant <code>nothing</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.previous_pulse-Tuple{Any, Any}" href="#MCMRSimulator.previous_pulse-Tuple{Any, Any}"><code>MCMRSimulator.previous_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">previous_pulse(sequence, time)</code></pre><p>Returns the previous <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a> in the <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> relative to <code>time</code>. If there is no previous pulse <code>nothing</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/sequence.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.produces_off_resonance-Tuple{Geometry}" href="#MCMRSimulator.produces_off_resonance-Tuple{Geometry}"><code>MCMRSimulator.produces_off_resonance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">produces_off_resonance(geometry)</code></pre><p>Whether any obstruction produces an off-resonance field. The field will be computed using [<code>off_resonance</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/geometry_struct.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.produces_off_resonance-Tuple{MCMRSimulator.BaseObstruction}" href="#MCMRSimulator.produces_off_resonance-Tuple{MCMRSimulator.BaseObstruction}"><code>MCMRSimulator.produces_off_resonance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">produces_off_resonance(base_obstruction)</code></pre><p>Whether the obstruction produces an off-resonance field. The field will be computed using [<code>lorentz_off_resonance</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.project-Tuple{PlotPlane, StaticArraysCore.SVector{3, Float64}}" href="#MCMRSimulator.project-Tuple{PlotPlane, StaticArraysCore.SVector{3, Float64}}"><code>MCMRSimulator.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(plot_plane, position)
project(plot_plane, snapshot)</code></pre><p>Transforms the <code>position</code> (length-3 vector) or <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> to a space, where the <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a> lies in the x-y-plane centered on origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/plot_plane.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.project-Union{Tuple{M}, Tuple{N}, Tuple{TransformObstruction{N, M, K, B, O} where {K, B&lt;:BoundingBox{N}, O&lt;:MCMRSimulator.BaseObstruction{N}}, StaticArraysCore.SVector{3, Float64}}} where {N, M}" href="#MCMRSimulator.project-Union{Tuple{M}, Tuple{N}, Tuple{TransformObstruction{N, M, K, B, O} where {K, B&lt;:BoundingBox{N}, O&lt;:MCMRSimulator.BaseObstruction{N}}, StaticArraysCore.SVector{3, Float64}}} where {N, M}"><code>MCMRSimulator.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(transform_obstruction, position)</code></pre><p>Computes the position in the space of the obstructions wrapped by the <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a>.</p><p>It does this first by rotating the <code>position</code> into the coordinate system of this <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a>. The position is then shifted by the appropriate amount for each <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a>. For repeating obstructions the position is always projected to the closest obstruction.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/transform.jl#L208-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.project-Union{Tuple{N}, Tuple{MCMRSimulator.GridShape{N}, StaticArraysCore.SVector{N, Float64}}} where N" href="#MCMRSimulator.project-Union{Tuple{N}, Tuple{MCMRSimulator.GridShape{N}, StaticArraysCore.SVector{N, Float64}}} where N"><code>MCMRSimulator.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(grid, position)</code></pre><p>Computes the voxel index for the position on the <a href="#MCMRSimulator.GridShape"><code>GridShape</code></a>.  This will return a result even if the point is outside of the grid. Use <a href="#MCMRSimulator.isinside-Tuple{Any, AbstractVector}"><code>isinside</code></a>(position, grid) to check that.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/grid.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.project_geometry-Union{Tuple{N}, Tuple{PlotPlane, TransformObstruction{N, M, K, B, O} where {M, K, B&lt;:BoundingBox{N}, O&lt;:MCMRSimulator.BaseObstruction{N}}}} where N" href="#MCMRSimulator.project_geometry-Union{Tuple{N}, Tuple{PlotPlane, TransformObstruction{N, M, K, B, O} where {M, K, B&lt;:BoundingBox{N}, O&lt;:MCMRSimulator.BaseObstruction{N}}}} where N"><code>MCMRSimulator.project_geometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project_geometry(plot_plane, transform)</code></pre><p>Projects the plane on the intrinsic plane of the obstructions deformed by <code>transform</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/geometry.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.project_on_grid-Tuple{PlotPlane, Snapshot{1}, Int64}" href="#MCMRSimulator.project_on_grid-Tuple{PlotPlane, Snapshot{1}, Int64}"><code>MCMRSimulator.project_on_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project_on_grid(plot_plane, snap, ngrid)</code></pre><p>Spins from the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> are projected onto the grid defined by <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a> in two ways:</p><ul><li>along the normal spins are projected onto the plane from infinitely far (TODO: give finite extent)</li><li>in the other directions any spins are projected onto the plane using mod(position[1], <code>sizex</code>) and mod(position[2], <code>sizey</code>).   This assumes that the geometry and field repeats itself ad infinitum beyond the <code>PlotPlane</code> (TODO: allow this assumption to be turned off).</li></ul><p>In effect, this means that all spins are projected onto the <code>PlotPlane</code>. The average spin orientation in each grid cell is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/plot_plane.jl#L105-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.propose_times-Tuple{TimeController, Number, Number, AbstractVector{&lt;:Sequence}, Number}" href="#MCMRSimulator.propose_times-Tuple{TimeController, Number, Number, AbstractVector{&lt;:Sequence}, Number}"><code>MCMRSimulator.propose_times</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propose_times(simulation, t_start, t_end)
propose_times(time_controller, t_start, t_end, sequences, diffusivity)</code></pre><p>Computes the timepoints at which the simulation will be evaluated when running from <code>t_start</code> to <code>t_end</code>.</p><p>The following timepoints will always be included</p><ul><li>Any multiple of the TR</li><li>Any RF pulse</li><li>Any change in the gradient strength</li></ul><p>Additional timepoints will be added to ensure that at any step the timestep is lower than the maximum timestep as described in <a href="#MCMRSimulator.TimeController"><code>TimeController</code></a>:</p><ul><li>the timestep needed to displace with the <code>simulation.time_controller.max_stepsize</code>.</li><li>at any time the timestep is larger than <span>$D^{-1/3} (360 * G \gamma)^{-2/3} / p$</span>, where <span>$p$</span> is the <code>simulation.time_controller.gradient_precision</code> (given in degrees).   The gradient <span>$G$</span> is the maximum of the user-applied gradient or the maximum off-resonance field gradient.</li><li>During an <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a> the rotation around the maximum magnetic field will be at most <code>simulation.time_controller.rf_rotation</code> degrees. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/timestep.jl#L36-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_annuli-Tuple{Any}" href="#MCMRSimulator.random_annuli-Tuple{Any}"><code>MCMRSimulator.random_annuli</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_annuli(target_density; repeats, g_ratio=0.8, distribution=Distributions.Gamma, mean_radius=1., variance_radius=0.5, max_iter=1000, myelin=false, chi_I=-0.1, chi_A=-0.1, rotation=I(3))</code></pre><p>Generate infinitely repeating box with non-overlapping annuli.</p><p>A rectangle with the size of <code>repeats</code> will be filled with annuli for a total surface density of <code>target_density</code>. The annulus outer radii will be drawn from the selected <code>distribution</code> (if not set, a Gamma distribution is used with given <code>mean_radius</code> and <code>var_radius</code>). An error is raised if no solution for non-overlapping annuli is found. The inner radius with respect to the outer radius is set by the <code>g-ratio</code>. Other annuli parameters (besides <code>inner</code>, <code>outer</code>, <code>positions</code>, and <code>repeats</code>) are identical as in <code>mr.annuli</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/annulus.jl#L124-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_cylinders-Tuple{Any}" href="#MCMRSimulator.random_cylinders-Tuple{Any}"><code>MCMRSimulator.random_cylinders</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_cylinders(target_density; repeats, distribution=Distributions.Gamma, mean_radius=1., variance_radius=0.5, max_iter=1000, g_ratio=1., chi_I=-0.1, chi_A=-0.1, rotation=I(3))</code></pre><p>Generate infinitely repeating box with non-overlapping cylinders.</p><p>A rectangle with the size of <code>repeats</code> will be filled with cylinders for a total surface density of <code>target_density</code>. The cylinder radii will be drawn from the selected <code>distribution</code> (if not set, a Gamma distribution is used with given <code>mean_radius</code> and <code>var_radius</code>). An error is raised if no solution for non-overlapping cylinders is found. Other cylinder parameters (besides <code>radii</code>, <code>shifts</code>, and <code>repeats</code>) are identical as in <code>mr.cylinders</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/cylinder.jl#L111-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_on_sphere-Tuple{}" href="#MCMRSimulator.random_on_sphere-Tuple{}"><code>MCMRSimulator.random_on_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_on_sphere()</code></pre><p>Draws a random orientation on the unit sphere as a length-3 vector</p><p>The z-orientation is drawn a random number between -1 and 1. The angle in the x-y plane is drawn as a random number between 0 and 2π. This results in an unbiased random distribution across the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/sphere.jl#L88-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_positions_radii-Tuple{Any, Real, Int64}" href="#MCMRSimulator.random_positions_radii-Tuple{Any, Real, Int64}"><code>MCMRSimulator.random_positions_radii</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_positions_radii(box_size, target_density, n_dimensions; distribution=Gamma, mean=1., variance=1., max_iter=1000, min_radius=0.1, max_radius=Inf)</code></pre><p>Randomly distributes circles or spheres in space.</p><p>Arguments:</p><ul><li><code>box_size</code>: Size of the infinitely repeating box of random positions</li><li><code>target_density</code>: Final density of the circles/spheres. This density will only be approximately reached</li><li><code>n_dimensions</code>: dimensionality of the space (2 for cicles; 3 for spheres)</li><li><code>distribution</code>: distribution from which the radii are drawn (from <a href="https://juliastats.org/Distributions.jl/stable/">Distributions.jl</a>)</li><li><code>mean</code>: mean of the gamma distribution (ignored if <code>distribution</code> explicitly set)</li><li><code>variance</code>: variance of the gamma distribution (ignored if <code>distribution</code> explicitly set)</li><li><code>max_iter</code>: maximum number of iterations to try to prevent the circles/spheres from overlapping. An error is raised if they still overlap after this number of iterations.</li><li><code>min_radius</code>: samples from the distribution below this radius will be rejected (in um).</li><li><code>max_radius</code>: samples from the distribution above this radius will be rejected (in um).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/random_draws.jl#L60-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_spheres-Tuple{Any}" href="#MCMRSimulator.random_spheres-Tuple{Any}"><code>MCMRSimulator.random_spheres</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_spheres(target_density; repeats, distribution=Distributions.Gamma, mean_radius=1., variance_radius=0.5, max_iter=1000, rotation=I(3))</code></pre><p>Generate infinitely repeating box with non-overlapping spheres.</p><p>A box with the size of <code>repeats</code> will be filled with spheres for a total volume density of <code>target_density</code>. The sphere radii will be drawn from the selected <code>distribution</code> (if not set, a Gamma distribution is used with given <code>mean_radius</code> and <code>var_radius</code>). An error is raised if no solution for non-overlapping spheres is found. Other sphere parameters (besides <code>radii</code>, <code>positions</code>, and <code>repeats</code>) are identical as in <code>mr.spheres</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/sphere.jl#L71-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_spirals-Tuple{Any}" href="#MCMRSimulator.random_spirals-Tuple{Any}"><code>MCMRSimulator.random_spirals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_spirals(target_density; repeats, g_ratio=0.8, distribution=Distributions.Gamma, mean_radius=1., variance_radius=0.5, max_iter=1000, rotation=I(3))</code></pre><p>Generate infinitely repeating box with non-overlapping spirals.</p><p>A rectangle with the size of <code>repeats</code> will be filled with spirals for a total surface density of <code>target_density</code>. The spiral outer radii will be drawn from the selected <code>distribution</code> (if not set, a Gamma distribution is used with given <code>mean_radius</code> and <code>var_radius</code>). An error is raised if no solution for non-overlapping annuli is found. The inner radius with respect to the outer radius is set by the <code>g-ratio</code>. Other spiral parameters (besides <code>inner</code>, <code>outer</code>, <code>positions</code>, and <code>repeats</code>) are identical as in <code>mr.spirals</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/spiral.jl#L290-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_surface_positions-Tuple{MCMRSimulator.BaseObstruction{2}, BoundingBox{3}, Number, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}" href="#MCMRSimulator.random_surface_positions-Tuple{MCMRSimulator.BaseObstruction{2}, BoundingBox{3}, Number, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}"><code>MCMRSimulator.random_surface_positions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_surface_positions(obstruction, bounding_box, surface_density[, repeats])</code></pre><p>Generates a set of random positions on the obstruction. It also returns the corresponding surface normals (pointing inwards!) and indices (for a mesh). This has been implemented for each obstruction to allow <a href="#MCMRSimulator.random_surface_spins-Union{Tuple{N}, Tuple{MCMRSimulator.BaseObstruction{N}, BoundingBox{3}, Number, StaticArraysCore.SVector{N, Float64}, Number, StaticArraysCore.SVector{N, Float64}}} where N"><code>random_surface_spins</code></a> to work.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L166-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_surface_spins-Union{Tuple{N}, Tuple{MCMRSimulator.BaseObstruction{N}, BoundingBox{3}, Number, StaticArraysCore.SVector{N, Float64}, Number, StaticArraysCore.SVector{N, Float64}}} where N" href="#MCMRSimulator.random_surface_spins-Union{Tuple{N}, Tuple{MCMRSimulator.BaseObstruction{N}, BoundingBox{3}, Number, StaticArraysCore.SVector{N, Float64}, Number, StaticArraysCore.SVector{N, Float64}}} where N"><code>MCMRSimulator.random_surface_spins</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_surface_spins(geometry, bounding_box, volume_density, repeats, default_surface_density, shift; longitudinal=1, transverse=0, phase=0, nsequences=1)</code></pre><p>Randomly generate stuck spins on the surface of the obstruction with the given magnetisation. For each obstruction in the geometry this will call <a href="#MCMRSimulator.random_surface_positions-Tuple{MCMRSimulator.BaseObstruction{2}, BoundingBox{3}, Number, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}"><code>random_surface_positions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.ray_grid_intersections-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Float64}, StaticArraysCore.SVector{N, Float64}}} where N" href="#MCMRSimulator.ray_grid_intersections-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Float64}, StaticArraysCore.SVector{N, Float64}}} where N"><code>MCMRSimulator.ray_grid_intersections</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ray_grid_intersections([grid, ]origin, destination)</code></pre><p>Computes all voxels crossed by a ray between <code>origin</code> and <code>destination</code> with a <a href="#MCMRSimulator.GridShape"><code>GridShape</code></a> (default infinitely extending 1x1x1 grid). Both origin and destination are length-3 vectors. The returned object is an iterator returning a tuple with:</p><ul><li>3-length vector with the voxel that we are crossing through</li><li>Float with the time the ray entered voxel (0=<code>origin</code>, 1=<code>destination</code>)</li><li>3-length vector with position within voxel that the ray entered (i.e., numbers between 0 and 1)</li><li>Float with the time the ray left the voxel (0=<code>origin</code>, 1=<code>destination</code>)</li><li>3-length vector with position within voxel that the ray left (i.e., numbers between 0 and 1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/grid.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.read_pulseq-Tuple{Any}" href="#MCMRSimulator.read_pulseq-Tuple{Any}"><code>MCMRSimulator.read_pulseq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_pulseq(filename; scanner=Scanner(B0=B0), B0=3., TR=&lt;sequence duration&gt;)</code></pre><p>Reads a sequence from a pulseq file (http://pulseq.github.io/). Pulseq files can be produced using matlab (http://pulseq.github.io/) or python (https://pypulseq.readthedocs.io/en/master/).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/pulseq.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.readout-Union{Tuple{N}, Tuple{Any, Simulation{N}}} where N" href="#MCMRSimulator.readout-Union{Tuple{N}, Tuple{Any, Simulation{N}}} where N"><code>MCMRSimulator.readout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readout(snapshot, simulation; bounding_box=&lt;1x1x1 mm box&gt;)</code></pre><p>Evolves the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> through the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>. Returns the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> at every <a href="#MCMRSimulator.Readout"><code>Readout</code></a> in the simulated sequences during a single TR. If no <code>TR</code> is explicitly selected, it will return the current TR if the snapshot has not passed any readouts and the next TR otherwise.</p><p>The return object depends on whether the simulation was created with a single sequence object or with a vector of sequences.</p><ul><li>For a single sequence object a vector of <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> objects is returned with a single snapshot for each <a href="#MCMRSimulator.Readout"><code>Readout</code></a> in the sequence.</li><li>For a vector of sequences a vector of vectors of <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> objects is returned. Each element in the outer vector contains the result for a single sequence.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/readout.jl#L151-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.relax!" href="#MCMRSimulator.relax!"><code>MCMRSimulator.relax!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">relax!(spin_orientation, timestep, mri, additional_off_resonance=0)</code></pre><p>Updates [<code>SpinOrientation</code>] after evolving for <code>timestep</code> with given <code>R1(mri)</code> (1/ms), <code>R2(mri)</code> (1/ms), and <code>off_resonance(mri) + additional_off_resonance</code> (kHz).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/relax.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.rotate-Union{Tuple{M}, Tuple{N}, Tuple{BoundingBox{N}, StaticArraysCore.SMatrix{M, N}}} where {N, M}" href="#MCMRSimulator.rotate-Union{Tuple{M}, Tuple{N}, Tuple{BoundingBox{N}, StaticArraysCore.SMatrix{M, N}}} where {N, M}"><code>MCMRSimulator.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate(bounding_box, rot_mat)</code></pre><p>Rotate the bounding box given a (NxM) rotation matrix. A new bounding box is returned that contains the old one.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/bounding_box.jl#L127-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.rotate_bvec-Tuple{AbstractVector{&lt;:Tuple{Real, Real}}, Any}" href="#MCMRSimulator.rotate_bvec-Tuple{AbstractVector{&lt;:Tuple{Real, Real}}, Any}"><code>MCMRSimulator.rotate_bvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_bvec(gradients, bvec)</code></pre><p>Rotates the gradients in <code>gradients</code> to align with <code>bvec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/gradients.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.sample-Tuple{MCMRSimulator.Shape, Number, Number}" href="#MCMRSimulator.sample-Tuple{MCMRSimulator.Shape, Number, Number}"><code>MCMRSimulator.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(shape, t1, t2)</code></pre><p>Returns the average value of the shape between <code>t1</code> and <code>t2</code>.  See <a href="#MCMRSimulator.sample_integral-Union{Tuple{MCMRSimulator.Shape{T}}, Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}, Tuple{MCMRSimulator.Shape{T}, Number, Number}} where T"><code>sample_integral</code></a> to get the full integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/shape.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.sample-Union{Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}} where T" href="#MCMRSimulator.sample-Union{Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}} where T"><code>MCMRSimulator.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(shape, time)</code></pre><p>Returns the value of the shape at a given time using linear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/shape.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.sample_derivative-Union{Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}} where T" href="#MCMRSimulator.sample_derivative-Union{Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}} where T"><code>MCMRSimulator.sample_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_derivative(shape, time[, later_time])</code></pre><p>Returns the derivative of the shape value at the specific time. At control points the derivative is always assumed to be the slope of the next block.</p><p>If <code>later_time</code> is provided the average derivative between both timepoints is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/shape.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.sample_integral-Union{Tuple{MCMRSimulator.Shape{T}}, Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}, Tuple{MCMRSimulator.Shape{T}, Number, Number}} where T" href="#MCMRSimulator.sample_integral-Union{Tuple{MCMRSimulator.Shape{T}}, Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}, Tuple{MCMRSimulator.Shape{T}, Number, Number}} where T"><code>MCMRSimulator.sample_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_integral(shape, t0, t1)</code></pre><p>Integrate the shape value from t0 to t1.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/shape.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.sample_integral-Union{Tuple{T}, Tuple{MCMRSimulator.Shape, T, AbstractVector{T}}} where T&lt;:Number" href="#MCMRSimulator.sample_integral-Union{Tuple{T}, Tuple{MCMRSimulator.Shape, T, AbstractVector{T}}} where T&lt;:Number"><code>MCMRSimulator.sample_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_integral(shape, t0, times)</code></pre><p>Integrate the shape value from t0 to all the times in <code>times</code> (all assumed to be larger than <code>t0</code> and strictly increasing).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/shape.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.sample_integral_step" href="#MCMRSimulator.sample_integral_step"><code>MCMRSimulator.sample_integral_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample_integral_step(shape, index, t0=`start of block`, t1=`end of block`)</code></pre><p>Integrate the shape value from t0 to t1 assuming that both are within the single step (given by <code>index</code>). This is a helper function for <a href="#MCMRSimulator.sample_integral-Union{Tuple{MCMRSimulator.Shape{T}}, Tuple{T}, Tuple{MCMRSimulator.Shape{T}, Number}, Tuple{MCMRSimulator.Shape{T}, Number, Number}} where T"><code>sample_integral</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence/shape.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.scatter_snapshot!-Tuple" href="#MCMRSimulator.scatter_snapshot!-Tuple"><code>MCMRSimulator.scatter_snapshot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(snapshot)
plot!(snapshot)
scatter_snapshot(snapshot)
scatter_snapshot!(snapshot)</code></pre><p>Plots the spin positions in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> in 3D color coded by the spin&#39;s orientation (see <a href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>color</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/snapshot.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.scatter_snapshot-Tuple" href="#MCMRSimulator.scatter_snapshot-Tuple"><code>MCMRSimulator.scatter_snapshot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(snapshot)
plot!(snapshot)
scatter_snapshot(snapshot)
scatter_snapshot!(snapshot)</code></pre><p>Plots the spin positions in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> in 3D color coded by the spin&#39;s orientation (see <a href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>color</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/snapshot.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.sequence_plot" href="#MCMRSimulator.sequence_plot"><code>MCMRSimulator.sequence_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot(sequence)
plot!(sequence)
plot_sequence(sequence)
plot_sequence!(sequence)</code></pre><p>Creates a visual representation of a <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/sequence.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N" href="#MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N"><code>MCMRSimulator.signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signal(snapshot, simulation, times=[TR]; bounding_box=&lt;1x1x1 mm box&gt;)</code></pre><p>Evolves the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> through the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> and outputs the total signal at the requested times. To get the full snapshot at each timepoint use <a href="#MCMRSimulator.trajectory-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N"><code>trajectory</code></a>.</p><p>The return object depends on whether the simulation was created with a single sequence object or with a vector of sequences.</p><ul><li>For a single sequence object a vector of <a href="#MCMRSimulator.SpinOrientation"><code>SpinOrientation</code></a> object with the total signal at each time is returned.</li><li>For a vector of sequences the return type is a (Nt, Ns) matrix of <a href="#MCMRSimulator.SpinOrientation"><code>SpinOrientation</code></a> objects for <code>Nt</code> timepoints and <code>Ns</code> sequences.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/readout.jl#L217-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.size_scale" href="#MCMRSimulator.size_scale"><code>MCMRSimulator.size_scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">size_scale(geometry)
size_scale(obstruction)</code></pre><p>Computes the minimum size scale of the obstructions in the geometry.</p><p>The size scale for each obstruction is defined as:</p><ul><li><a href="#MCMRSimulator.cylinders-Tuple"><code>cylinders</code></a>/<a href="#MCMRSimulator.spheres-Tuple"><code>spheres</code></a>: minimum radius</li><li><a href="#MCMRSimulator.annuli-Tuple"><code>annuli</code></a>: minimum inner radius</li><li><a href="#MCMRSimulator.Mesh"><code>Mesh</code></a>: square root of median triangle size</li><li><a href="#MCMRSimulator.Wall"><code>Wall</code></a>: distance between closest walls (infinite for single, non-repeating walls)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L106-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.spheres-Tuple" href="#MCMRSimulator.spheres-Tuple"><code>MCMRSimulator.spheres</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spheres(radii; positions=[[0, 0, 0]], repeats=[Inf, Inf, Inf], rotation=I(3))</code></pre><p>Creates one or more <a href="#MCMRSimulator.Sphere"><code>Sphere</code></a>s with given radius (or vector of <code>radii</code>). The <code>positions</code>, <code>repeats</code>, and <code>rotation</code> control the sphere positions and is explained in  more detail in <a href="../geometry/#Defining-the-geometry">Defining the geometry</a>. Additional keyword arguments are available to set generic obstruction settings as described in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/sphere.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.spin_echo-Tuple{Any}" href="#MCMRSimulator.spin_echo-Tuple{Any}"><code>MCMRSimulator.spin_echo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spin_echo(TE; TR=&lt;TE&gt;, scanner=&lt;3T scanner&gt;, excitation_pulse=Instant, excitation_time=&lt;half pulse duration&gt;, refocus_pulse=Instant, refocus_time=&lt;half pulse duration&gt;)</code></pre><p>Creates a gradient echo sequence consisting of:</p><ul><li><code>excitation_pulse</code>: by default this is an <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a>, but can be replaced with an <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a>. If the excitation does not take place halfway the RF pulse, <code>excitation_time</code> should be set as well.</li><li>a delay</li><li><code>refocus_pulse</code>: by default this is an <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a>, but can be replaced with an <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a>. If the refocus does not take place halfway the RF pulse, <code>refocus_time</code> should be set as well.</li><li>a readout <code>TE</code> ms after the excitation.</li></ul><p>The refocus time is always halfway the excitation time and the readout.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/sequence_builder/sequences/spin_echo.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.spiral_theta-Tuple{Spiral, StaticArraysCore.SVector{2, Float64}}" href="#MCMRSimulator.spiral_theta-Tuple{Spiral, StaticArraysCore.SVector{2, Float64}}"><code>MCMRSimulator.spiral_theta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spiral_theta(spiral, position; assume_inner)</code></pre><p>Computes the location of the particle within the spiral. This function returns 0 if the particle has just entered the inner part of the spiral. Each wrap further outwards will add 2π to the result.</p><p>When the particle is at the spiral edge, <code>assume_inner</code> should be set to true if the particle should be considered just on the inner side of the surface or to false if it should be considered just on the outer surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/spiral.jl#L35-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.spirals-Tuple" href="#MCMRSimulator.spirals-Tuple"><code>MCMRSimulator.spirals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spirals(inner, outer; theta0=0., thickness=0.014, myelin=false, chi_I=-0.1, chi_A=-0.1, positions=[0, 0], repeats=[Inf, Inf], rotation=I(3)</code></pre><p>Creates one or more <a href="#MCMRSimulator.Spiral"><code>Spiral</code></a>. Spirals range from <code>inner</code> to <code>outer</code> radii starting at an angle of <code>theta0</code>. Each wrap has a thickness of <code>thickness</code> micrometers. Inner/outer cylinders can be added using respectively the <code>inner_cylinder</code> and <code>outer_cylinder</code> flags (default: only inner cylinder).</p><p>Myelinated spirals can be created by setting the <code>myelin</code> to true. All parameters can be either a single value or a vector of values.</p><p>The <code>positions</code>, <code>repeats</code>, and <code>rotation</code> control the annulus position and orientation and is explained in  more detail in <a href="../geometry/#Defining-the-geometry">Defining the geometry</a>. Additional keyword arguments are available to set generic obstruction settings as described in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/spiral.jl#L62-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.stick_probability-NTuple{4, Number}" href="#MCMRSimulator.stick_probability-NTuple{4, Number}"><code>MCMRSimulator.stick_probability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stick_probability(surface_density, dwell_time, diffusivity, timestep)
stick_probability(properties, diffusivity, timestep)</code></pre><p>Computes the probability of a spin getting stuck at the surface given a <a href="#MCMRSimulator.surface_density-Tuple{ObstructionProperties, Any}"><code>surface_density</code></a> and <a href="#MCMRSimulator.dwell_time-Tuple{ObstructionProperties, Any}"><code>dwell_time</code></a> from a <a href="#MCMRSimulator.CollisionProperties"><code>CollisionProperties</code></a> as well as the diffusivity (in um^2/ms) and the timestep (in ms).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L282-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.stuck-Tuple{Spin}" href="#MCMRSimulator.stuck-Tuple{Spin}"><code>MCMRSimulator.stuck</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stuck(spin)</code></pre><p>Returns true if the spin is stuck on the surface. This can be used to filter a <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> using:</p><pre><code class="language-julia hljs">only_stuck = filter(stuck, snapshot)
only_free = filter(s -&gt; !stuck(s), snapshot)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L121-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.surface_MRI_properties-Tuple{MCMRSimulator.Collision, MRIProperties}" href="#MCMRSimulator.surface_MRI_properties-Tuple{MCMRSimulator.Collision, MRIProperties}"><code>MCMRSimulator.surface_MRI_properties</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surface_MRI_properties(collision, defaults::MRIProperties)</code></pre><p>Computes the MRI properties at the surface for spins stuck at the given collision.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/collision.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.surface_density-Tuple{ObstructionProperties, Any}" href="#MCMRSimulator.surface_density-Tuple{ObstructionProperties, Any}"><code>MCMRSimulator.surface_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surface_density(properties)
surface_density(obstruction_properties, global_properties)</code></pre><p>The surface_density, which affects the spin when colliding with an obstruction. It can be either set when creating a <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>, in which case it is stored in <a href="#MCMRSimulator.GlobalProperties"><code>GlobalProperties</code></a> or when creating any <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a>, in which case it is stored in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/properties.jl#L259-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.total_susceptibility-Tuple{MCMRSimulator.BaseObstruction}" href="#MCMRSimulator.total_susceptibility-Tuple{MCMRSimulator.BaseObstruction}"><code>MCMRSimulator.total_susceptibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">total_susceptibility(obstruction)</code></pre><p>Computes total surface (for 2D) or volume (for 3D) susceptibility of a base obstruction.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/base.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.trajectory-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N" href="#MCMRSimulator.trajectory-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N"><code>MCMRSimulator.trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trajectory(snapshot, simulation, times=[TR]; bounding_box=&lt;1x1x1 mm box&gt;)</code></pre><p>Evolves the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> through the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> and outputs at the requested times. Returns a vector of <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> objects with the current state of each time in times. When you are only interested in the signal at each timepoint, use <a href="#MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N"><code>signal</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/readout.jl#L200-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.transfer!-Tuple{SpinOrientation, Float64}" href="#MCMRSimulator.transfer!-Tuple{SpinOrientation, Float64}"><code>MCMRSimulator.transfer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transfer!(orientation, MT_fraction)</code></pre><p>Loses <code>MT_fraction</code> spin from <code>orientation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/relax.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.transverse" href="#MCMRSimulator.transverse"><code>MCMRSimulator.transverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transverse(spin)
transverse(snapshot)</code></pre><p>Returns the transverse spin (i.e., magnitude in the plane perpendicular to the magnetic field) for a single particle (<a href="#MCMRSimulator.Spin"><code>Spin</code></a>) or averaged across a group of particles in a [<code>Snapshot</code>]. When orientations for multiple sequences are available an array of transverse values is returned with a value for each sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/spin.jl#L156-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.triangle_size-Tuple{Any, Any, Any}" href="#MCMRSimulator.triangle_size-Tuple{Any, Any, Any}"><code>MCMRSimulator.triangle_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangle_size(p1, p2, p3)</code></pre><p>Computes the size of a triangle formed by three points</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/mesh.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.walls-Tuple{}" href="#MCMRSimulator.walls-Tuple{}"><code>MCMRSimulator.walls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">walls(positions=0, repeats=Inf, rotation=I(3))</code></pre><p>Creates one or more <a href="#MCMRSimulator.Wall"><code>Wall</code></a>s. The <code>positions</code>, <code>repeats</code>, and <code>rotation</code> control the wall position and orientation and is explained in  more detail in <a href="../geometry/#Defining-the-geometry">Defining the geometry</a>. Additional keyword arguments are available to set generic obstruction settings as described in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/geometry/base/wall.jl#L15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MakieCore.plot!-Tuple{MakieCore.Combined{MCMRSimulator.dyad_snapshot}}" href="#MakieCore.plot!-Tuple{MakieCore.Combined{MCMRSimulator.dyad_snapshot}}"><code>MakieCore.plot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)
dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)</code></pre><p>Plots the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> projected onto given <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>. Each spin is represented by an arrow showing the transverse component of the spin.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/a2011405606ba89e754bf7179da2267f300c595d/src/plot/snapshot.jl#L39-L45">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../properties/">« MRI/collision properties</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 25 March 2023 13:46">Saturday 25 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
