<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MCMRSimulator.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MCMRSimulator.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../obstructions/">Geometry</a></li><li><a class="tocitem" href="../sequence/">Sequence</a></li><li><a class="tocitem" href="../off_resonance/">Magnetic susceptibility</a></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/main/docs/src/api.md#" title="Edit source"><span class="docs-icon fa"></span><span class="docs-label is-hidden-touch">Edit source</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="api"><a class="docs-heading-anchor" href="#api">MCMRSimulator.jl API</a><a id="api-1"></a><a class="docs-heading-anchor-permalink" href="#api" title="Permalink"></a></h1><p>This is the API for <a href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl">MCMRSimulator</a>. For a more friendly introduction, click <a href="../#Introduction">here</a></p><ul><li><a href="#MCMRSimulator.MCMRSimulator"><code>MCMRSimulator.MCMRSimulator</code></a></li><li><a href="#MCMRSimulator.Siemens_Connectom"><code>MCMRSimulator.Siemens_Connectom</code></a></li><li><a href="#MCMRSimulator.Siemens_Prisma"><code>MCMRSimulator.Siemens_Prisma</code></a></li><li><a href="#MCMRSimulator.Siemens_Terra"><code>MCMRSimulator.Siemens_Terra</code></a></li><li><a href="#MCMRSimulator.Annulus"><code>MCMRSimulator.Annulus</code></a></li><li><a href="#MCMRSimulator.BaseObstruction"><code>MCMRSimulator.BaseObstruction</code></a></li><li><a href="#MCMRSimulator.BoundingBox"><code>MCMRSimulator.BoundingBox</code></a></li><li><a href="#MCMRSimulator.Collision"><code>MCMRSimulator.Collision</code></a></li><li><a href="#MCMRSimulator.CollisionProperties"><code>MCMRSimulator.CollisionProperties</code></a></li><li><a href="#MCMRSimulator.ConcreteShape-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>MCMRSimulator.ConcreteShape</code></a></li><li><a href="#MCMRSimulator.ConcreteShape"><code>MCMRSimulator.ConcreteShape</code></a></li><li><a href="#MCMRSimulator.ConcreteShape-Tuple{}"><code>MCMRSimulator.ConcreteShape</code></a></li><li><a href="#MCMRSimulator.Cylinder"><code>MCMRSimulator.Cylinder</code></a></li><li><a href="#MCMRSimulator.Field"><code>MCMRSimulator.Field</code></a></li><li><a href="#MCMRSimulator.FixedXoshiro"><code>MCMRSimulator.FixedXoshiro</code></a></li><li><a href="#MCMRSimulator.Float"><code>MCMRSimulator.Float</code></a></li><li><a href="#MCMRSimulator.Geometry"><code>MCMRSimulator.Geometry</code></a></li><li><a href="#MCMRSimulator.GlobalProperties"><code>MCMRSimulator.GlobalProperties</code></a></li><li><a href="#MCMRSimulator.GridShape"><code>MCMRSimulator.GridShape</code></a></li><li><a href="#MCMRSimulator.InstantGradient"><code>MCMRSimulator.InstantGradient</code></a></li><li><a href="#MCMRSimulator.InstantRFPulse"><code>MCMRSimulator.InstantRFPulse</code></a></li><li><a href="#MCMRSimulator.MRGradients"><code>MCMRSimulator.MRGradients</code></a></li><li><a href="#MCMRSimulator.MRIProperties"><code>MCMRSimulator.MRIProperties</code></a></li><li><a href="#MCMRSimulator.Mesh"><code>MCMRSimulator.Mesh</code></a></li><li><a href="#MCMRSimulator.Microstructure"><code>MCMRSimulator.Microstructure</code></a></li><li><a href="#MCMRSimulator.Movement"><code>MCMRSimulator.Movement</code></a></li><li><a href="#MCMRSimulator.Obstruction"><code>MCMRSimulator.Obstruction</code></a></li><li><a href="#MCMRSimulator.ObstructionProperties"><code>MCMRSimulator.ObstructionProperties</code></a></li><li><a href="#MCMRSimulator.PlotPlane"><code>MCMRSimulator.PlotPlane</code></a></li><li><a href="#MCMRSimulator.PosVector"><code>MCMRSimulator.PosVector</code></a></li><li><a href="#MCMRSimulator.RFPulse"><code>MCMRSimulator.RFPulse</code></a></li><li><a href="#MCMRSimulator.Readout"><code>MCMRSimulator.Readout</code></a></li><li><a href="#MCMRSimulator.Scanner"><code>MCMRSimulator.Scanner</code></a></li><li><a href="#MCMRSimulator.Sequence"><code>MCMRSimulator.Sequence</code></a></li><li><a href="#MCMRSimulator.Shape"><code>MCMRSimulator.Shape</code></a></li><li><a href="#MCMRSimulator.Simulation"><code>MCMRSimulator.Simulation</code></a></li><li><a href="#MCMRSimulator.Snapshot"><code>MCMRSimulator.Snapshot</code></a></li><li><a href="#MCMRSimulator.Sphere"><code>MCMRSimulator.Sphere</code></a></li><li><a href="#MCMRSimulator.Spin"><code>MCMRSimulator.Spin</code></a></li><li><a href="#MCMRSimulator.SpinOrientation"><code>MCMRSimulator.SpinOrientation</code></a></li><li><a href="#MCMRSimulator.Spiral"><code>MCMRSimulator.Spiral</code></a></li><li><a href="#MCMRSimulator.TransformObstruction"><code>MCMRSimulator.TransformObstruction</code></a></li><li><a href="#MCMRSimulator.Wall"><code>MCMRSimulator.Wall</code></a></li><li><a href="#MCMRSimulator.B0-Tuple{Scanner}"><code>MCMRSimulator.B0</code></a></li><li><a href="#MCMRSimulator.amplitude-Tuple{MCMRSimulator.Shape, Number}"><code>MCMRSimulator.amplitude</code></a></li><li><a href="#MCMRSimulator.amplitude-Tuple{MCMRSimulator.RFPulse, Number}"><code>MCMRSimulator.amplitude</code></a></li><li><a href="#MCMRSimulator.amplitude_derivative-Union{Tuple{N}, Tuple{MCMRSimulator.Shape{N}, Number}} where N"><code>MCMRSimulator.amplitude_derivative</code></a></li><li><a href="#MCMRSimulator.amplitude_integral-Union{Tuple{T}, Tuple{MCMRSimulator.Shape, T, AbstractVector{T}}} where T&lt;:Number"><code>MCMRSimulator.amplitude_integral</code></a></li><li><a href="#MCMRSimulator.amplitude_integral-Tuple{MCMRSimulator.Shape, Number, Number}"><code>MCMRSimulator.amplitude_integral</code></a></li><li><a href="#MCMRSimulator.amplitude_integral_step"><code>MCMRSimulator.amplitude_integral_step</code></a></li><li><a href="#MCMRSimulator.annuli-Tuple"><code>MCMRSimulator.annuli</code></a></li><li><a href="#MCMRSimulator.apply!-Tuple{InstantRFPulse, SpinOrientation}"><code>MCMRSimulator.apply!</code></a></li><li><a href="#MCMRSimulator.collided-Tuple{MCMRSimulator.BaseObstruction, MCMRSimulator.Collision}"><code>MCMRSimulator.collided</code></a></li><li><a href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>MCMRSimulator.color</code></a></li><li><a href="#MCMRSimulator.constant_pulse-Tuple{Number, Number, Number}"><code>MCMRSimulator.constant_pulse</code></a></li><li><a href="#MCMRSimulator.corners-Tuple{MCMRSimulator.BoundingBox{3}}"><code>MCMRSimulator.corners</code></a></li><li><a href="#MCMRSimulator.correct_collisions-Tuple{MCMRSimulator.Movement, Any}"><code>MCMRSimulator.correct_collisions</code></a></li><li><a href="#MCMRSimulator.cylinders-Tuple"><code>MCMRSimulator.cylinders</code></a></li><li><a href="#MCMRSimulator.derive_qval_time-Tuple{Union{Nothing, Real}, Union{Nothing, Real}, Union{Nothing, Real}, Real}"><code>MCMRSimulator.derive_qval_time</code></a></li><li><a href="#MCMRSimulator.detect_collision"><code>MCMRSimulator.detect_collision</code></a></li><li><a href="#MCMRSimulator.detect_collision"><code>MCMRSimulator.detect_collision</code></a></li><li><a href="#MCMRSimulator.draw_step!-Tuple{Spin, Float64, Float64, MCMRSimulator.GlobalProperties}"><code>MCMRSimulator.draw_step!</code></a></li><li><a href="#MCMRSimulator.dwi-Tuple{}"><code>MCMRSimulator.dwi</code></a></li><li><a href="#MCMRSimulator.dyad_snapshot-Tuple"><code>MCMRSimulator.dyad_snapshot</code></a></li><li><a href="#MCMRSimulator.dyad_snapshot!-Tuple"><code>MCMRSimulator.dyad_snapshot!</code></a></li><li><a href="#MCMRSimulator.effective_pulse-Tuple{Sequence, Number, Number}"><code>MCMRSimulator.effective_pulse</code></a></li><li><a href="#MCMRSimulator.effective_pulse-Tuple{MCMRSimulator.RFPulse, Number, Number}"><code>MCMRSimulator.effective_pulse</code></a></li><li><a href="#MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>MCMRSimulator.evolve</code></a></li><li><a href="#MCMRSimulator.evolve_to_time-Union{Tuple{N}, Tuple{Snapshot{N}, Simulation{N}, Float64}} where N"><code>MCMRSimulator.evolve_to_time</code></a></li><li><a href="#MCMRSimulator.evolve_to_time!-Union{Tuple{N}, Tuple{Spin{N}, Simulation{N}, StaticArraysCore.SVector{N, Tuple{InstantRFPulse, InstantRFPulse}}, Float64, Float64}} where N"><code>MCMRSimulator.evolve_to_time!</code></a></li><li><a href="#MCMRSimulator.expand"><code>MCMRSimulator.expand</code></a></li><li><a href="#MCMRSimulator.field-Tuple{}"><code>MCMRSimulator.field</code></a></li><li><a href="#MCMRSimulator.fit_time-Tuple{}"><code>MCMRSimulator.fit_time</code></a></li><li><a href="#MCMRSimulator.flip_angle-Tuple{InstantRFPulse}"><code>MCMRSimulator.flip_angle</code></a></li><li><a href="#MCMRSimulator.get_sequence-Tuple{Spin, Any}"><code>MCMRSimulator.get_sequence</code></a></li><li><a href="#MCMRSimulator.get_time-Tuple{Snapshot}"><code>MCMRSimulator.get_time</code></a></li><li><a href="#MCMRSimulator.gradient-Tuple{MRGradients, Number}"><code>MCMRSimulator.gradient</code></a></li><li><a href="#MCMRSimulator.gradient-Tuple{AbstractVector, Sequence, Number}"><code>MCMRSimulator.gradient</code></a></li><li><a href="#MCMRSimulator.image_snapshot-Tuple"><code>MCMRSimulator.image_snapshot</code></a></li><li><a href="#MCMRSimulator.image_snapshot!-Tuple"><code>MCMRSimulator.image_snapshot!</code></a></li><li><a href="#MCMRSimulator.isinside-Tuple{Any, Spin}"><code>MCMRSimulator.isinside</code></a></li><li><a href="#MCMRSimulator.load_mesh-Tuple{IO}"><code>MCMRSimulator.load_mesh</code></a></li><li><a href="#MCMRSimulator.longitudinal"><code>MCMRSimulator.longitudinal</code></a></li><li><a href="#MCMRSimulator.lorentz_off_resonance"><code>MCMRSimulator.lorentz_off_resonance</code></a></li><li><a href="#MCMRSimulator.max_gradient"><code>MCMRSimulator.max_gradient</code></a></li><li><a href="#MCMRSimulator.max_slew_rate"><code>MCMRSimulator.max_slew_rate</code></a></li><li><a href="#MCMRSimulator.mesh_grid_intersection-Tuple{MCMRSimulator.GridShape, Vector{StaticArraysCore.SVector{3, Float64}}, Vector{StaticArraysCore.SVector{3, Int64}}}"><code>MCMRSimulator.mesh_grid_intersection</code></a></li><li><a href="#MCMRSimulator.norm_angle-Tuple{Any}"><code>MCMRSimulator.norm_angle</code></a></li><li><a href="#MCMRSimulator.normal-Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}"><code>MCMRSimulator.normal</code></a></li><li><a href="#MCMRSimulator.off_resonance-Tuple{Cylinder, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}"><code>MCMRSimulator.off_resonance</code></a></li><li><a href="#MCMRSimulator.off_resonance-Tuple{MCMRSimulator.RFPulse, Number}"><code>MCMRSimulator.off_resonance</code></a></li><li><a href="#MCMRSimulator.orientation"><code>MCMRSimulator.orientation</code></a></li><li><a href="#MCMRSimulator.perfect_dwi-Tuple{}"><code>MCMRSimulator.perfect_dwi</code></a></li><li><a href="#MCMRSimulator.phase-Tuple{MCMRSimulator.RFPulse, Number}"><code>MCMRSimulator.phase</code></a></li><li><a href="#MCMRSimulator.phase"><code>MCMRSimulator.phase</code></a></li><li><a href="#MCMRSimulator.phase-Tuple{InstantRFPulse}"><code>MCMRSimulator.phase</code></a></li><li><a href="#MCMRSimulator.plot_geometry-Tuple"><code>MCMRSimulator.plot_geometry</code></a></li><li><a href="#MCMRSimulator.plot_geometry!-Tuple"><code>MCMRSimulator.plot_geometry!</code></a></li><li><a href="#MCMRSimulator.plot_off_resonance-Tuple"><code>MCMRSimulator.plot_off_resonance</code></a></li><li><a href="#MCMRSimulator.plot_off_resonance!-Tuple"><code>MCMRSimulator.plot_off_resonance!</code></a></li><li><a href="#MCMRSimulator.plot_snapshot"><code>MCMRSimulator.plot_snapshot</code></a></li><li><a href="#MCMRSimulator.plot_trajectory2d-Tuple"><code>MCMRSimulator.plot_trajectory2d</code></a></li><li><a href="#MCMRSimulator.plot_trajectory2d!-Tuple"><code>MCMRSimulator.plot_trajectory2d!</code></a></li><li><a href="#MCMRSimulator.plot_trajectory3d-Tuple"><code>MCMRSimulator.plot_trajectory3d</code></a></li><li><a href="#MCMRSimulator.plot_trajectory3d!-Tuple"><code>MCMRSimulator.plot_trajectory3d!</code></a></li><li><a href="#MCMRSimulator.ply_from_mesh-Tuple{Any}"><code>MCMRSimulator.ply_from_mesh</code></a></li><li><a href="#MCMRSimulator.position-Tuple{Snapshot}"><code>MCMRSimulator.position</code></a></li><li><a href="#MCMRSimulator.position-Tuple{Spin}"><code>MCMRSimulator.position</code></a></li><li><a href="#MCMRSimulator.produces_off_resonance-Tuple{MCMRSimulator.Geometry}"><code>MCMRSimulator.produces_off_resonance</code></a></li><li><a href="#MCMRSimulator.produces_off_resonance-Tuple{MCMRSimulator.BaseObstruction}"><code>MCMRSimulator.produces_off_resonance</code></a></li><li><a href="#MCMRSimulator.project"><code>MCMRSimulator.project</code></a></li><li><a href="#MCMRSimulator.project-Tuple{PlotPlane, StaticArraysCore.SVector{3, Float64}}"><code>MCMRSimulator.project</code></a></li><li><a href="#MCMRSimulator.project_geometry-Union{Tuple{N}, Tuple{PlotPlane, TransformObstruction{N, M, K, O} where {M, K, O&lt;:MCMRSimulator.BaseObstruction{N}}}} where N"><code>MCMRSimulator.project_geometry</code></a></li><li><a href="#MCMRSimulator.project_on_grid-Tuple{PlotPlane, Snapshot{1}, Int64}"><code>MCMRSimulator.project_on_grid</code></a></li><li><a href="#MCMRSimulator.propose_times-Tuple{MCMRSimulator.TimeController, Number, Number, AbstractVector{&lt;:Sequence}, Number}"><code>MCMRSimulator.propose_times</code></a></li><li><a href="#MCMRSimulator.random_annuli-Tuple{Any}"><code>MCMRSimulator.random_annuli</code></a></li><li><a href="#MCMRSimulator.random_cylinders-Tuple{Any}"><code>MCMRSimulator.random_cylinders</code></a></li><li><a href="#MCMRSimulator.random_gauss-Tuple{Float64, Float64}"><code>MCMRSimulator.random_gauss</code></a></li><li><a href="#MCMRSimulator.random_on_sphere-Tuple{}"><code>MCMRSimulator.random_on_sphere</code></a></li><li><a href="#MCMRSimulator.random_positions_radii-Tuple{Any, Real, Int64}"><code>MCMRSimulator.random_positions_radii</code></a></li><li><a href="#MCMRSimulator.random_spheres-Tuple{Any}"><code>MCMRSimulator.random_spheres</code></a></li><li><a href="#MCMRSimulator.random_spirals-Tuple{Any}"><code>MCMRSimulator.random_spirals</code></a></li><li><a href="#MCMRSimulator.ray_grid_intersections-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Float64}, StaticArraysCore.SVector{N, Float64}}} where N"><code>MCMRSimulator.ray_grid_intersections</code></a></li><li><a href="#MCMRSimulator.readout-Union{Tuple{N}, Tuple{Any, Simulation{N}}} where N"><code>MCMRSimulator.readout</code></a></li><li><a href="#MCMRSimulator.relax!"><code>MCMRSimulator.relax!</code></a></li><li><a href="#MCMRSimulator.rotate_bvec-Tuple{AbstractVector{&lt;:Tuple{Real, Real}}, Any}"><code>MCMRSimulator.rotate_bvec</code></a></li><li><a href="#MCMRSimulator.scatter_snapshot-Tuple"><code>MCMRSimulator.scatter_snapshot</code></a></li><li><a href="#MCMRSimulator.scatter_snapshot!-Tuple"><code>MCMRSimulator.scatter_snapshot!</code></a></li><li><a href="#MCMRSimulator.sequence_plot"><code>MCMRSimulator.sequence_plot</code></a></li><li><a href="#MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>MCMRSimulator.signal</code></a></li><li><a href="#MCMRSimulator.spheres-Tuple"><code>MCMRSimulator.spheres</code></a></li><li><a href="#MCMRSimulator.spiral_theta-Tuple{Spiral, StaticArraysCore.SVector{2, Float64}}"><code>MCMRSimulator.spiral_theta</code></a></li><li><a href="#MCMRSimulator.spirals-Tuple"><code>MCMRSimulator.spirals</code></a></li><li><a href="#MCMRSimulator.total_susceptibility-Tuple{MCMRSimulator.BaseObstruction}"><code>MCMRSimulator.total_susceptibility</code></a></li><li><a href="#MCMRSimulator.trajectory-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>MCMRSimulator.trajectory</code></a></li><li><a href="#MCMRSimulator.transfer!-Tuple{SpinOrientation, Float64}"><code>MCMRSimulator.transfer!</code></a></li><li><a href="#MCMRSimulator.transverse"><code>MCMRSimulator.transverse</code></a></li><li><a href="#MCMRSimulator.walls-Tuple{}"><code>MCMRSimulator.walls</code></a></li><li><a href="#MakieCore.plot!-Tuple{MakieCore.Combined{MCMRSimulator.dyad_snapshot}}"><code>MakieCore.plot!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.MCMRSimulator" href="#MCMRSimulator.MCMRSimulator"><code>MCMRSimulator.MCMRSimulator</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This package supports the running of MR Monte Carlo simulations.</p><p>In these simulations hundreds of thousands or millions of particles randomly diffuse through some tissue microstructure constrained by a series of <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a> objects. The spins of these particles will be evolved by the effect of one or more <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> objects as well as spatially varying <a href="#MCMRSimulator.Field"><code>Field</code></a> objecs describing the R1, R2, diffusivity, and off-resonance fields. Off-resonance fields can also be generated by the <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a> objects themselves. All of these variables are combined into a single <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> object.  See <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> for how to run the simulation.</p><p>Plotting support for the output is also available based on <a href="https://makie.juliaplots.org/stable/">Makie.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/MCMRSimulator.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Siemens_Connectom" href="#MCMRSimulator.Siemens_Connectom"><code>MCMRSimulator.Siemens_Connectom</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Siemens 3T Connectom MRI scanner (<a href="../references/#fan22_MappingHumanConnectome">Qiuyun Fan, Cornelius Eichner, Maryam Afzali, Lars Mueller, Chantal M. W. Tax, Mathias Davids, Mirsad Mahmutovic, Boris Keil, Berkin Bilgic, Kawin Setsompop, Hong-Hsi Lee, Qiyuan Tian, Chiara Maffei, Gabriel {Ramos-Llord{\&#39;e}n}, Aapo Nummenmaa, Thomas Witzel, Anastasia Yendiki, Yi-Qiao Song, Chu-Chung Huang, Ching-Po Lin, Nikolaus Weiskopf, Alfred Anwander, Derek K. Jones, Bruce R. Rosen, Lawrence L. Wald, Susie Y. Huang (2022)</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/scanner.jl#L63-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Siemens_Prisma" href="#MCMRSimulator.Siemens_Prisma"><code>MCMRSimulator.Siemens_Prisma</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Siemens MAGNETOM 3T Prisma MRI scanner (https://www.siemens-healthineers.com/en-uk/magnetic-resonance-imaging/3t-mri-scanner/magnetom-prisma).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/scanner.jl#L53-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Siemens_Terra" href="#MCMRSimulator.Siemens_Terra"><code>MCMRSimulator.Siemens_Terra</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Siemens MAGNETOM 7T Terra MRI scanner (https://www.siemens-healthineers.com/en-uk/magnetic-resonance-imaging/7t-mri-scanner/magnetom-terra)</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/scanner.jl#L58-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Annulus" href="#MCMRSimulator.Annulus"><code>MCMRSimulator.Annulus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Annulus(inner_radius, outer_radius; chi_I=-0.1, chi_A=-0.1, myelin=false)</code></pre><p>Create an annulus with an inner and outer radius. Using <a href="#MCMRSimulator.annuli-Tuple"><code>annuli</code></a> is recommended. Water can freely diffuse within the inner radius, and between the inner and outer radius, but not in between. Myelin can be added by setting <code>myelin</code> to true. Restrictions are only present at the inner and outer cylinder, not in the myelin in between.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/annulus.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.BaseObstruction" href="#MCMRSimulator.BaseObstruction"><code>MCMRSimulator.BaseObstruction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Base obstruction type hindering free diffusion.</p><p>These obstructions are always perfectly aligned with the main axes and centered at the origin (except for <a href="#MCMRSimulator.Mesh"><code>Mesh</code></a>). They can be moved/rotated/repeated by applying <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a>.</p><p>The dimensionality N indicates the dimensionality of the input data  (1 for <a href="#MCMRSimulator.Wall"><code>Wall</code></a>, 2 for <a href="#MCMRSimulator.Cylinder"><code>Cylinder</code></a>, 3 for <a href="#MCMRSimulator.Sphere"><code>Sphere</code></a> or <a href="#MCMRSimulator.Mesh"><code>Mesh</code></a>).</p><p>Each obstruction needs to define the following interface:</p><ul><li><a href="movement, obstruction, previous_collision"><code>detect_collision</code></a>: returns any interesection between the movement and the obstruction</li><li><a href="obstruction"><code>produces_off_resonance</code></a>, optional: whether the obstruction produces an off-resonance field (false by default). If true, the obstruction should also define:<ul><li><a href="obstruction, position, ..."><code>lorentz_off_resonance</code></a>: computes the off-resonance due to the obstruction at position</li><li><a href="obstruction"><code>total_susceptibility</code></a>: computes total susceptibility caused by this obstruction</li></ul></li><li><a href="obstruction, position"><code>isinside</code></a>: true if position is inside the obstruction</li><li><a href="obstruction"><code>BoundingBox</code></a>: returns a [<code>BoundingBox</code>] fully containing the obstruction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/base.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.BoundingBox" href="#MCMRSimulator.BoundingBox"><code>MCMRSimulator.BoundingBox</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundingBox(lower::PosVector, upper::PosVector)
BoundingBox(obstruction::Obstruction)
BoundingBox(obstructions)</code></pre><p>Creates a bounding box containing one or more <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a>. For infinitely repeated objects (using <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a>) the bounding box of the central object is returned.</p><p>Check whether particles are inside using <a href="#MCMRSimulator.isinside-Tuple{Any, Spin}"><code>isinside</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/bounding_box.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Collision" href="#MCMRSimulator.Collision"><code>MCMRSimulator.Collision</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Collision(distance, normal, properties; index=0, inside=false)</code></pre><p>A detected collision along the movement.</p><p><strong>Parameters</strong></p><ul><li><code>distance</code>: number between 0 and 1 indicating the distance of the collision from the origin (0) to the destination point (1)</li><li><code>normal</code>: normal of the obstruction at the collision site. To get correct reflection the normal should point in the direction of the incoming particle.</li><li><code>properties</code>: <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a> of the obstruction the spin collided with.</li><li><code>index</code>: Index of which triangle in <a href="#MCMRSimulator.Mesh"><code>Mesh</code></a> got hit</li><li><code>inside</code>: Whether the obstruction was hit on the inside or the outside. For a mesh triangle the outside is considered in the direction of the normal. For a wall the outside is in the positive direction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/collision.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.CollisionProperties" href="#MCMRSimulator.CollisionProperties"><code>MCMRSimulator.CollisionProperties</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CollisionProperties(MT_fraction, permeability)</code></pre><p>Object used to define the collision properties within a <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a> or a [<code>GlobalProperties</code>] object. Values of NaN are used in [<code>ObstructionProperties</code>] to indicate that the default collision parameter should be used.</p><p>These properties can be retrieved using:</p><ul><li><a href="@ref"><code>MT_fraction</code></a></li><li><a href="@ref"><code>permeability</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/properties.jl#L54-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.ConcreteShape" href="#MCMRSimulator.ConcreteShape"><code>MCMRSimulator.ConcreteShape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConcreteShape(t0, t1, max_amplitude, shape)</code></pre><p>A 1-dimensional amplitude profile extending from <code>t0</code> to <code>t1</code> with maximum amplitude of <code>max_amplitude</code>. The amplitude profile is defined by a <a href="#MCMRSimulator.Shape"><code>Shape</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/shape.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.ConcreteShape-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}" href="#MCMRSimulator.ConcreteShape-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>MCMRSimulator.ConcreteShape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ConcreteShape(times, amplitudes)</code></pre><p>Creates an amplitude profile by linearly interpolating the amplitudes between the given times. Times and amplitudes should be vectors of the same length.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/shape.jl#L142-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.ConcreteShape-Tuple{}" href="#MCMRSimulator.ConcreteShape-Tuple{}"><code>MCMRSimulator.ConcreteShape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ConcreteShape()</code></pre><p>Produces a ConcreteShape with only zero amplitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/shape.jl#L167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Cylinder" href="#MCMRSimulator.Cylinder"><code>MCMRSimulator.Cylinder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cylinder(radius; chi_I=-0.1, chi_A=-0.1, g_ratio=1)</code></pre><p>Creates a hollow cylinder with a radius of <code>radius</code> micrometer (default 1 micrometer) at the given <code>location</code> (default: origin). Generate cylinders using <a href="#MCMRSimulator.cylinders-Tuple"><code>cylinders</code></a>. See <a href="../off_resonance/#Myelinated_cylinders">Myelinated cylinders</a> for an explanation of the myelin sheath.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/cylinder.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Field" href="#MCMRSimulator.Field"><code>MCMRSimulator.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Describes the spatial distribution of the R1, R2, diffusivity, and off-resonance fields.</p><p>Construct using <a href="#MCMRSimulator.field-Tuple{}"><code>field</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/field.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.FixedXoshiro" href="#MCMRSimulator.FixedXoshiro"><code>MCMRSimulator.FixedXoshiro</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Immutable version of the Xoshiro random number generator state</p><p>Used to store the current state in the Spin object. To evolve the spin in a predictable manner set the seed using <code>copy!(spin.rng, Random.TaskLocalRNG)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Float" href="#MCMRSimulator.Float"><code>MCMRSimulator.Float</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Float type used during the simulation (default: Float64). This has to be changed in the code.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/constants.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Geometry" href="#MCMRSimulator.Geometry"><code>MCMRSimulator.Geometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Geometry(obstructions...)</code></pre><p>Represents the tissue geometry as one or more <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a> objects. Any <a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a> passed on will be converted into a <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a> before being added to the geometry.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/geometry_struct.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.GlobalProperties" href="#MCMRSimulator.GlobalProperties"><code>MCMRSimulator.GlobalProperties</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GlobalProperties(; MT_fraction=0, permeability=0, R1=0, T1=Inf, R2=0, T2=Inf, off_resonance=0)</code></pre><p>Defines a default set of collision and relaxation parameters for a simulation. These parameters can be locally overriden by <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p><p>Parameters can be accessed using their accessors:</p><ul><li><a href="@ref"><code>MT_fraction</code></a></li><li><a href="@ref"><code>permeability</code></a></li><li><a href="@ref"><code>T1</code></a></li><li><a href="@ref"><code>R1</code></a></li><li><a href="@ref"><code>T2</code></a></li><li><a href="@ref"><code>R2</code></a></li><li><a href="#MCMRSimulator.off_resonance-Tuple{Cylinder, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}"><code>off_resonance</code></a></li></ul><p>They can be set using <code>global_properites.&lt;property&gt; = &lt;value&gt;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/properties.jl#L101-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.GridShape" href="#MCMRSimulator.GridShape"><code>MCMRSimulator.GridShape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridShape(bounding_box::BoundingBox, size::SVector{3, Int})
GridShape(bounding_box::BoundingBox, size::Int)</code></pre><p>Defines a 3D grid within the <a href="#MCMRSimulator.BoundingBox"><code>BoundingBox</code></a>.  <code>size</code> sets the number of voxels along each dimension. Setting <code>size</code> to a single integer will set that number along each dimension  (except dimensions of infinite size, which are always just one voxel wide).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/grid.jl#L71-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.InstantGradient" href="#MCMRSimulator.InstantGradient"><code>MCMRSimulator.InstantGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InstantGradient(; qvec=[0, 0, 0], q_origin=0, time=0.)</code></pre><p>Infinitely short gradient pulse that encodes phase information given by <code>qvec</code> (units: number of rotations/um) and <code>q_origin</code> (units: number of rotations).</p><p>The number of time a spins at given <code>position</code> is rotated is given by <code>qvec ⋅ position + q_origin</code>.</p><p>The pulse is applied at given <code>time</code> (in milliseconds). Retrieve this time using <a href="#MCMRSimulator.get_time-Tuple{Snapshot}"><code>get_time</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/instants.jl#L85-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.InstantRFPulse" href="#MCMRSimulator.InstantRFPulse"><code>MCMRSimulator.InstantRFPulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InstantRFPulse(;time=0., flip_angle=0., phase=0.)</code></pre><p>Instantaneous radio-frequency pulse that flips the spins by <code>flip_angle</code> degrees in a plane perpendicular to an axis in the x-y plane with an angle of <code>phase</code> degrees with respect to the x-axis at given <code>time</code>. Angles are in degrees and the <code>time</code> is in milliseconds. Angles can be retrieved using <a href="#MCMRSimulator.flip_angle-Tuple{InstantRFPulse}"><code>flip_angle</code></a> and <a href="#MCMRSimulator.phase"><code>phase</code></a>. Time can be retrieved using <a href="#MCMRSimulator.get_time-Tuple{Snapshot}"><code>get_time</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/instants.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.MRGradients" href="#MCMRSimulator.MRGradients"><code>MCMRSimulator.MRGradients</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MRGradients(Gx, Gy, Gz, origin)
MRGradients(times, amplitudes; origin=[0, 0, 0])
MRGradients([(time0, amplitude0), (time1, amplitude1), ...]; origin=[0, 0, 0])
MRGradients()</code></pre><p>Defines a gradient profile with the gradients (unit: kHz/um) linearly interpolated between the given times (unit: ms). The gradients are centered on given <code>origin</code> (unit: um). They can be sampled using <code>gradient</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/gradients.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.MRIProperties" href="#MCMRSimulator.MRIProperties"><code>MCMRSimulator.MRIProperties</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MRIProperties(; R1=, R2=, T1=, T2=, off_resonance=)</code></pre><p>Object used to define the MRI relaxation properties within a <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a> or a [<code>GlobalProperties</code>] object. Either the relaxation rate (R1/R2) or the relaxation time (T1/T2) should be set (or neither).</p><p>Values of NaN are used in [<code>ObstructionProperties</code>] to indicate that the default relaxation parameter should be used.</p><p>These relaxation variables can be retrieved using:</p><ul><li><a href="@ref"><code>T1</code></a></li><li><a href="@ref"><code>R1</code></a></li><li><a href="@ref"><code>T2</code></a></li><li><a href="@ref"><code>R2</code></a></li><li><a href="#MCMRSimulator.off_resonance-Tuple{Cylinder, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}"><code>off_resonance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/properties.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Mesh" href="#MCMRSimulator.Mesh"><code>MCMRSimulator.Mesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Mesh(vertices, triangles)</code></pre><p>An <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a> formed from a triangular mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/mesh.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Microstructure" href="#MCMRSimulator.Microstructure"><code>MCMRSimulator.Microstructure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Microstructure(; off_resonance=0., R2=0., R1=0., diffusivity=0., geometry=Obstruction[])</code></pre><p>Describes the microstructure of the tissue.</p><p>This describes both the spatial distribution of the <code>R1</code> (in 1/ms), <code>R2</code> (in 1/ms), and <code>off-resonance</code> (in kHz) parameters (as <a href="#MCMRSimulator.Field"><code>Field</code></a> objects), the diffusivity (in um^2/ms) as a number, as well as the spatial <code>geometry</code> constraining the diffusion (as a sequence of <a href="#MCMRSimulator.Obstruction"><code>Obstruction</code></a> objects).</p><p>The <code>R1</code>, <code>R2</code>, and <code>off-resonance</code> parameters can be defined as one of:</p><ul><li><code>value::Number</code>: constant value across the microstructure.</li><li><code>(gradient::PosVector, value::Number)</code>: gradient across the microstructure.</li><li><code>field::Field</code>: as generated using <a href="#MCMRSimulator.field-Tuple{}"><code>field</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/microstructure.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Movement" href="#MCMRSimulator.Movement"><code>MCMRSimulator.Movement</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Intermediate object used internally to represent a movement from one position to another</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/movement.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Obstruction" href="#MCMRSimulator.Obstruction"><code>MCMRSimulator.Obstruction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of any obstruction to the free diffusion of water. Some might also generate off-resonance fields.</p><p>There are two types of obstructions:</p><ul><li><a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a> with the basic obstructions (walls, sphere, cylinders, meshes)</li><li><a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a>, which transform the base obstructions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/geometry.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.ObstructionProperties" href="#MCMRSimulator.ObstructionProperties"><code>MCMRSimulator.ObstructionProperties</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObstructionProperties(; MT_fraction=NaN, permeability=NaN, R1_inside=NaN, T1_inside=NaN, R2_inside=NaN, T2_inside=NaN, off_resonance_inside=NaN)</code></pre><p>Defines the collision and relaxation properties for an obstruction. Either the relaxation rate (R1/R2) or the relaxation time (T1/T2) should be set (or neither).</p><p>Collision parameters can be retreived using their accessors: <a href="@ref"><code>MT_fraction</code></a>, and <a href="@ref"><code>permeability</code></a>.</p><p>MRI relaxation parameters within the obstruction can be retrieved by calling their accessor on <code>obstruction_properties.inside</code>. The accessors are <a href="@ref"><code>T1</code></a>, <a href="@ref"><code>R1</code></a>, <a href="@ref"><code>T2</code></a>, <a href="@ref"><code>R2</code></a>, and <a href="#MCMRSimulator.off_resonance-Tuple{Cylinder, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}"><code>off_resonance</code></a>.</p><p>Values of NaN are used internally to indicate that the default parameters (from <a href="#MCMRSimulator.GlobalProperties"><code>GlobalProperties</code></a>) should be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/properties.jl#L69-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.PlotPlane" href="#MCMRSimulator.PlotPlane"><code>MCMRSimulator.PlotPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a finite plane in the 3D space used for plotting.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PlotPlane(normal::PosVector=[0, 0, 1], position::PosVector=[0, 0, 0]; size=10., sizex=&lt;size&gt;, sizey=&lt;size&gt;, ngrid=100)</code></pre><p>Arguments:</p><ul><li><code>normal</code>: length-3 vector with the orientation perpendicular to the plane (default to z-direction).</li><li><code>position</code>: position of plane as a length-3 vector (defaults to origin).</li><li><code>sizex</code>: size of the plane in the x-direction (before rotating to <code>normal</code>).</li><li><code>sizey</code>: size of the plane in the y-direction (before rotating to <code>normal</code>).</li><li><code>size</code>: set default value for <code>sizex</code> and <code>sizey</code>.</li><li><code>ngrid</code>: number of grid elements to split the plane up into for plotting.</li></ul><p><strong>Spin projection onto plane</strong></p><p>See <a href="#MCMRSimulator.project"><code>project</code></a> for details on how spins are projected onto the <code>PlotPlane</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/plot_plane.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.PosVector" href="#MCMRSimulator.PosVector"><code>MCMRSimulator.PosVector</code></a> — <span class="docstring-category">Type</span></header><section><div><p>General definition used for length-3 vectors. Mostly used for positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/constants.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.RFPulse" href="#MCMRSimulator.RFPulse"><code>MCMRSimulator.RFPulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RFPulse(times, amplitudes[, phases]; phase0=0., off_resonance=0)</code></pre><p>Creates a radio-frequency block between times <code>t0</code> and <code>t1</code>. At time <code>t0</code> the phase of the transverse B1 magnetic field is equal to <code>phase0</code> (given in degrees).</p><p>The amplitude and frequency modulation profile of the RF pulse are provided as functions:</p><ul><li>The amplitude represents the strength of the magnetic field in kHz the transverse plane as a function of time (between t0 and t1). This should always be positive.</li><li>The phase represents the offset from the Larmor frequency in degrees as a function of time (between t0 and t1). If not provided explicitly, the phase at time <code>t</code> is determined by the initial phase (in degrees) and the off-resonance (in kHz).</li></ul><p>The functions <a href="#MCMRSimulator.amplitude-Tuple{MCMRSimulator.RFPulse, Number}"><code>amplitude</code></a>, <a href="#MCMRSimulator.phase"><code>phase</code></a>, and <a href="#MCMRSimulator.off_resonance-Tuple{Cylinder, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}"><code>off_resonance</code></a> are used to get the value at a specific <code>t</code> or averaged between two times.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/radio_frequency.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Readout" href="#MCMRSimulator.Readout"><code>MCMRSimulator.Readout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Readout(;time=0)</code></pre><p>Readout the spins at the given <code>time</code> (in milliseconds) each TR</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/instants.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Scanner" href="#MCMRSimulator.Scanner"><code>MCMRSimulator.Scanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Scanner(;B0=3., max_gradient=Inf, max_slew_rate=Inf, units=:kHz)</code></pre><p>Properties of an MRI scanner relevant for the MR signal simulations.</p><ul><li><a href="#MCMRSimulator.B0-Tuple{Scanner}"><code>B0</code></a>: magnetic field strength (in Tesla)</li><li><a href="#MCMRSimulator.max_gradient"><code>max_gradient</code></a>: maximum gradient strength long each axis.</li><li><a href="#MCMRSimulator.max_slew_rate"><code>max_slew_rate</code></a>: maximum rate of change in the gradient strength</li></ul><p>By default <code>gradient</code> and <code>slew_rate</code> are expected to be provided in units of, respectively, kHz/um and kHz/um/ms. However, if the keyword <code>units=:Tesla</code> is set, the <code>gradient</code> and <code>slew_rate</code> can be provided in terms of respectively mT/m and </p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/scanner.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Sequence" href="#MCMRSimulator.Sequence"><code>MCMRSimulator.Sequence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sequence(;TR, gradients=nothing, pulses=nothing, B0=3., interplate_gradients=:step)</code></pre><p>An MR sequence represented by a series of pulses repeated with a given repetition time (<code>TR</code>).</p><p>Possible sequence components are:</p><ul><li><a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a>: Radio-frequency pulse with user-provided amplitude and phase profile.</li><li><a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a>: instantaneous approximation of a radio-frequency pulse flipping the spin orientations.</li><li><a href="#MCMRSimulator.InstantGradient"><code>InstantGradient</code></a>: instantaneous gradients encoding spatial patterns in the spin phase distribution.</li><li><a href="#MCMRSimulator.Readout"><code>Readout</code></a>: Store the spins at this timepoint.</li></ul><p>The previous/current/next RF pulse at a specific time is given by <a href="@ref"><code>previous_pulse</code></a>, <a href="@ref"><code>current_pulse</code></a>, or <a href="@ref"><code>next_pulse</code></a>.  All of these will return <code>nothing</code> if there is no previous/current/next pulse. The same functions exist for the previous/current/next instantaneous pulse (i.e., <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a> or <a href="#MCMRSimulator.InstantGradient"><code>InstantGradient</code></a>),      namely <a href="@ref"><code>previous_instant</code></a>, <a href="@ref"><code>current_instant</code></a>, or <a href="@ref"><code>next_instant</code></a>.  Note that all gradients/pulses repeat every <code>TR</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/sequence.jl#L6-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Shape" href="#MCMRSimulator.Shape"><code>MCMRSimulator.Shape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Shape(times, amplitudes; normalise=false)</code></pre><p>Defines a 1D <a href="#MCMRSimulator.Shape"><code>Shape</code></a> for an RF pulse or gradient profile. Times should be between 0 and 1 (inclusive). Amplitudes should start and end at 0 and range between 0 and 1 (for RF pulses) and -1 and 1 (for gradients). Errors are ranged if times/amplitudes are outside of these ranges (although normalise=true can be used to simply adjust the shape to match these constraints).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/shape.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Simulation" href="#MCMRSimulator.Simulation"><code>MCMRSimulator.Simulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Simulation(sequences, [microstructure]; R1=0., R2=0., off_resonance=0., diffusivity=0., geometry=Obstruction[], store_every=5., timestep=0.5)</code></pre><p>Defines the setup of the simulation and stores the output of the run.</p><p>Note the use of units:</p><ul><li>all positions are in micrometers</li><li>all times are in milliseconds</li><li>magnetic fields are in Tesla</li></ul><p><strong>Arguments</strong></p><ul><li><code>sequences::AbstractVector{Sequence}</code>: MR sequences to simulate. See <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a>.</li><li><code>microstructure::Microstructure</code>: Description the tissue microstructure. A <a href="#MCMRSimulator.Microstructure"><code>Microstructure</code></a> object can be obtained directly or created using the <code>R1</code>, <code>R2</code>, <code>off_resonance</code>, <code>diffusivity</code>, and <code>geometry</code> flags.</li><li><code>timestep::Real</code>: Timestep of the spin random walk through the tissue in milliseconds (default: 0.5).</li></ul><p><strong>Running the simulation</strong></p><p>To run a <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> through the simulations you can use one of the following functions:</p><ul><li><a href="#MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>evolve</code></a>: evolves the spins in the snapshot until a single given time and returns that state in a new <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a>.</li><li><a href="#MCMRSimulator.trajectory-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>trajectory</code></a>: returns full spin trajectory (recommended only for small number of spins)</li><li><a href="#MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>signal</code></a>: returns signal variation over time</li><li><a href="#MCMRSimulator.readout-Union{Tuple{N}, Tuple{Any, Simulation{N}}} where N"><code>readout</code></a>: returns the snapshots at the sequence readouts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/readout.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Snapshot" href="#MCMRSimulator.Snapshot"><code>MCMRSimulator.Snapshot</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents the positions and orientations of multiple <a href="#MCMRSimulator.Spin"><code>Spin</code></a> objects at a specific <code>time</code>.</p><p>Note that times are in milliseconds and positions in micrometer.  The equilibrium longitudinal spin (after T1 relaxation) is always 1.</p><p><strong>Useful constructors</strong></p><pre><code class="nohighlight hljs">Snapshot(positions; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)
Snapshot(nspins::Integer; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)</code></pre><p>Creates a new Snapshot at the given <code>time</code> with perfectly longitudinal spins initialised for simulating <code>nsequences</code> sequences. This initial spin locations are given by <code>positions</code> (Nx3 matrix or sequence of vectors of size 3). Alternatively the number of spins can be given in which case the spins are randomly distributed in a 1x1x1 mm box centered on the origin.</p><pre><code class="nohighlight hljs">Snapshot(snap::Snapshot{1}, nsequences)</code></pre><p>Replicates the positions and orientations for a single sequence in the input snapshot across <code>nsequences</code>.</p><p><strong>Extracting summary information</strong></p><ul><li><a href="#MCMRSimulator.longitudinal"><code>longitudinal</code></a>(snapshot) to get the <code>nsequences</code> spin magnitudes in the z-direction (equilibrium of 1) averaged over all spins</li><li><a href="#MCMRSimulator.transverse"><code>transverse</code></a>(snapshot) to get the <code>nsequences</code> spin magnitudes in the x-y-plane averaged over all spins</li><li><a href="#MCMRSimulator.phase"><code>phase</code></a>(snapshot) to get the <code>nsequences</code> spin angles in x-y plane (in degrees) averaged over all spins</li><li><a href="#MCMRSimulator.orientation"><code>orientation</code></a>(snapshot) to get a (<code>nsequences</code>x3) matrix with the spin orientations in 3D space averaged over all spins</li><li><a href="#MCMRSimulator.SpinOrientation"><code>SpinOrientation</code></a>(snapshot) to get a <code>nsequences</code> vector of [<code>SpinOrientation</code>] objects with the average spin orientation across all spins</li><li><a href="#MCMRSimulator.position-Tuple{Snapshot}"><code>position</code></a>.(snapshot) to get a the position for each spin in a vector (no averaging applied)</li></ul><p>Information for a single sequence can be extracted by calling <a href="#MCMRSimulator.get_sequence-Tuple{Spin, Any}"><code>get_sequence</code></a> first.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L184-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Sphere" href="#MCMRSimulator.Sphere"><code>MCMRSimulator.Sphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sphere([radius[, location]])</code></pre><p>Creates a hollow sphere with a radius of <code>radius</code> micrometer (default 1 micrometer) at the given <code>location</code> (default: origin). Generate spheres using <a href="#MCMRSimulator.spheres-Tuple"><code>spheres</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/sphere.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Spin" href="#MCMRSimulator.Spin"><code>MCMRSimulator.Spin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Spin particle with a position and <code>nsequences</code> spin orientations (stored as <a href="#MCMRSimulator.SpinOrientation"><code>SpinOrientation</code></a>).</p><p>A random number generator is stored in the <code>Spin</code> object as well, which will be used for evolving the spin into the future in a reproducible manner.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">Spin(;nsequences=1, position=[0, 0, 0], longitudinal=1., transverse=0., phase=0.)</code></pre><p>Creates a new spin with <code>nsequences</code> identical spin orientations (given by <code>longitudinal</code>, <code>transverse</code>, and <code>phase</code> flags). The spin will start at given position.</p><pre><code class="nohighlight hljs">Spin(reference_spin::Spin{1}, nsequences)</code></pre><p>Create a new spin with the same position as <code>reference_spin</code> with the orientation of <code>reference_spin</code> replicated <code>nsequences</code> times.</p><p><strong>Extracting spin information</strong></p><ul><li><a href="#MCMRSimulator.longitudinal"><code>longitudinal</code></a> to get the <code>nsequences</code> spin magnitudes in the z-direction (equilibrium of 1)</li><li><a href="#MCMRSimulator.transverse"><code>transverse</code></a> to get the <code>nsequences</code> spin magnitudes in the x-y-plane</li><li><a href="#MCMRSimulator.phase"><code>phase</code></a> to get the <code>nsequences</code> spin angles in x-y plane (in degrees)</li><li><a href="#MCMRSimulator.orientation"><code>orientation</code></a> to get a (<code>nsequences</code>x3) matrix with the spin orientations in 3D space</li><li><a href="#MCMRSimulator.position-Tuple{Snapshot}"><code>position</code></a> to get a length-3 vector with spin location</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L72-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.SpinOrientation" href="#MCMRSimulator.SpinOrientation"><code>MCMRSimulator.SpinOrientation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpinOrientation(longitudinal, transverse, phase)</code></pre><p>The spin orientation. Usually created as part of a <a href="#MCMRSimulator.Spin"><code>Spin</code></a> object.</p><pre><code class="nohighlight hljs">SpinOrientation(snapshot::Snapshot)</code></pre><p>Returns the average spin orientations of all <a href="#MCMRSimulator.Spin"><code>Spin</code></a> objects in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a>.</p><p>This information can be extracted using:</p><ul><li><a href="#MCMRSimulator.longitudinal"><code>longitudinal</code></a> to get the spin in the z-direction (equilibrium of 1)</li><li><a href="#MCMRSimulator.transverse"><code>transverse</code></a> to get the spin in the x-y-plane</li><li><a href="#MCMRSimulator.phase"><code>phase</code></a> to get the spin angle in x-y plane (in degrees)</li><li><a href="#MCMRSimulator.orientation"><code>orientation</code></a> to get the spin orientation as a length-3 vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L42-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Spiral" href="#MCMRSimulator.Spiral"><code>MCMRSimulator.Spiral</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Spiral(inner, outer; theta0=0., thickness=0.014)</code></pre><p>Creates a spiral starting from <code>inner</code> to <code>outer</code> radius. The distance between subsequent wraps is <code>thickness</code> micrometer. The angle of the start of the wraps is <code>theta0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/spiral.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.TransformObstruction" href="#MCMRSimulator.TransformObstruction"><code>MCMRSimulator.TransformObstruction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransformObstruction(base_type, args...; positions=nothing, repeats=0., rotation=I(3), lorentz_radius=10., kwargs...)
TransformObstruction(base; positions=nothing, repeats=0., rotation=I(3), lorentz_radius=10.)</code></pre><p>Transforms the <a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a> objects in <code>base</code> in one of several ways:</p><ul><li>Apply the shifts defined by <code>positions</code> (none applied by default).</li><li>Infinitely repeat the base obstruction every <code>repeats</code>.</li><li>Rotate the base obstructions by <code>rotation</code>.</li></ul><p>The <a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a> objects an already be initialised. If a <a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a> type is given instead it will be initialised using <code>args</code> and <code>kwargs</code> not used by <code>TransformObstruction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/transform.jl#L2-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.Wall" href="#MCMRSimulator.Wall"><code>MCMRSimulator.Wall</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Wall()</code></pre><p>Wall stretching to infinite along two dimensions. Generate walls using <a href="#MCMRSimulator.walls-Tuple{}"><code>walls</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/wall.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.B0-Tuple{Scanner}" href="#MCMRSimulator.B0-Tuple{Scanner}"><code>MCMRSimulator.B0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">B0(scanner)
B0(sequence)</code></pre><p>Returns the magnetic field strength of the scanner in Tesla.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/scanner.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.amplitude-Tuple{MCMRSimulator.RFPulse, Number}" href="#MCMRSimulator.amplitude-Tuple{MCMRSimulator.RFPulse, Number}"><code>MCMRSimulator.amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude(rf_pulse, t1[, t2])</code></pre><p>Computes the amplitude of the <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a> at time <code>t1</code> in kHz. If <code>t2</code> is also provided, the average amplitude between times <code>t1</code> and <code>t2</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/radio_frequency.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.amplitude-Tuple{MCMRSimulator.Shape, Number}" href="#MCMRSimulator.amplitude-Tuple{MCMRSimulator.Shape, Number}"><code>MCMRSimulator.amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude(shape, time)</code></pre><p>Returns the amplitude of the shape at the given time using linear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/shape.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.amplitude_derivative-Union{Tuple{N}, Tuple{MCMRSimulator.Shape{N}, Number}} where N" href="#MCMRSimulator.amplitude_derivative-Union{Tuple{N}, Tuple{MCMRSimulator.Shape{N}, Number}} where N"><code>MCMRSimulator.amplitude_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude_derivative(shape, time)</code></pre><p>Returns the derivative of the shape at the specific time. At control points the derivative is always assumed to be the one of the next block.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/shape.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.amplitude_integral-Tuple{MCMRSimulator.Shape, Number, Number}" href="#MCMRSimulator.amplitude_integral-Tuple{MCMRSimulator.Shape, Number, Number}"><code>MCMRSimulator.amplitude_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude_integral(shape, t0, t1)</code></pre><p>Integrate the amplitude from t0 to t1.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/shape.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.amplitude_integral-Union{Tuple{T}, Tuple{MCMRSimulator.Shape, T, AbstractVector{T}}} where T&lt;:Number" href="#MCMRSimulator.amplitude_integral-Union{Tuple{T}, Tuple{MCMRSimulator.Shape, T, AbstractVector{T}}} where T&lt;:Number"><code>MCMRSimulator.amplitude_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude_integral(shape, t0, times)</code></pre><p>Integrate the amplitude from t0 to all the times in <code>times</code> (all assumed to be larger than <code>t0</code> and strictly increasing).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/shape.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.amplitude_integral_step" href="#MCMRSimulator.amplitude_integral_step"><code>MCMRSimulator.amplitude_integral_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">amplitude_integral_step(shape, index, t0, t1)</code></pre><p>Integrate the amplitude from t0 to t1 assuming that both are within the single step (given by <code>index</code>). This is a helper function for <a href="#MCMRSimulator.amplitude_integral-Tuple{MCMRSimulator.Shape, Number, Number}"><code>amplitude_integral</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/shape.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.annuli-Tuple" href="#MCMRSimulator.annuli-Tuple"><code>MCMRSimulator.annuli</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">annuli(inner, outer; myelin=false, chi_I=-0.1, chi_A=-0.1, positions=[0, 0], repeats=[Inf, Inf], rotation=I(3)</code></pre><p>Creates one or more <a href="#MCMRSimulator.Annulus"><code>Annulus</code></a> with given <code>inner</code> and <code>outer</code> radii. <a href="../off_resonance/#Myelinated_annuli">Myelinated annuli</a> can be created by setting the <code>myelin</code> to true. All parameters can be either a single value or a vector of values.</p><p>The <code>positions</code>, <code>repeats</code>, and <code>rotation</code> control the annulus position and orientation and is explained in  more detail in <a href="../obstructions/#Defining-the-geometry">Defining the geometry</a>. Additional keyword arguments are available to set generic obstruction settings as described in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/annulus.jl#L39-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.apply!-Tuple{InstantRFPulse, SpinOrientation}" href="#MCMRSimulator.apply!-Tuple{InstantRFPulse, SpinOrientation}"><code>MCMRSimulator.apply!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply!(sequence_component, spin_orientation[, position])</code></pre><p>Applies given sequence component to the spin orientation. This updates the existing spin orientation. Some pulses (e.g., <a href="#MCMRSimulator.InstantGradient"><code>InstantGradient</code></a>) require positional information as well.</p><pre><code class="nohighlight hljs">apply!(sequence_components, spin)
apply!(sequence_components, snapshot)</code></pre><p>Apply all sequence components to the spin orientation in the <a href="#MCMRSimulator.Spin"><code>Spin</code></a> or to all the spins in <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a>. Sequence components (see <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a>) can be <code>nothing</code> if there is no sequence component at this time.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/instants.jl#L46-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.collided-Tuple{MCMRSimulator.BaseObstruction, MCMRSimulator.Collision}" href="#MCMRSimulator.collided-Tuple{MCMRSimulator.BaseObstruction, MCMRSimulator.Collision}"><code>MCMRSimulator.collided</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collided(o::BaseObstruction, c::Collision)</code></pre><p>Returns true if the collision <code>c</code> hit the obstruction <code>o</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/base.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}" href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>MCMRSimulator.color</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">color(orient::SpinOrientation; saturation=1.)</code></pre><p>Returns a color representing the spin orientation in the transverse (x-y) plane. Brighter colors have a larger transverse component, so that spins with no transverse component are black. The actual color encodes the spin orientation.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/plot.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.constant_pulse-Tuple{Number, Number, Number}" href="#MCMRSimulator.constant_pulse-Tuple{Number, Number, Number}"><code>MCMRSimulator.constant_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constant_pulse(t0, t1, flip_angle; phase0=0., off_resonance=0.)</code></pre><p>Creates an RF pulse with a constant amplitude resulting in given <code>flip_angle</code> (for spins at <code>off_resonance</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/radio_frequency.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.corners-Tuple{MCMRSimulator.BoundingBox{3}}" href="#MCMRSimulator.corners-Tuple{MCMRSimulator.BoundingBox{3}}"><code>MCMRSimulator.corners</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">corners(bb::BoundingBox)</code></pre><p>Returns a vector of all corners of the <a href="#MCMRSimulator.BoundingBox"><code>BoundingBox</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/bounding_box.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.correct_collisions-Tuple{MCMRSimulator.Movement, Any}" href="#MCMRSimulator.correct_collisions-Tuple{MCMRSimulator.Movement, Any}"><code>MCMRSimulator.correct_collisions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">correct_collision(movement, geometry)</code></pre><p>Splits the given movement from point A to point B into multiple steps that bounce off the given obstructions. This function assumes perfect reflection rather than the diffuse reflection used in <a href="@ref"><code>draw_step</code></a>. It is used to test the collision detection and resolution, but not actually used in the simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/diffuse.jl#L82-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.cylinders-Tuple" href="#MCMRSimulator.cylinders-Tuple"><code>MCMRSimulator.cylinders</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cylinders(radii; g_ratio=1, chi_I=-0.1, chi_A=-0.1, positions=[0, 0], repeats=[Inf, Inf], rotation=I(3)</code></pre><p>Creates one or more <a href="#MCMRSimulator.Cylinder"><code>Cylinder</code></a>s with given radius (or vector of <code>radii</code>). <a href="../off_resonance/#Myelinated_cylinders">Myelinated cylinders</a> can be created by setting the <code>g_ratio</code> to a different value that 1. All parameters can be either a single value or a vector of values. The <code>positions</code>, <code>repeats</code>, and <code>rotation</code> control the cylinder position and orientation and is explained in  more detail in <a href="../obstructions/#Defining-the-geometry">Defining the geometry</a>. Additional keyword arguments are available to set generic obstruction settings as described in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/cylinder.jl#L37-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.derive_qval_time-Tuple{Union{Nothing, Real}, Union{Nothing, Real}, Union{Nothing, Real}, Real}" href="#MCMRSimulator.derive_qval_time-Tuple{Union{Nothing, Real}, Union{Nothing, Real}, Union{Nothing, Real}, Real}"><code>MCMRSimulator.derive_qval_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">derive_qval_time(max_diffusion_time; bval=nothing, diffusion_time=nothing, qval=nothing)</code></pre><p>Derives b-value, diffusion time, and q-value from each other assuming short pulses</p><p>Returns a tuple with the q-value and diffusion time.</p><p>The strength of the diffusion weighting can be defined in 3 ways:</p><ul><li>not setting anything or only setting the diffusion time: in this case no diffusion weighting is applied (b=0).</li><li>setting only the b-value or q-value: in this case a <code>diffusion_time</code> of TE/2 is assumed.</li><li>setting two out of three of the <code>b-value</code>, <code>diffusion_time</code>, and <code>qval</code>. The last one will be calculated.</li></ul><p>If all three are defined an AssertionError is raised if they do not agree with each other.</p><p>Assumes equation of <span>$b = q^2 \Delta$</span>, where</p><ul><li><code>bval</code> is the diffusion-weighted strength (b-value) in <span>$ms/um^2$</span>.   </li><li><code>qval</code> is the gradient applied due to the diffusion-weighted gradients in the spin phase field (<span>$1/\mu m$</span>).    For a square pulse this is computed as <span>$\gamma G \delta$</span>.</li><li><code>diffusion_time</code> (<span>$\Delta$</span>) is the diffusion time defined for infinitely short pulses as the time between the diffusion-weighted gradients (in <span>$ms$</span>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/diffusion.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.detect_collision" href="#MCMRSimulator.detect_collision"><code>MCMRSimulator.detect_collision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">detect_collision(movement, geometry[, previous])</code></pre><p>Returns a <a href="#MCMRSimulator.Collision"><code>Collision</code></a> object if the given <code>movement</code> crosses any obstructions. The first collision is always returned. If no collision is detected, <code>empty_collision</code> will be returned</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/geometry_struct.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.detect_collision" href="#MCMRSimulator.detect_collision"><code>MCMRSimulator.detect_collision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">detect_collision(movement, base_obstruction, previous_collision)</code></pre><p>Returns any intersection between the <a href="#MCMRSimulator.Movement"><code>Movement</code></a> and the [<code>BaseObstruction</code>].</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/base.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.draw_step!-Tuple{Spin, Float64, Float64, MCMRSimulator.GlobalProperties}" href="#MCMRSimulator.draw_step!-Tuple{Spin, Float64, Float64, MCMRSimulator.GlobalProperties}"><code>MCMRSimulator.draw_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_step!(spin::Spin, diffusivity, timestept, default_properties, [, geometry])</code></pre><p>Updates the spin based on a random movement through the given geometry for a given <code>timestep</code>:</p><ul><li>draws the next location of the particle after <code>timestep</code> with given <code>diffusivity</code>.   If provided, this displacement will take into account the obstructions in <code>geometry</code>.</li><li>the spin orientation might be affected by collisions with the obstructions in <code>geometry</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/diffuse.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.dwi-Tuple{}" href="#MCMRSimulator.dwi-Tuple{}"><code>MCMRSimulator.dwi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dwi(; TE=80., TR=2000., bval/qval/gradient_strength, diffusion_time=TE/2, gradient_duration, readout_time=0., scanner=Scanner(B0=3.), orientation = [1., 0, 0])</code></pre><p>Creates a diffusion-weighted pulsed gradient spin echo MRI sequence</p><p>The timings of the RF pulses is set by <code>TE</code> and <code>TR</code>.  The gradient timings will also be affected by <code>gradient_duration</code>, <code>diffusion_time</code>, <code>scanner</code> (which sets the ramp time) and <code>readout_time</code>:</p><ul><li>By default the gradient durations are set to the maximum value possible within the echo time (<code>TE</code>) keeping in mind the time needed for the MR readout (<code>readout_time</code>) and the time needed to ramp to the maximum gradient strength (set by the <code>scanner</code>).</li><li>When <code>gradient_duration</code> is set to 0, the gradient pulses are assumed to be instanteneous (i.e., using <a href="#MCMRSimulator.InstantGradient"><code>InstantGradient</code></a>). The time between these instant gradients can be set using <code>diffusion_time</code> (defaults to <code>TE</code>/2).</li></ul><p>The strength of the diffusion gradients is set by one of <code>bval</code> (units: ms/um^2), <code>qval</code> (units: 1/um), or <code>gradient_strength</code> (units: kHz/um). If this strength exceeds the maximum allowed for the <code>scanner</code> an AssertionError is raised. The gradient orientation is set by <code>orientation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/diffusion.jl#L95-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.dyad_snapshot!-Tuple" href="#MCMRSimulator.dyad_snapshot!-Tuple"><code>MCMRSimulator.dyad_snapshot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)</code></pre><p>Plots the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> projected onto given <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a> as arrows.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/snapshot.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.dyad_snapshot-Tuple" href="#MCMRSimulator.dyad_snapshot-Tuple"><code>MCMRSimulator.dyad_snapshot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)</code></pre><p>Plots the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> projected onto given <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a> as arrows.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/snapshot.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.effective_pulse-Tuple{MCMRSimulator.RFPulse, Number, Number}" href="#MCMRSimulator.effective_pulse-Tuple{MCMRSimulator.RFPulse, Number, Number}"><code>MCMRSimulator.effective_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">effective_pulse(RFPulse, t0, t1)
effective_pulse(sequence, t0, t1)</code></pre><p>Represents the effect of the RF pulse between times <code>t0</code> and <code>t1</code> as an <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/radio_frequency.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.effective_pulse-Tuple{Sequence, Number, Number}" href="#MCMRSimulator.effective_pulse-Tuple{Sequence, Number, Number}"><code>MCMRSimulator.effective_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">effective_pulse(sequence, t1, t2)</code></pre><p>Returns the <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a> that has the same effect as the radio-frequency pulses (<a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a>) in the provided sequence will have between <code>t1</code> and <code>t2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/sequence.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N" href="#MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>MCMRSimulator.evolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve(snapshot, simulation[, new_time])</code></pre><p>Evolves the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> through the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> to a new time. Returns a <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> at the new time, which can be used as a basis for further simulation. By default it will simulate till the start of the next TR.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/readout.jl#L208-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.evolve_to_time!-Union{Tuple{N}, Tuple{Spin{N}, Simulation{N}, StaticArraysCore.SVector{N, Tuple{InstantRFPulse, InstantRFPulse}}, Float64, Float64}} where N" href="#MCMRSimulator.evolve_to_time!-Union{Tuple{N}, Tuple{Spin{N}, Simulation{N}, StaticArraysCore.SVector{N, Tuple{InstantRFPulse, InstantRFPulse}}, Float64, Float64}} where N"><code>MCMRSimulator.evolve_to_time!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve_to_time(spin, simulation, current_time, new_time)</code></pre><p>Evolve a single spin to the next time of interest. This takes into account both random diffusion of the spin&#39;s position and relaxation of the MR spin orientation. It is used internally when evolving <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/evolve.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.evolve_to_time-Union{Tuple{N}, Tuple{Snapshot{N}, Simulation{N}, Float64}} where N" href="#MCMRSimulator.evolve_to_time-Union{Tuple{N}, Tuple{Snapshot{N}, Simulation{N}, Float64}} where N"><code>MCMRSimulator.evolve_to_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve_to_time(snapshot, simulation, new_time)</code></pre><p>Evolves the full <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> through the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> to the given <code>new_time</code>. Multi-threading is used to evolve multiple spins in parallel. This is used internally when calling any of the snapshot evolution methods (e.g., <a href="#MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>evolve</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/evolve.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.expand" href="#MCMRSimulator.expand"><code>MCMRSimulator.expand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expand(bb::BoundingBox, ratio=1.)</code></pre><p>Expand or shrink the <a href="#MCMRSimulator.BoundingBox"><code>BoundingBox</code></a> so that it grows/shrinks by <code>ratio</code> along each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/bounding_box.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.field-Tuple{}" href="#MCMRSimulator.field-Tuple{}"><code>MCMRSimulator.field</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a <a href="#MCMRSimulator.Field"><code>Field</code></a> object to describe the spatial distribution of some parameter (e.g., R1, R2, off-resonance, diffusivity)</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">field()</code></pre><p>Sets the parameter to zero everywhere.</p><pre><code class="nohighlight hljs">field(value::real)</code></pre><p>Sets the parameter to a constant value everywhere.</p><pre><code class="nohighlight hljs">field(gradient::PosVector, value::real)</code></pre><p>Parameter is described by a spatial gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/field.jl#L28-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.fit_time-Tuple{}" href="#MCMRSimulator.fit_time-Tuple{}"><code>MCMRSimulator.fit_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit_time(gradient_duration, diffusion_time, ramp_time, readout_time, TE)</code></pre><p>Arranges the timing of gradients given the duration of gradient, diffusion time, ramp time, readout time and TE. By default it will try to arrange to gradients symmetrically arround the 180 degree pulse. If not feasible, it will make readout right after the rephasing gradient and calculate the dephasing gradient&#39;s timing based on the rephasing gradient.</p><p>This function is not supposed to be called individually! So no check for the arguments will happen, assuming all have been checked by dwi<em>gradients</em>1D and all will not be nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/diffusion.jl#L218-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.flip_angle-Tuple{InstantRFPulse}" href="#MCMRSimulator.flip_angle-Tuple{InstantRFPulse}"><code>MCMRSimulator.flip_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flip_angle(instant_pulse)</code></pre><p>Returns the flip angle of the <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a> in degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/instants.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.get_sequence-Tuple{Spin, Any}" href="#MCMRSimulator.get_sequence-Tuple{Spin, Any}"><code>MCMRSimulator.get_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_sequence(spin, sequence_index)
get_sequence(snapshot, sequence_index)</code></pre><p>Extracts the spin orientation corresponding to a specific sequence, where the sequence index uses the order in which the sequences where provided in the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.get_time-Tuple{Snapshot}" href="#MCMRSimulator.get_time-Tuple{Snapshot}"><code>MCMRSimulator.get_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_time(snapshot)
get_time(sequence_component)
get_time(sequence, sequence_index)</code></pre><p>Returns the time in milliseconds that a snapshot was taken or that a sequence component will have effect.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L227-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.gradient-Tuple{AbstractVector, Sequence, Number}" href="#MCMRSimulator.gradient-Tuple{AbstractVector, Sequence, Number}"><code>MCMRSimulator.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient([position, ], sequence, t1[, t2])</code></pre><p>Gets the off-resonance field (units: kHz) at given <code>position</code> at time <code>t1</code> (or integrated between times <code>t1</code> and <code>t2</code>). If position is not supplied the MR gradient is returned as a <a href="#MCMRSimulator.PosVector"><code>PosVector</code></a> (units: kHz/um).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/sequence.jl#L126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.gradient-Tuple{MRGradients, Number}" href="#MCMRSimulator.gradient-Tuple{MRGradients, Number}"><code>MCMRSimulator.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient([position, ]sequence/grad, time)
gradient([position, ]sequence/grad, t1, t2)</code></pre><p>Get gradient strength generated by <code>grad</code> (<a href="#MCMRSimulator.MRGradients"><code>MRGradients</code></a> object) at a specific <code>time</code> or averaged over a period between <code>t1</code> and <code>t2</code>. If no position is provided, the gradient is returned as a length-3 vector in units of mT/m. If a position is provided, the gradient is returned at that position as a float quantifying the off-resonance field in units of microTesla.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/gradients.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.image_snapshot!-Tuple" href="#MCMRSimulator.image_snapshot!-Tuple"><code>MCMRSimulator.image_snapshot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">image_snapshot(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)
image_snapshot!(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)</code></pre><p>Plots the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> projected onto given <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>. The average spin orientation across the plot plane is plotted using the colour coding from <a href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>color</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/snapshot.jl#L60-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.image_snapshot-Tuple" href="#MCMRSimulator.image_snapshot-Tuple"><code>MCMRSimulator.image_snapshot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">image_snapshot(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)
image_snapshot!(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)</code></pre><p>Plots the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> projected onto given <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>. The average spin orientation across the plot plane is plotted using the colour coding from <a href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>color</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/snapshot.jl#L60-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.isinside-Tuple{Any, Spin}" href="#MCMRSimulator.isinside-Tuple{Any, Spin}"><code>MCMRSimulator.isinside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinside(obstruction/geometry/bounding_box, position)
isinside(obstructions/geometry/bounding_box, spin)
isinside(obstructions/geometry/bounding_box, snapshot)</code></pre><p>Test whether the particles are inside a <a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a>, <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a>, <a href="#MCMRSimulator.Geometry"><code>Geometry</code></a> or <a href="#MCMRSimulator.BoundingBox"><code>BoundingBox</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/base.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.load_mesh-Tuple{IO}" href="#MCMRSimulator.load_mesh-Tuple{IO}"><code>MCMRSimulator.load_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_mesh(file)</code></pre><p>Loads a <a href="#MCMRSimulator.Mesh"><code>Mesh</code></a> from a file.</p><p>Currently only PLY files are supported (see <a href="#MCMRSimulator.ply_from_mesh-Tuple{Any}"><code>ply_from_mesh</code></a>)</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/mesh.jl#L253-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.longitudinal" href="#MCMRSimulator.longitudinal"><code>MCMRSimulator.longitudinal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transverse(spin)
transverse(snapshot)</code></pre><p>Returns the longitudinal magnitude of the spin (i.e., magnitude aligned with the magnetic field) for a single particle (<a href="#MCMRSimulator.Spin"><code>Spin</code></a>) or averaged across a group of particles in a [<code>Snapshot</code>]. When orientations for multiple sequences are available an array of longitudinal values is returned with a value for each sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.lorentz_off_resonance" href="#MCMRSimulator.lorentz_off_resonance"><code>MCMRSimulator.lorentz_off_resonance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lorentz_off_resonance(base_obstruction, position, b0_field, repeat_dist, radius, nrepeats)</code></pre><p>Computes the off-resonance field produced by the obstruction (<a href="#MCMRSimulator.BaseObstruction"><code>BaseObstruction</code></a>) at the given <code>position</code> given the <code>b0_field</code>. The field generated by any repeats of the base obstruction within a distance of <code>radius</code> will also be considered (presuming the obstruction repeats every <code>repeat_dist</code>). This maximum number of repeats that need to be considered is precomputed as <code>nrepeats</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/base.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.max_gradient" href="#MCMRSimulator.max_gradient"><code>MCMRSimulator.max_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">max_gradient(scanner[, units])</code></pre><p>Returns the maximum magnetic field gradient of the scanner in kHz/um. By setting <code>units</code> to :Tesla, the gradient strength can be returned in mT/m instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/scanner.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.max_slew_rate" href="#MCMRSimulator.max_slew_rate"><code>MCMRSimulator.max_slew_rate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">max_slew_rate(scanner[, units])</code></pre><p>Returns the maximum magnetic field slew rate of the scanner in kHz/um/ms. By setting <code>units</code> to :Tesla, the slew rate can be returned in T/m/s instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/scanner.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.mesh_grid_intersection-Tuple{MCMRSimulator.GridShape, Vector{StaticArraysCore.SVector{3, Float64}}, Vector{StaticArraysCore.SVector{3, Int64}}}" href="#MCMRSimulator.mesh_grid_intersection-Tuple{MCMRSimulator.GridShape, Vector{StaticArraysCore.SVector{3, Float64}}, Vector{StaticArraysCore.SVector{3, Int64}}}"><code>MCMRSimulator.mesh_grid_intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mesh_grid_intersection(shape, vertices, triangles)</code></pre><p>Determines for each voxel in the grid with which triangles it intersects.</p><p><strong>Algorithm</strong></p><p>We follow the algorithm proposed by https://fileadmin.cs.lth.se/cs/Personal/Tomas<em>Akenine-Moller/code/tribox</em>tam.pdf, which is based on the separating axis theorem.</p><p>We project each voxel in the grid and each triangle on a series of 9 axes:</p><ul><li>the normals of the cube ([1, 0, 0], [0, 1, 0], [0, 0, 1])</li><li>the normal of the triangle</li><li>the cross products of any edge of the cube (same as normals) and the edges of the triangle (total of 9 tests)</li></ul><p>If the cube and triangle do not overlap along any of these axes, they are non-overlapping. If they overlap along all axes, the triangle and cube overlap</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/mesh.jl#L82-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.norm_angle-Tuple{Any}" href="#MCMRSimulator.norm_angle-Tuple{Any}"><code>MCMRSimulator.norm_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm_angle(angle)</code></pre><p>Normalises an angle in degrees, so that it is between it is in the range (-180, 180]</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.normal-Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}" href="#MCMRSimulator.normal-Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}"><code>MCMRSimulator.normal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal(p1, p2, p3)</code></pre><p>Computes the normal of a triangle formed by the three points</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/mesh.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.off_resonance-Tuple{Cylinder, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}" href="#MCMRSimulator.off_resonance-Tuple{Cylinder, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}"><code>MCMRSimulator.off_resonance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">off_resonance(cylinder, position, b0_field)</code></pre><p>Computed by the hollow cylinder fiber model from <a href="../references/#Wharton_2012">Samuel Wharton, Richard Bowtell (2012)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/cylinder.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.off_resonance-Tuple{MCMRSimulator.RFPulse, Number}" href="#MCMRSimulator.off_resonance-Tuple{MCMRSimulator.RFPulse, Number}"><code>MCMRSimulator.off_resonance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">off_resonance(rf_pulse, t1[, t2])</code></pre><p>Computes the off<em>resonance of the <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a> at time <code>t1</code> in kHz. If <code>t2</code> is also provided, the average off</em>resonance between times <code>t1</code> and <code>t2</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/radio_frequency.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.orientation" href="#MCMRSimulator.orientation"><code>MCMRSimulator.orientation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orientation(spin)
orientation(snapshot)</code></pre><p>Returns the spin orientation as a length-3 vector for a single particle (<a href="#MCMRSimulator.Spin"><code>Spin</code></a>) or averaged across a group of particles in a [<code>Snapshot</code>]. When orientations for multiple sequences are available an array of vectors is returned with a value for each sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L144-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.perfect_dwi-Tuple{}" href="#MCMRSimulator.perfect_dwi-Tuple{}"><code>MCMRSimulator.perfect_dwi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perfect_dwi(; TE=80., TR=2000., bval=nothing, diffusion_time=nothing, qval=nothing, orientation = [0, 0, 1.])</code></pre><p>Creates a standard diffusion-weighted MRI sequence</p><p>This produces a pulsed gradient spin echo (PGSE) sequence with perfect RF pulses  and infinitely short diffusion-weighted gradients.</p><p>The procedure for defining the diffusion-weighted gradient strength is defined by <a href="#MCMRSimulator.derive_qval_time-Tuple{Union{Nothing, Real}, Union{Nothing, Real}, Union{Nothing, Real}, Real}"><code>derive_qval_time</code></a>. The <code>orientation</code> parameter only sets the gradient orientation, not the strength.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/diffusion.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.phase" href="#MCMRSimulator.phase"><code>MCMRSimulator.phase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase(spin)
phase(snapshot)</code></pre><p>Returns the phase in the x-y plane of the spin for a single particle (<a href="#MCMRSimulator.Spin"><code>Spin</code></a>) or averaged across a group of particles in a [<code>Snapshot</code>]. When orientations for multiple sequences are available  an array of phase values is returned with a value for each sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L135-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.phase-Tuple{InstantRFPulse}" href="#MCMRSimulator.phase-Tuple{InstantRFPulse}"><code>MCMRSimulator.phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phase(instant_pulse)</code></pre><p>Returns the angle in the x-y plane of the axis around with the <a href="#MCMRSimulator.InstantRFPulse"><code>InstantRFPulse</code></a> rotates in degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/instants.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.phase-Tuple{MCMRSimulator.RFPulse, Number}" href="#MCMRSimulator.phase-Tuple{MCMRSimulator.RFPulse, Number}"><code>MCMRSimulator.phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phase(rf_pulse, t1[, t2])</code></pre><p>Computes the phase of the <a href="#MCMRSimulator.RFPulse"><code>RFPulse</code></a> at time <code>t1</code> in degrees. If <code>t2</code> is also provided, the average phase between times <code>t1</code> and <code>t2</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/radio_frequency.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_geometry!-Tuple" href="#MCMRSimulator.plot_geometry!-Tuple"><code>MCMRSimulator.plot_geometry!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(plot_plane, geometry)
plot!(plot_plane, geometry)
plot_geometry(plot_plane, geometry)
plot_geometry!(plot_plane, geometry)</code></pre><p>Plots the intersections of <code>geometry</code> in the <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/geometry.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_geometry-Tuple" href="#MCMRSimulator.plot_geometry-Tuple"><code>MCMRSimulator.plot_geometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(plot_plane, geometry)
plot!(plot_plane, geometry)
plot_geometry(plot_plane, geometry)
plot_geometry!(plot_plane, geometry)</code></pre><p>Plots the intersections of <code>geometry</code> in the <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/geometry.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_off_resonance!-Tuple" href="#MCMRSimulator.plot_off_resonance!-Tuple"><code>MCMRSimulator.plot_off_resonance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_off_resonance(plot_plane, geometry)
plot_off_resonance(plot_plane, geometry)</code></pre><p>Plots the off-resonance of <code>geometry</code> in the <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/off_resonance.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_off_resonance-Tuple" href="#MCMRSimulator.plot_off_resonance-Tuple"><code>MCMRSimulator.plot_off_resonance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_off_resonance(plot_plane, geometry)
plot_off_resonance(plot_plane, geometry)</code></pre><p>Plots the off-resonance of <code>geometry</code> in the <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/off_resonance.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_snapshot" href="#MCMRSimulator.plot_snapshot"><code>MCMRSimulator.plot_snapshot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot(plot_plane, snapshot; kwargs...)
plot!(plot_plane, snapshot; kwargs...)
plot_snapshot(plot_plane, snapshot; kwargs...)
plot_snapshot!(plot_plane, snapshot; kwargs...)</code></pre><p>Plots the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> projected onto given <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>. Each spin is represented by an arrow showing the transverse component of the spin (for a total of the first <code>ndyads</code> spins). The average spin orientation across the plot plane is plotted using the colour coding from <a href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>color</code></a>.</p><p>This combines the plotting from <a href="#MCMRSimulator.image_snapshot-Tuple"><code>image_snapshot</code></a> and <a href="#MCMRSimulator.dyad_snapshot-Tuple"><code>dyad_snapshot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/snapshot.jl#L97-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_trajectory2d!-Tuple" href="#MCMRSimulator.plot_trajectory2d!-Tuple"><code>MCMRSimulator.plot_trajectory2d!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(snapshots)
plot!(snapshots)
plot_trajectory3d(snapshots)
plot_trajectory3d!(snapshots)</code></pre><p>Plots trajectory of the spins in a sequence of <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/trajectory.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_trajectory2d-Tuple" href="#MCMRSimulator.plot_trajectory2d-Tuple"><code>MCMRSimulator.plot_trajectory2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(snapshots)
plot!(snapshots)
plot_trajectory3d(snapshots)
plot_trajectory3d!(snapshots)</code></pre><p>Plots trajectory of the spins in a sequence of <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/trajectory.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_trajectory3d!-Tuple" href="#MCMRSimulator.plot_trajectory3d!-Tuple"><code>MCMRSimulator.plot_trajectory3d!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(snapshots)
plot!(snapshots)
plot_trajectory3d(snapshots)
plot_trajectory3d!(snapshots)</code></pre><p>Plots trajectory of the spins in a sequence of <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/trajectory.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.plot_trajectory3d-Tuple" href="#MCMRSimulator.plot_trajectory3d-Tuple"><code>MCMRSimulator.plot_trajectory3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(snapshots)
plot!(snapshots)
plot_trajectory3d(snapshots)
plot_trajectory3d!(snapshots)</code></pre><p>Plots trajectory of the spins in a sequence of <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/trajectory.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.ply_from_mesh-Tuple{Any}" href="#MCMRSimulator.ply_from_mesh-Tuple{Any}"><code>MCMRSimulator.ply_from_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ply_from_mesh(file)</code></pre><p>Loads a <a href="#MCMRSimulator.Mesh"><code>Mesh</code></a> from a PLY file. PLY stands for Polygon File Format (http://paulbourke.net/dataformats/ply/). PLY IO is handled by PlyIO.jl (https://github.com/JuliaGeometry/PlyIO.jl).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/mesh.jl#L234-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.position-Tuple{Snapshot}" href="#MCMRSimulator.position-Tuple{Snapshot}"><code>MCMRSimulator.position</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">position.(s::Snapshot)</code></pre><p>Returns all the positions of the spin particles as a vector of length-3 vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.position-Tuple{Spin}" href="#MCMRSimulator.position-Tuple{Spin}"><code>MCMRSimulator.position</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">position(s::Spin)</code></pre><p>Returns the position of the spin particle as a vector of length 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.produces_off_resonance-Tuple{MCMRSimulator.BaseObstruction}" href="#MCMRSimulator.produces_off_resonance-Tuple{MCMRSimulator.BaseObstruction}"><code>MCMRSimulator.produces_off_resonance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">produces_off_resonance(base_obstruction)</code></pre><p>Whether the obstruction produces an off-resonance field. The field will be computed using [<code>lorentz_off_resonance</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/base.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.produces_off_resonance-Tuple{MCMRSimulator.Geometry}" href="#MCMRSimulator.produces_off_resonance-Tuple{MCMRSimulator.Geometry}"><code>MCMRSimulator.produces_off_resonance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">produces_off_resonance(geometry)</code></pre><p>Whether any obstruction produces an off-resonance field. The field will be computed using [<code>off_resonance</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/geometry_struct.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.project" href="#MCMRSimulator.project"><code>MCMRSimulator.project</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">project(position, transform::TransformObstruction)</code></pre><p>Computes the position in the space of the obstructions wrapped by the <a href="#MCMRSimulator.TransformObstruction"><code>TransformObstruction</code></a>.</p><pre><code class="nohighlight hljs">project(position, grid::GridShape)</code></pre><p>Computes the voxel index for the position on the <a href="#MCMRSimulator.GridShape"><code>GridShape</code></a>.  This will return a result even if the point is outside of the grid. Use <a href="#MCMRSimulator.isinside-Tuple{Any, Spin}"><code>isinside</code></a>(position, grid) to check that.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/geometry.jl#L20-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.project-Tuple{PlotPlane, StaticArraysCore.SVector{3, Float64}}" href="#MCMRSimulator.project-Tuple{PlotPlane, StaticArraysCore.SVector{3, Float64}}"><code>MCMRSimulator.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(plot_plane, position)
project(plot_plane, snapshot)</code></pre><p>Transforms the <code>position</code> (length-3 vector) or <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> to a space, where the <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a> lies in the x-y-plane centered on origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/plot_plane.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.project_geometry-Union{Tuple{N}, Tuple{PlotPlane, TransformObstruction{N, M, K, O} where {M, K, O&lt;:MCMRSimulator.BaseObstruction{N}}}} where N" href="#MCMRSimulator.project_geometry-Union{Tuple{N}, Tuple{PlotPlane, TransformObstruction{N, M, K, O} where {M, K, O&lt;:MCMRSimulator.BaseObstruction{N}}}} where N"><code>MCMRSimulator.project_geometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project_geometry(plot_plane, transform)</code></pre><p>Projects the plane on the intrinsic plane of the obstructions deformed by <code>transform</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/geometry.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.project_on_grid-Tuple{PlotPlane, Snapshot{1}, Int64}" href="#MCMRSimulator.project_on_grid-Tuple{PlotPlane, Snapshot{1}, Int64}"><code>MCMRSimulator.project_on_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project_on_grid(plot_plane, snap, ngrid)</code></pre><p>Spins from the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> are projected onto the grid defined by <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a> in two ways:</p><ul><li>along the normal spins are projected onto the plane from infinitely far (TODO: give finite extent)</li><li>in the other directions any spins are projected onto the plane using mod(position[1], <code>sizex</code>) and mod(position[2], <code>sizey</code>).   This assumes that the geometry and field repeats itself ad infinitum beyond the <code>PlotPlane</code> (TODO: allow this assumption to be turned off).</li></ul><p>In effect, this means that all spins are projected onto the <code>PlotPlane</code>. The average spin orientation in each grid cell is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/plot_plane.jl#L115-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.propose_times-Tuple{MCMRSimulator.TimeController, Number, Number, AbstractVector{&lt;:Sequence}, Number}" href="#MCMRSimulator.propose_times-Tuple{MCMRSimulator.TimeController, Number, Number, AbstractVector{&lt;:Sequence}, Number}"><code>MCMRSimulator.propose_times</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propose_times(simulation::Simulation, t_start, t_end)
propose_times(time_controller::TimeController, t_start, t_end, sequences, diffusivity)</code></pre><p>Computes the timepoints at which the simulation will be evaluated when running from <code>t_start</code> to <code>t_end</code>.</p><p>The following timepoints will always be included</p><ul><li>Any multiple of the TR</li><li>Any RF pulse</li><li>Any change in the gradient strength</li></ul><p>Additional timepoints will be added to ensure that:</p><ul><li>at any time the timestep is larger than <code>time_controller.gradient_precision</code> times <span>$D^{-1/3} (G \gamma)^{-2/3}$</span>.</li><li>between <code>t_start</code> and <code>t_end</code> there are at least <code>time_controller.sample_displacement</code> timepoints.</li><li>between any control point of the sequence gradient there are at least <code>time_controller.sample_displacement</code> timepoints.</li><li>between an RF pulse and a subsequent RF pulse or t<em>end there are at least `time</em>controller.sample<em>off</em>resonance` timepoints.</li><li>During an RF block the rotation around the maximum magnetic field will be at most <code>time_controller.rf_rotation</code> radians. For a specific <a href="@ref"><code>RFBlock</code></a> these timepoints can be found using <code>propose_times(rf_block, rf_rotation, B0)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/timestep.jl#L20-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_annuli-Tuple{Any}" href="#MCMRSimulator.random_annuli-Tuple{Any}"><code>MCMRSimulator.random_annuli</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_annuli(target_density; repeats, g_ratio=0.8, distribution=Distributions.Gamma, mean_radius=1., variance_radius=0.5, max_iter=1000, myelin=false, chi_I=-0.1, chi_A=-0.1, rotation=I(3))</code></pre><p>Generate infinitely repeating box with non-overlapping annuli.</p><p>A rectangle with the size of <code>repeats</code> will be filled with annuli for a total surface density of <code>target_density</code>. The annulus outer radii will be drawn from the selected <code>distribution</code> (if not set, a Gamma distribution is used with given <code>mean_radius</code> and <code>var_radius</code>). An error is raised if no solution for non-overlapping annuli is found. The inner radius with respect to the outer radius is set by the <code>g-ratio</code>. Other annuli parameters (besides <code>inner</code>, <code>outer</code>, <code>positions</code>, and <code>repeats</code>) are identical as in <code>mr.annuli</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/annulus.jl#L116-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_cylinders-Tuple{Any}" href="#MCMRSimulator.random_cylinders-Tuple{Any}"><code>MCMRSimulator.random_cylinders</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_cylinders(target_density; repeats, distribution=Distributions.Gamma, mean_radius=1., variance_radius=0.5, max_iter=1000, g_ratio=1., chi_I=-0.1, chi_A=-0.1, rotation=I(3))</code></pre><p>Generate infinitely repeating box with non-overlapping cylinders.</p><p>A rectangle with the size of <code>repeats</code> will be filled with cylinders for a total surface density of <code>target_density</code>. The cylinder radii will be drawn from the selected <code>distribution</code> (if not set, a Gamma distribution is used with given <code>mean_radius</code> and <code>var_radius</code>). An error is raised if no solution for non-overlapping cylinders is found. Other cylinder parameters (besides <code>radii</code>, <code>shifts</code>, and <code>repeats</code>) are identical as in <code>mr.cylinders</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/cylinder.jl#L110-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_gauss-Tuple{Float64, Float64}" href="#MCMRSimulator.random_gauss-Tuple{Float64, Float64}"><code>MCMRSimulator.random_gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_gauss(diffusivity, timestep)</code></pre><p>Draws a random step from a Gaussian distribution with a variance of 2 * diffusivity * timestep.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/diffuse.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_on_sphere-Tuple{}" href="#MCMRSimulator.random_on_sphere-Tuple{}"><code>MCMRSimulator.random_on_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_on_sphere()</code></pre><p>Draws a random orientation on the unit sphere as a length-3 vector</p><p>The z-orientation is drawn a random number between -1 and 1. The angle in the x-y plane is drawn as a random number between 0 and 2π. This results in an unbiased random distribution across the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/diffuse.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_positions_radii-Tuple{Any, Real, Int64}" href="#MCMRSimulator.random_positions_radii-Tuple{Any, Real, Int64}"><code>MCMRSimulator.random_positions_radii</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_positions_radii(box_size, target_density, n_dimensions; distribution=Gamma, mean=1., variance=1., max_iter=1000)</code></pre><p>Randomly distributes circles or spheres in space.</p><p>Arguments:</p><ul><li><code>box_size</code>: Size of the infinitely repeating box of random positions</li><li><code>target_density</code>: Final density of the circles/spheres. This density will only be approximately reached</li><li><code>n_dimensions</code>: dimensionality of the space (2 for cicles; 3 for spheres)</li><li><code>distribution</code>: distribution from which the radii are drawn (from <a href="https://juliastats.org/Distributions.jl/stable/">Distributions.jl</a>)</li><li><code>mean</code>: mean of the gamma distribution (ignored if <code>distribution</code> explicitly set)</li><li><code>variance</code>: variance of the gamma distribution (ignored if <code>distribution</code> explicitly set)</li><li><code>max_iter</code>: maximum number of iterations to try to prevent the circles/spheres from overlapping. An error is raised if they still overlap after this number of iterations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/random_draws.jl#L56-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_spheres-Tuple{Any}" href="#MCMRSimulator.random_spheres-Tuple{Any}"><code>MCMRSimulator.random_spheres</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_spheres(target_density; repeats, distribution=Distributions.Gamma, mean_radius=1., variance_radius=0.5, max_iter=1000, rotation=I(3))</code></pre><p>Generate infinitely repeating box with non-overlapping spheres.</p><p>A box with the size of <code>repeats</code> will be filled with spheres for a total volume density of <code>target_density</code>. The sphere radii will be drawn from the selected <code>distribution</code> (if not set, a Gamma distribution is used with given <code>mean_radius</code> and <code>var_radius</code>). An error is raised if no solution for non-overlapping spheres is found. Other sphere parameters (besides <code>radii</code>, <code>positions</code>, and <code>repeats</code>) are identical as in <code>mr.spheres</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/sphere.jl#L79-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.random_spirals-Tuple{Any}" href="#MCMRSimulator.random_spirals-Tuple{Any}"><code>MCMRSimulator.random_spirals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_spirals(target_density; repeats, g_ratio=0.8, distribution=Distributions.Gamma, mean_radius=1., variance_radius=0.5, max_iter=1000, rotation=I(3))</code></pre><p>Generate infinitely repeating box with non-overlapping spirals.</p><p>A rectangle with the size of <code>repeats</code> will be filled with spirals for a total surface density of <code>target_density</code>. The spiral outer radii will be drawn from the selected <code>distribution</code> (if not set, a Gamma distribution is used with given <code>mean_radius</code> and <code>var_radius</code>). An error is raised if no solution for non-overlapping annuli is found. The inner radius with respect to the outer radius is set by the <code>g-ratio</code>. Other spiral parameters (besides <code>inner</code>, <code>outer</code>, <code>positions</code>, and <code>repeats</code>) are identical as in <code>mr.spirals</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/spiral.jl#L285-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.ray_grid_intersections-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Float64}, StaticArraysCore.SVector{N, Float64}}} where N" href="#MCMRSimulator.ray_grid_intersections-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Float64}, StaticArraysCore.SVector{N, Float64}}} where N"><code>MCMRSimulator.ray_grid_intersections</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ray_grid_intersections([grid, ]origin, destination)</code></pre><p>Computes all voxels crossed by a ray between <code>origin</code> and <code>destination</code> with a <a href="#MCMRSimulator.GridShape"><code>GridShape</code></a> (default infinitely extending 1x1x1 grid). Both origin and destination are length-3 vectors. The returned object is an iterator returning a tuple with:</p><ul><li>3-length vector with the voxel that we are crossing through</li><li>Float with the time the ray entered voxel (0=<code>origin</code>, 1=<code>destination</code>)</li><li>3-length vector with position within voxel that the ray entered (i.e., numbers between 0 and 1)</li><li>Float with the time the ray left the voxel (0=<code>origin</code>, 1=<code>destination</code>)</li><li>3-length vector with position within voxel that the ray left (i.e., numbers between 0 and 1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/grid.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.readout-Union{Tuple{N}, Tuple{Any, Simulation{N}}} where N" href="#MCMRSimulator.readout-Union{Tuple{N}, Tuple{Any, Simulation{N}}} where N"><code>MCMRSimulator.readout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readout(snapshot, simulation)</code></pre><p>Evolves the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> through the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a>. Returns the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> at every <a href="#MCMRSimulator.Readout"><code>Readout</code></a> in the simulated sequences during a single TR. If no <code>TR</code> is explicitly selected, it will return the current TR if the snapshot has not passed any readouts and the next TR otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/readout.jl#L107-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.relax!" href="#MCMRSimulator.relax!"><code>MCMRSimulator.relax!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">relax!(spin_orientation, timestep, mri, additional_off_resonance=0)</code></pre><p>Updates [<code>SpinOrientation</code>] after evolving for <code>timestep</code> with given <code>R1(mri)</code> (1/ms), <code>R2(mri)</code> (1/ms), and <code>off_resonance(mri) + additional_off_resonance</code> (kHz).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/relax.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.rotate_bvec-Tuple{AbstractVector{&lt;:Tuple{Real, Real}}, Any}" href="#MCMRSimulator.rotate_bvec-Tuple{AbstractVector{&lt;:Tuple{Real, Real}}, Any}"><code>MCMRSimulator.rotate_bvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_bvec(gradients, bvec)</code></pre><p>Rotates the gradients in <code>gradients</code> to align with <code>bvec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/sequence/gradients.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.scatter_snapshot!-Tuple" href="#MCMRSimulator.scatter_snapshot!-Tuple"><code>MCMRSimulator.scatter_snapshot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(snapshot)
plot!(snapshot)
scatter_snapshot(snapshot)
scatter_snapshot!(snapshot)</code></pre><p>Plots the spin positions in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> in 3D color coded by the spin&#39;s orientation (see <a href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>color</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/snapshot.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.scatter_snapshot-Tuple" href="#MCMRSimulator.scatter_snapshot-Tuple"><code>MCMRSimulator.scatter_snapshot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(snapshot)
plot!(snapshot)
scatter_snapshot(snapshot)
scatter_snapshot!(snapshot)</code></pre><p>Plots the spin positions in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> in 3D color coded by the spin&#39;s orientation (see <a href="#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}"><code>color</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/snapshot.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.sequence_plot" href="#MCMRSimulator.sequence_plot"><code>MCMRSimulator.sequence_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot(sequence)
plot!(sequence)
plot_sequence(sequence)
plot_sequence!(sequence)</code></pre><p>Creates a visual representation of a <a href="#MCMRSimulator.Sequence"><code>Sequence</code></a> diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/sequence.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N" href="#MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>MCMRSimulator.signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signal(snapshot, simulation, times=[TR])</code></pre><p>Evolves the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> through the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> and outputs the total signal at the requested times. To get the full snapshot at each timepoint use <a href="#MCMRSimulator.trajectory-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>trajectory</code></a>. Returns a vector of <a href="#MCMRSimulator.SpinOrientation"><code>SpinOrientation</code></a> object with the total signal at each time in <code>times</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/readout.jl#L174-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.spheres-Tuple" href="#MCMRSimulator.spheres-Tuple"><code>MCMRSimulator.spheres</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spheres(radii; positions=[[0, 0, 0]], repeats=[Inf, Inf, Inf], rotation=I(3))</code></pre><p>Creates one or more <a href="#MCMRSimulator.Sphere"><code>Sphere</code></a>s with given radius (or vector of <code>radii</code>). The <code>positions</code>, <code>repeats</code>, and <code>rotation</code> control the sphere positions and is explained in  more detail in <a href="../obstructions/#Defining-the-geometry">Defining the geometry</a>. Additional keyword arguments are available to set generic obstruction settings as described in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/sphere.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.spiral_theta-Tuple{Spiral, StaticArraysCore.SVector{2, Float64}}" href="#MCMRSimulator.spiral_theta-Tuple{Spiral, StaticArraysCore.SVector{2, Float64}}"><code>MCMRSimulator.spiral_theta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spiral_theta(spiral, position; assume_inner)</code></pre><p>Computes the location of the particle within the spiral. This function returns 0 if the particle has just entered the inner part of the spiral. Each wrap further outwards will add 2π to the result.</p><p>When the particle is at the spiral edge, <code>assume_inner</code> should be set to true if the particle should be considered just on the inner side of the surface or to false if it should be considered just on the outer surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/spiral.jl#L32-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.spirals-Tuple" href="#MCMRSimulator.spirals-Tuple"><code>MCMRSimulator.spirals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spirals(inner, outer; theta0=0., thickness=0.014, myelin=false, chi_I=-0.1, chi_A=-0.1, positions=[0, 0], repeats=[Inf, Inf], rotation=I(3)</code></pre><p>Creates one or more <a href="#MCMRSimulator.Spiral"><code>Spiral</code></a>. Spirals range from <code>inner</code> to <code>outer</code> radii starting at an angle of <code>theta0</code>. Each wrap has a thickness of <code>thickness</code> micrometers. Inner/outer cylinders can be added using respectively the <code>inner_cylinder</code> and <code>outer_cylinder</code> flags (default: only inner cylinder).</p><p><a href="../off_resonance/#Myelinated_annuli">Myelinated spirals</a> can be created by setting the <code>myelin</code> to true. All parameters can be either a single value or a vector of values.</p><p>The <code>positions</code>, <code>repeats</code>, and <code>rotation</code> control the annulus position and orientation and is explained in  more detail in <a href="../obstructions/#Defining-the-geometry">Defining the geometry</a>. Additional keyword arguments are available to set generic obstruction settings as described in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/spiral.jl#L57-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.total_susceptibility-Tuple{MCMRSimulator.BaseObstruction}" href="#MCMRSimulator.total_susceptibility-Tuple{MCMRSimulator.BaseObstruction}"><code>MCMRSimulator.total_susceptibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">total_susceptibility(obstruction)</code></pre><p>Computes total surface (for 2D) or volume (for 3D) susceptibility of a base obstruction.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/base.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.trajectory-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N" href="#MCMRSimulator.trajectory-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>MCMRSimulator.trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trajectory(snapshot, simulation, times=[TR])</code></pre><p>Evolves the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> through the <a href="#MCMRSimulator.Simulation"><code>Simulation</code></a> and outputs at the requested times. Returns a vector of <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> objects with the current state of each time in times. When you are only interested in the signal at each timepoint, use <a href="#MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>signal</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/readout.jl#L148-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.transfer!-Tuple{SpinOrientation, Float64}" href="#MCMRSimulator.transfer!-Tuple{SpinOrientation, Float64}"><code>MCMRSimulator.transfer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transfer!(orientation, MT_fraction)</code></pre><p>Loses <code>MT_fraction</code> spin from <code>orientation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/relax.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.transverse" href="#MCMRSimulator.transverse"><code>MCMRSimulator.transverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transverse(spin)
transverse(snapshot)</code></pre><p>Returns the transverse spin (i.e., magnitude in the plane perpendicular to the magnetic field) for a single particle (<a href="#MCMRSimulator.Spin"><code>Spin</code></a>) or averaged across a group of particles in a [<code>Snapshot</code>]. When orientations for multiple sequences are available an array of transverse values is returned with a value for each sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/spin.jl#L126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCMRSimulator.walls-Tuple{}" href="#MCMRSimulator.walls-Tuple{}"><code>MCMRSimulator.walls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">walls(positions=0, repeats=Inf, rotation=I(3))</code></pre><p>Creates one or more <a href="#MCMRSimulator.Wall"><code>Wall</code></a>s. The <code>positions</code>, <code>repeats</code>, and <code>rotation</code> control the wall position and orientation and is explained in  more detail in <a href="../obstructions/#Defining-the-geometry">Defining the geometry</a>. Additional keyword arguments are available to set generic obstruction settings as described in <a href="#MCMRSimulator.ObstructionProperties"><code>ObstructionProperties</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/geometry/base/wall.jl#L15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MakieCore.plot!-Tuple{MakieCore.Combined{MCMRSimulator.dyad_snapshot}}" href="#MakieCore.plot!-Tuple{MakieCore.Combined{MCMRSimulator.dyad_snapshot}}"><code>MakieCore.plot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)
dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)</code></pre><p>Plots the spins in the <a href="#MCMRSimulator.Snapshot"><code>Snapshot</code></a> projected onto given <a href="#MCMRSimulator.PlotPlane"><code>PlotPlane</code></a>. Each spin is represented by an arrow showing the transverse component of the spin.</p></div><a class="docs-sourcelink" target="_blank" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/0cadb40ae5ac9b9a43796b6dd9739a85fb32d426/src/plot/snapshot.jl#L39-L45">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../off_resonance/">« Magnetic susceptibility</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 3 February 2023 19:08">Friday 3 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
