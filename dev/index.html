<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MCMRSimulator.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MCMRSimulator.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Movie-of-spins-moving-through-cylinders"><span>Movie of spins moving through cylinders</span></a></li><li class="toplevel"><a class="tocitem" href="#installation"><span>Installation</span></a></li><li class="toplevel"><a class="tocitem" href="#Tutorial"><span>Tutorial</span></a></li><li><a class="tocitem" href="#Defining-the-simulation"><span>Defining the simulation</span></a></li><li><a class="tocitem" href="#Initialising-the-simulation"><span>Initialising the simulation</span></a></li><li><a class="tocitem" href="#Running-the-simulation"><span>Running the simulation</span></a></li></ul></li><li><a class="tocitem" href="obstructions/">Geometry</a></li><li><a class="tocitem" href="sequence/">Sequence</a></li><li><a class="tocitem" href="off_resonance/">Magnetic susceptibility</a></li><li><a class="tocitem" href="api/">API</a></li><li><a class="tocitem" href="references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/blob/main/docs/src/index.md#" title="Edit source"><span class="docs-icon fa"></span><span class="docs-label is-hidden-touch">Edit source</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p><a href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl">MCMRSimulator.jl</a> allows simulation of MR signal generation using Monte Carlo simulations. The spin evolution of randomly diffusing particles is tracked under influence of one or more MR sequences. At present, the simulator allows to model</p><ul><li>Free diffusion and diffusion restricted by walls, cylinders, spirals (experimental, spheres, or meshes</li><li>T1 and T2 relaxation using global T1/T2 parameters</li><li>MR sequences consisting of RF pulses, gradients, and readouts</li><li>Off-resonance field generation by myelinated cylinders</li><li>Magnetisation transfer between liquid spins and membranes in both a simplified way (i.e., spins relax when hitting an obstruction) or a more realistic way (spins get exchanged into the obstruction).</li><li>Membrane permeability (i.e., exchange)</li><li>Surface tension of membranes causing spins to get temporarily &quot;stuck&quot; when they hit a membrane</li></ul><p>Future (potential) features:</p><ul><li>Off-resonance field generated by myelinated meshes</li><li>Off-resonance field by iron particles</li><li>Contribution from metabolites (i.e., spectroscopy)</li></ul><div class="admonition is-warning"><header class="admonition-header">beta</header><div class="admonition-body"><p>This MR simulator is still under very active development and the API might still change substantially at any time!</p></div></div><p>We use the following units throughout (unless otherwise noted):</p><ul><li>Times are in ms. Equivalently, RF pulse amplitudes and off-resonance fields are in kHz (i.e., 1/ms).</li><li>Positions are in um. So, gradients are in kHz/um (not mT/m).</li><li>Angles are in degrees (not radians). These are used for phases (of spins and RF pulses) as well as RF pulse flip angles. </li><li>Susceptibilities are in ppm.</li></ul><h2 id="Movie-of-spins-moving-through-cylinders"><a class="docs-heading-anchor" href="#Movie-of-spins-moving-through-cylinders">Movie of spins moving through cylinders</a><a id="Movie-of-spins-moving-through-cylinders-1"></a><a class="docs-heading-anchor-permalink" href="#Movie-of-spins-moving-through-cylinders" title="Permalink"></a></h2><iframe src="https://ox.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=b6211751-2743-4bb8-b65a-af5d011a8684&autoplay=true&offerviewer=false&showtitle=false&showbrand=false&captions=false&interactivity=none" style="border: 1px solid #464646;" allowfullscreen allow="autoplay"></iframe><h1 id="installation"><a class="docs-heading-anchor" href="#installation">Installation</a><a id="installation-1"></a><a class="docs-heading-anchor-permalink" href="#installation" title="Permalink"></a></h1><ol><li>First install julia (e.g., from the <a href="https://julialang.org/downloads/">official website</a> or using <a href="https://github.com/JuliaLang/juliaup">juliaup</a>).</li><li>Start julia in the terminal (<code>$ julia</code>).</li><li>Enter the package manager by pressing &quot;]&quot;<ul><li>Install MCMRSimulator.jl (<code>pkg&gt; add https://git.fmrib.ox.ac.uk/ndcn0236/mcmrsimulator.jl.git</code>)</li><li>Install one of the <a href="https://makie.juliaplots.org/stable/documentation/backends/">Makie backends</a> for plotting (e.g., <code>pkg&gt; add CairoMakie</code>)</li><li>Press &quot;[backspace]&quot; to leave the package manager</li></ul></li></ol><p>After this installation, you should be able to follow the steps in the tutorial below or create your own simulations.</p><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This tutorial will walk through an example of modelling the MRI signal evolution for a diffusion-weighted sequence. The spins in this simulation will be constrained by regularly packed cylinders. After <a href="#installation">installation</a> we can load MCMRSimulator.jl using</p><pre><code class="language-julia hljs">using MCMRSimulator
using CairoMakie  # used for plotting; use GLMakie or WGLMakie for interactive plots</code></pre><p>In general, running a simulation will consist of the following three steps:</p><ul><li>Defining the microstructure and on or more sequences by creating an appropriate <a href="api/#MCMRSimulator.Simulation"><code>Simulation</code></a> object.</li><li>Initialising one or more <a href="api/#MCMRSimulator.Spin"><code>Spin</code></a> objects.</li><li>Simulating a random walk of the spins through the microstructure and the MR signal produced by those spins.</li><li>Plotting the MR signal or storing it to disk.</li></ul><p>We will look through each of these steps below.</p><h2 id="Defining-the-simulation"><a class="docs-heading-anchor" href="#Defining-the-simulation">Defining the simulation</a><a id="Defining-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-simulation" title="Permalink"></a></h2><p>The first step is to define the environment through which the spins will evolve. We will do so by creating an appropriate <a href="api/#MCMRSimulator.Simulation"><code>Simulation</code></a> object. This <code>Simulation</code> will contain information on the microstructure, the MR physics, and the enabled sequences.</p><p>These different steps are described in more detail in other sections of this documentation:</p><ul><li><a href="obstructions/#geometry">How to define the microstrutural geometry</a></li><li><a href="off_resonance/#off_resonance">Generate off-resonance fields due to the microstructural geometry</a></li><li><a href="sequence/#sequence">Sequence generation</a></li></ul><p>First we will define the geometry formed of regularly packed axons. This is represented by a single cylinder with a radius of 1 micrometer that repeats itself every 2.5 micrometer (in both the x-, and y-direction).</p><pre><code class="language-julia hljs">geometry = cylinders(1., repeats=[2.5, 2.5])

f = plot(PlotPlane(size=5), geometry)</code></pre><p><img src="tutorial_geometry.png" alt/> More complicated geometries can be generated as described <a href="obstructions/#geometry">here</a> including geometries with magnetic susceptibility that produce off-resonance fields (see <a href="off_resonance/#off_resonance">here</a>).</p><p>The next step is to define a sequence.  Here we will adopt a single diffusion-weighted MRI sequence.</p><pre><code class="language-julia hljs">sequence = dwi(bval=2., TR=300, TE=80, scanner=Siemens_Prisma)  # default gradient orientation in the x-direction
f = plot(sequence)</code></pre><p><img src="tutorial_sequence.png" alt/></p><p>Once we have both a geometry and one or more sequences, we can put them together in a <a href="api/#MCMRSimulator.Simulation"><code>Simulation</code></a> object (click on this object for more details on the many options available when setting up a simulation):</p><pre><code class="language-julia hljs">simulation = Simulation(sequence, R2=0.012, R1=3e-3, diffusivity=2., off_resonance=0.1, geometry=geometry)</code></pre><p>Note that we actually have to set the <code>R2</code>, <code>R1</code>, and <code>diffusivity</code> to non-zero values to enable those pieces of physics.</p><h2 id="Initialising-the-simulation"><a class="docs-heading-anchor" href="#Initialising-the-simulation">Initialising the simulation</a><a id="Initialising-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Initialising-the-simulation" title="Permalink"></a></h2><p>We can initialise the simulation in one of three ways:</p><ul><li>An integer value indicating the number of spins to be simulated. The spins will be randomly distributed through a 1mm x 1mm x 1mm voxel and start with a longitudinal magnetisation in equilibrium.</li><li>A sequence of positions (i.e., length-3 vectors) with the initial spin positions.</li><li>A <a href="api/#MCMRSimulator.Snapshot"><code>Snapshot</code></a> (i.e., collection of spins with a timestamp) from a previous simulation.</li></ul><p>We will see examples of all three below.</p><p>Each <code>Spin</code> represents a single diffusing particle. Besides containing its current position, it also contains its contribution to the MR signal for each of the sequences in the simulation.</p><p>At each timepoint the current state of the spins is represented by a <a href="api/#MCMRSimulator.Snapshot"><code>Snapshot</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Deterministic spins</header><div class="admonition-body"><p>Each <a href="api/#MCMRSimulator.Spin"><code>Spin</code></a> is assigned a random number state at creation, which will be used for its future evolution. This means that after creation of a spin or a <a href="api/#MCMRSimulator.Snapshot"><code>Snapshot</code></a> its future is fully determined. This ensures that when a spin is evolved through the same simulation multiple times, it sill follow the same path each time. This allows improved comparisons between simulations with the same geometry, but different sequences/physics. However, it can lead to confusing results (e.g., a simulation initialised with <code>fill(Spin(), 500)</code> will contain 500 spins all following the exact same path).</p></div></div><h2 id="Running-the-simulation"><a class="docs-heading-anchor" href="#Running-the-simulation">Running the simulation</a><a id="Running-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-simulation" title="Permalink"></a></h2><p>Running the simulation is done through 4 functions, for which examples are shown below:</p><ul><li><a href="api/#MCMRSimulator.trajectory-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N"><code>trajectory</code></a>: follow the full state evolution for a small number of spins</li><li><a href="api/#MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>evolve</code></a>: evolve a large number of spins for a specific time</li><li><a href="api/#MCMRSimulator.readout-Union{Tuple{N}, Tuple{Any, Simulation{N}}} where N"><code>readout</code></a>: return the spin states at the time of the sequence readouts</li><li><a href="api/#MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N"><code>signal</code></a>: return the average signal at high temporal resolution</li></ul><h3 id="Illustrating-trajectories"><a class="docs-heading-anchor" href="#Illustrating-trajectories">Illustrating trajectories</a><a id="Illustrating-trajectories-1"></a><a class="docs-heading-anchor-permalink" href="#Illustrating-trajectories" title="Permalink"></a></h3><p>We will start by illustrating the 2D trajectory for two spins, one inside and one outside of the cylinder. To plot the trajectory we first need to output the state of the all spins at a high temporal resolution, which can be done using <code>trajectory</code>:</p><pre><code class="language-julia hljs"># Simulate 2 spins with given starting positions for 3 ms
snapshots = trajectory([[0, 0, 0], [1, 1, 0]], simulation, 0:0.01:3.)

pp = PlotPlane(size=5.)
f = plot(pp, geometry)
plot_trajectory2d!(pp, snapshots)</code></pre><p><img src="tutorial_trajectory2D.png" alt/> In this plot the color at each timepoint encodes the spin orientation. The brightness of the spin indicates the size of the transverse component with purely longitudinal spins being in black. The color of the spin encodes the phase of the MR signal in the transverse plane.</p><p>The trajectories can also be plotted in 3D:</p><pre><code class="language-julia hljs">f = plot_trajectory3d(snapshots)</code></pre><p><img src="tutorial_trajectory3D.png" alt/></p><p>When simulating a large number of spins, storing the spin state every timestep would become very memory-intensive. To get around this we will typically either store the average signal at a high temporal resolution or the full state at a low resolution. Let&#39;s have a look of examples for both.</p><h3 id="Signal-evolution"><a class="docs-heading-anchor" href="#Signal-evolution">Signal evolution</a><a id="Signal-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-evolution" title="Permalink"></a></h3><p>To store the total signal evolution we can use <a href="api/#MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}, Any}} where N"><code>signal</code></a>. At each timepoint this will return the total MR signal (for each sequence) as a <a href="api/#MCMRSimulator.SpinOrientation"><code>SpinOrientation</code></a> object. From this one can estimate the <a href="api/#MCMRSimulator.transverse"><code>transverse</code></a> component, the <a href="api/#MCMRSimulator.longitudinal"><code>longitudinal</code></a> component, and the <a href="api/#MCMRSimulator.phase"><code>phase</code></a>. Here we plot the transverse component of the signal evolution as an example</p><pre><code class="language-julia hljs">times = 0:0.1:sequence.TR
average_signals = signal(3000, simulation, times)  # simulate 3000 spins for a single repetition time
f = plot(sequence)
lines!(times, transverse.(average_signals)/3000.)</code></pre><p><img src="tutorial_transverse.png" alt/></p><h3 id="Readout-at-specific-times"><a class="docs-heading-anchor" href="#Readout-at-specific-times">Readout at specific times</a><a id="Readout-at-specific-times-1"></a><a class="docs-heading-anchor-permalink" href="#Readout-at-specific-times" title="Permalink"></a></h3><p>We can return a <a href="api/#MCMRSimulator.Snapshot"><code>Snapshot</code></a> at any time simply by running:</p><pre><code class="language-julia hljs">snapshot = evolve(3000, simulation, 80.)
pp = PlotPlane(size=2.5)
f = plot(pp, snapshot)
plot!(pp, geometry)</code></pre><p><img src="tutorial_snapshot.png" alt/> The color encoding is the same as for the trajectory plot above. The brightness encodes the size of the transverse component, while the color encodes the phase of the MR signal in the transverse plane. We can see that outside of the cylinder the signal contribution is significantly reduced. The black arrows show the transverse spin for some random spins.</p><p>The snapshot returned by <a href="api/#MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N"><code>evolve</code></a> can be used as a starting point for further simulations. We can use this to plot the longitudinal signal at the first and third TR using:</p><pre><code class="language-julia hljs">first_TR_start = Snapshot(1000)
fifth_TR_start = evolve(first_TR_start, simulation, sequence.TR * 2)

f = plot(sequence)

times = 0:0.1:100.
for start in (first_TR_start, fifth_TR_start)
    simulated_signals = signal(start, simulation, times .+ start.time)
    lines!(times, longitudinal.(simulated_signals)/3000., cycle=[:color])
end</code></pre><p><img src="tutorial_longitudinal.png" alt/></p><p>Sequences will usually contain one or more <a href="api/#MCMRSimulator.Readout"><code>Readout</code></a> objects to mark the readout times. To get the <a href="api/#MCMRSimulator.Snapshot"><code>Snapshot</code></a> at these readouts during one repetition time, you can use <a href="api/#MCMRSimulator.readout-Union{Tuple{N}, Tuple{Any, Simulation{N}}} where N"><code>readout</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="obstructions/">Geometry »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 22 March 2023 16:18">Wednesday 22 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
