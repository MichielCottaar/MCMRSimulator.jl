var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Callaghan, R.; Alexander, D. C.; Palombo, M. and Zhang, H. (2020). Config: Contextual Fibre Growth to Generate Realistic Axonal Packing for Diffusion Mri Simulation. NeuroImage 220, 117107.\n\n\n\nGinsburger, K.; Matuschke, F.; Poupon, F.; Mangin, J.-F. c.; Axer, M. and Poupon, C. (2019). MEDUSA: A GPU-based Tool to Create Realistic Phantoms of the Brain Microstructure Using Tiny Spheres. Neuroimage 193, 10–24.\n\n\n\nPalombo, M.; Alexander, D. C. and Zhang, H. (2019). A Generative Model of Realistic Brain Cells with Application to Numerical Simulation of the Diffusion-Weighted MR Signal. NeuroImage 188, 391–402. Accessed on Nov 16, 2022.\n\n\n\nVillarreal-Haro, J. L.; Gardier, R.; Canales-Rodríguez, E. J.; Fischi-Gomez, E.; Girard, G.; Thiran, J.-P. and Rafael-Patiño, J. (2023). CACTUS: A Computational Framework for Generating Realistic White Matter Microstructure Substrates. Frontiers in Neuroinformatics 17. Accessed on Aug 22, 2023.\n\n\n\n","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = MCMRSimulator","category":"page"},{"location":"api/#api","page":"API","title":"MCMRSimulator.jl public API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This is the public API for MCMRSimulator. For a more user-friendly introduction, click here.","category":"page"},{"location":"api/#Running-simulations","page":"API","title":"Running simulations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Simulation\nreadout\nevolve\nSubset\nSnapshot\nBoundingBox\nSpin\nMCMRSimulator.get_subset\nMCMRSimulator.SpinOrientation\nMCMRSimulator.SpinOrientationSum\nMCMRSimulator.TimeStep","category":"page"},{"location":"api/#MCMRSimulator.Simulations.Simulation","page":"API","title":"MCMRSimulator.Simulations.Simulation","text":"Simulation(\n    sequences; geometry=[], diffusivity=3.,\n    R1=0, T1=Inf, R2=0, T2=Inf, off_resonance=0, MT_fraction=0, permeability=0,, \n    timestep=<default parameters>,\n)\n\nDefines the setup of the simulation and stores the output of the run.\n\nArgument\n\nGeneral parameters:\n\nsequences: Vector of MRIBuilder.Sequence objects. During the spin random walk the simulation will keep track of the spin magnetisations for all of the provided sequences.\ngeometry: Set of obstructions, which can be used to restrict the diffusion, produce off-resonance fields, alter the local T1/T2 relaxation, and as sources of magnetisation transfer.\ndiffusivity: Rate of the random motion of the spins in um^2/ms (default: 3).\nverbose: set to false to silence descriptions of the simulation parameters (default: true).\n\nMRI properties\n\nThese parameters determine the evolution and relaxation of the spin magnetisation.\n\nR1/T1: sets the longitudinal relaxation rate (R1 in kHz) or relaxation time (T1=1/R1 in ms). This determines how fast the longitudinal magnetisation returns to its equilibrium value of 1.\nR2/T2: sets the transverse relaxation rate (R2 in kHz) or relaxation time (T2=1/R2 in ms). This determines how fast the transverse magnetisation is lost.\noff_resonance: Size of the off-resonance field in this voxel in kHz.\n\nThese MRI properties can be overriden for spins inside the ObstructionGroup objects of the geometry.\n\nCollision parameters\n\nThese parameters determine how parameters behave when hitting the ObstructionGroup objects of the geometry. They can be overriden for individual objects for each ObstructionGroup.\n\nMT_fraction: the fraction of magnetisation transfered between the obstruction and the water spin at each collision.\npermeability: the rate of spins passing through the surface in arbitrary units (set to infinity for fully permeable surface).\nsurface_density: Density of spins stuck on the surface relative to the volume density of hte free water.\ndwell_time: Typical time that spins will stay at the surface after getting stuck.\n\nNote that MT_fraction and permeability are internally adjusted to make their effect independent of the timestep.\n\nTimestep parameters\n\ntimestep controls the timepoints at which the simulation is evaluated.  By default, the maximum allowable timestep will be determined by the geometry and biophysical parameters as described in MCMRSimulator.TimeStep. That documentation also describes how to adjust these settings. The timestep can also be set to a number to ignore any of these parameters. Note that a too large timestep will lead to inaccurate results.\n\nRunning the simulation\n\nTo run a Snapshot of spins through the simulations you can use one of the following functions:\n\nevolve: evolves the spins in the snapshot until a single given time and returns that state in a new Snapshot.\nreadout: evolves the spins to particular times in each TR and return the total signal at that time (or a Snapshot).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Evolve.readout","page":"API","title":"MCMRSimulator.Evolve.readout","text":"readout(spins, simulation[, readout_times]; bounding_box=<1x1x1 mm box>, skip_TR=0, nTR=1, return_snapshot=false, subset=<all>)\n\nEvolves a set of spins through the Simulation. Returns the total signal or a full Snapshot at every readout time in the simulated sequences over one or more repetition times (TRs).\n\nPositional arguments:\n\nspins: Number of spins to simulate or an already existing Snapshot.\nsimulation: Simulation object defining the environment, scanner, and sequence(s).\ntimes (optional): time of the readouts relative to the start of the TR (in ms). If not provided, the times of any MRIBuilder.ADC objects in the sequence will be used (see get_readouts for details).\n\nKeyword arguments:\n\nbounding_box: size of the voxel in which the spins are initiated in um (default is 1000, corresponding to a 1x1x1 mm box centered on zero). Can be set to a BoundingBox object for more control.\nskip_TR: Number of repetition times to skip before starting the readout.    Even if set to zero (the default), the simulator will still skip the current TR before starting the readout    if the starting snapshot is from a time past one of the sequence readouts.   See get_readouts for details.\nnTR: number of TRs for which to store the output. See get_readouts for details.\nreturn_snapshot: set to true to output the state of all the spins as a Snapshot at each readout instead of a SpinOrientationSum with the total signal.\nsubset: Return the signal/snapshot for a subset of all spins. Can be set to a single or a vector of Subset objects. If set to a vector, this will add an attional dimension to the output.\n\nReturns\n\nThe function returns an up to 3-dimensional (KxLxMxN) array, with the following dimensions:\n\nK: the number of sequences. This dimension is not included if the simulation only contains a single sequencen (and this single sequence is not passed into the Simulation as a vector).\nL: the number of readout times with a single TR. This dimension is skipped if the readout_times is set to a scalar number. This dimension might contain nothings for sequences that contain fewer Readout.ADC objects than the maximum (M).\nM: the number of TRs (controlled by the nTR keyword). If nTR is not explicitly set by the user, this dimension is skipped.\nN: the number of subsets (controlled by the subset keyword). If subset is set to a single value (<all> by default), this dimension is skipped.\n\nBy default each element of this matrix is either a SpinOrientationSum with the total signal. If return_snapshot=true is set, each element is the full Snapshot instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Evolve.evolve","page":"API","title":"MCMRSimulator.Evolve.evolve","text":"evolve(snapshot, simulation[, new_time]; bounding_box=<1x1x1 mm box>)\n\nEvolves the Snapshot through the Simulation to a new time. Returns a Snapshot at the new time, which can be used as a basis for further simulation.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Subsets.Subset","page":"API","title":"MCMRSimulator.Subsets.Subset","text":"Subset(; bound=nothing, inside=nothing, geometry_index=nothing, obstruction_index=nothing)\n\nThis creates a helper object to extract a subset of a Snapshot from the total snapshot. It defines which spins should be kept. This definition is determined by:\n\nbound: set to true to return only bound spins, to false to return only free spins (default: whether spins are bound is not relevant).\ninside: set to true to return only spins inside the geometry, to false to return only spins outside of the geometry (default: whether spins are inside or outside is not relevant). It can also be set to a positive integer number. Only spins that are inside that exact number of obstructions will be returned.\ngeometry_index: set to an index to only consider that obstruction group within the total geometry (default: consider the full geometry).\nobstruction_index: set to an index to only consider that obstruction group within the total geometry (default: consider the full geometry).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Spins.Snapshot","page":"API","title":"MCMRSimulator.Spins.Snapshot","text":"Represents the positions and orientations of multiple Spin objects at a specific time.\n\nNote that times are in milliseconds and positions in micrometer.  The equilibrium longitudinal spin (after T1 relaxation) is always 1.\n\nUseful constructors\n\nSnapshot(positions; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)\nSnapshot(nspins[, bounding_box[, geometry]]; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)\nSnapshot(nspins, simulation[, bounding_box; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)\n\nCreates a new Snapshot at the given time with spins initialised for simulating nsequences sequences. All spins will start out in equilibrium, but that can be changed using the longitudinal, transverse, and/or phase flags. This initial spin locations are given by positions (Nx3 matrix or sequence of vectors of size 3). Alternatively the number of spins can be given in which case the spins are randomly distributed in the given bounding_box (default: 1x1x1 mm box centered on origin). The bounding_box can be a BoundingBox object, a tuple with the lower and upper bounds (i.e., two vectors of length 3) or a number r (resulting in spins filling a cube from -r to +r)\n\nSnapshot(snap::Snapshot{1}, nsequences)\n\nReplicates the positions and orientations for a single sequence in the input snapshot across nsequences.\n\nExtracting summary information\n\nlongitudinal(snapshot) to get the nsequences spin magnitudes in the z-direction (equilibrium of 1) averaged over all spins\ntransverse(snapshot) to get the nsequences spin magnitudes in the x-y-plane averaged over all spins\nphase(snapshot) to get the nsequences spin angles in x-y plane (in degrees) averaged over all spins\norientation(snapshot) to get a (nsequencesx3) matrix with the spin orientations in 3D space averaged over all spins\nSpinOrientation(snapshot) to get a nsequences vector of [SpinOrientation] objects with the average spin orientation across all spins\nposition.(snapshot) to get a the position for each spin in a vector (no averaging applied)\n\nInformation for a single sequence can be extracted by calling get_sequence first.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.BoundingBoxes.BoundingBox","page":"API","title":"MCMRSimulator.Geometries.Internal.BoundingBoxes.BoundingBox","text":"BoundingBox(lower::Vector, upper::Vector)\nBoundingBox([center::Vector, ]radius::Number)\n\nRepresents a box in N-dimensional space.\n\nCheck whether particles are inside using isinside.\n\nThis can be used to define where spins should be generated in a Snapshot (see readout).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Spins.Spin","page":"API","title":"MCMRSimulator.Spins.Spin","text":"Spin particle with a position and nsequences spin orientations (stored as SpinOrientation).\n\nA random number generator is stored in the Spin object as well, which will be used for evolving the spin into the future in a reproducible manner.\n\nConstructors\n\nSpin(;nsequences=1, position=[0, 0, 0], longitudinal=1., transverse=0., phase=0.)\n\nCreates a new spin with nsequences identical spin orientations (given by longitudinal, transverse, and phase flags). The spin will start at given position.\n\nSpin(reference_spin::Spin{1}, nsequences)\n\nCreate a new spin with the same position as reference_spin with the orientation of reference_spin replicated nsequences times.\n\nExtracting spin information\n\nlongitudinal to get the nsequences spin magnitudes in the z-direction (equilibrium of 1)\ntransverse to get the nsequences spin magnitudes in the x-y-plane\nphase to get the nsequences spin angles in x-y plane (in degrees)\norientation to get a (nsequencesx3) matrix with the spin orientations in 3D space\nposition to get a length-3 vector with spin location\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Subsets.get_subset","page":"API","title":"MCMRSimulator.Subsets.get_subset","text":"get_subset(snapshot, simulation, subset)\nget_subset(snapshot, simulation; bound=nothing, inside=nothing, geometry_index=nothing, obstruction_index=nothing)\n\nReturns a subset of the Snapshot from the Simulation that obey some specific properties. These properties can be either defined by a Subset object or a set of keyword arguments.\n\nThese keyword arguments are:\n\nbound: set to true to return only bound spins, to false to return only free spins (default: whether spins are bound is not relevant).\ninside: set to true to return only spins inside the geometry, to false to return only spins outside of the geometry (default: whether spins are inside or outside is not relevant). It can also be set to a positive integer number. Only spins that are inside that exact number of obstructions will be returned.\ngeometry_index: set to an index to only consider that obstruction group within the total geometry (default: consider the full geometry).\nobstruction_index: set to an index to only consider that obstruction group within the total geometry (default: consider the full geometry).\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Spins.SpinOrientation","page":"API","title":"MCMRSimulator.Spins.SpinOrientation","text":"SpinOrientation(longitudinal, transverse, phase)\n\nThe spin orientation. Usually created as part of a Spin object.\n\nSpinOrientation(snapshot::Snapshot)\n\nReturns the average spin orientations of all Spin objects in the Snapshot.\n\nThis information can be extracted using:\n\nlongitudinal to get the spin in the z-direction (equilibrium of 1)\ntransverse to get the spin in the x-y-plane\nphase to get the spin angle in x-y plane (in degrees)\norientation to get the spin orientation as a length-3 vector\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Spins.SpinOrientationSum","page":"API","title":"MCMRSimulator.Spins.SpinOrientationSum","text":"SpinOrientationSum(snapshot)\n\nComputes the total signal and the number of spins in a Snapshot. The number of spins can be found by running length(spin_orientation_sum). The spin orientation information can be found in the same way as for SpinOrientation, namely by calling transverse, longitudinal, or phase.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.TimeSteps.TimeStep","page":"API","title":"MCMRSimulator.TimeSteps.TimeStep","text":"Simulation(timestep=(tortuosity=3e-2, gradient=1e-4, permeability=0.5, surface_relaxation=0.01, transfer_rate=0.01, dwell_time=0.1))\n\nCreates an object controlling the timestep of the MCMR simulation.\n\nIt can be set by supplying a named tuple to the timestep keyword when creating a Simulation.\n\nAt any time the timestep is guaranteed to be shorter than:\n\ntortuosity * size_scale(geometry)^2 / D, where size_scale is the average size of the obstructions and D is the diffusivity.\ntimestep greater than permeability times 1 / (maximum permeability parameter)^2\ntimestep that would allow surface relaxation rate at single collision to be greater than surface_relaxation.\ntimestep that would allow magnetisation transfer rate at single collision to be greater than transfer_rate.\nthe minimum dwell time of the bound pool times dwell_time.\n(gradient /( D * \\gamma^2 * G^2))^(1//3), where \\gamma is the gyromagnetic_ratio and G is the current gradient_strength.\n\n\n\n\n\n","category":"type"},{"location":"api/#Creating-geometry","page":"API","title":"Creating geometry","text":"","category":"section"},{"location":"api/#Geometry-types","page":"API","title":"Geometry types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Annuli\nMCMRSimulator.Annulus\nCylinders\nMCMRSimulator.Cylinder\nWalls\nMCMRSimulator.Wall\nSpheres\nMCMRSimulator.Sphere\nMesh\nMCMRSimulator.Triangle\nBendyCylinder\nMCMRSimulator.Ring","category":"page"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Annuli","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Annuli","text":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup{:Annuli})(; fields...)\n\nCreates a set of MCMRSimulator.Annulus objects. Fields can be set using keyword arguments. The following fields are available:\n\ninner: Radius of the inner cylinder. Field is required. Expected type: Float64.\nouter: Radius of the outer cylinder. Field is required. Expected type: Float64.\nmyelin: Whether the annulus is myelinated. Field is required. Expected type: Bool.  default value: false\nrotation: Rotation applied to all obstructions in group. Can be set to a matrix or one of :x, :y, or, :z (see MCMRSimulator.get_rotation). Field is required. Expected type: StaticArraysCore.SMatrix{3, 2, Float64, 6}.  default value: [1.0 0.0; 0.0 1.0; 0.0 0.0]\nR1_inner_surface: Additional longitudinal relaxation rate (kHz). Inner_surface property. Field is required. Expected type: Float64.  default value: 0.0\nR1_outer_surface: Additional longitudinal relaxation rate (kHz). Outer_surface property. Field is required. Expected type: Float64.  default value: 0.0\nR1_inner_volume: Additional longitudinal relaxation rate (kHz). Inner_volume property. Field is required. Expected type: Float64.  default value: 0.0\nR1_outer_volume: Additional longitudinal relaxation rate (kHz). Outer_volume property. Field is required. Expected type: Float64.  default value: 0.0\nR2_inner_surface: Additional transverse relaxation rate (kHz). Inner_surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2_outer_surface: Additional transverse relaxation rate (kHz). Outer_surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2_inner_volume: Additional transverse relaxation rate (kHz). Inner_volume property. Field is required. Expected type: Float64.  default value: 0.0\nR2_outer_volume: Additional transverse relaxation rate (kHz). Outer_volume property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_inner_surface: Additional off-resonance field offset (kHz). Inner_surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_outer_surface: Additional off-resonance field offset (kHz). Outer_surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_inner_volume: Additional off-resonance field offset (kHz). Inner_volume property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_outer_volume: Additional off-resonance field offset (kHz). Outer_volume property. Field is required. Expected type: Float64.  default value: 0.0\nposition: Spatial offset of obstruction from origin. Field is required. Expected type: StaticArraysCore.MVector{2, Float64}.  default value: [0.0, 0.0]\nsusceptibility_iso: Isotropic component of the myelin susceptibility (in ppm). Field can be null. Expected type: Float64.  default value: -0.1\nsusceptibility_aniso: Anisotropic component of the myelin susceptibility (in ppm). Field can be null. Expected type: Float64.  default value: -0.1\nlorentz_radius: Only compute field explicitly for a annuli with this Lorentz radius. Field can be null. Expected type: Float64.  default value: 5.0\nrepeats: Length scale on which the obstructions are repeated (um). Field can be null. Expected type: StaticArraysCore.MVector{2, Float64}.\nuse_boundingbox: Use bounding boxes for an initial filtering of possible intersections. Field can be null. Expected type: Bool.  default value: true\ngrid_resolution: Resolution of the grid that the volume is split up into (um). Defaults to roughly one grid element per obstruction. Field can be null. Expected type: Float64.\ndwell_time_inner_surface: Average time a particle stays stuck to the surface (ms). Inner_surface property. Field can be null. Expected type: Float64.\ndwell_time_outer_surface: Average time a particle stays stuck to the surface (ms). Outer_surface property. Field can be null. Expected type: Float64.\ndensity_inner_surface: Surface density of stuck particles relative to the volume density (um). Inner_surface property. Field can be null. Expected type: Float64.\ndensity_outer_surface: Surface density of stuck particles relative to the volume density (um). Outer_surface property. Field can be null. Expected type: Float64.\npermeability_inner_surface: Rate of particle passing through the obstruction in arbitrary units. Inner_surface property. Field can be null. Expected type: Float64.\npermeability_outer_surface: Rate of particle passing through the obstruction in arbitrary units. Outer_surface property. Field can be null. Expected type: Float64.\nrelaxation_inner_surface: Rate of signal loss at each collision. The actual signal loss at each collision is e^(-x * sqrt(t)), where x is this rate and t is the timestep. Inner_surface property. Field can be null. Expected type: Float64.\nrelaxation_outer_surface: Rate of signal loss at each collision. The actual signal loss at each collision is e^(-x * sqrt(t)), where x is this rate and t is the timestep. Outer_surface property. Field can be null. Expected type: Float64.\nsize_scale: Size of the smallest obstructions. If not set explicitly, this will be determined by the minimum radius or distance between objects (see size_scale). Field can be null. Expected type: Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Annulus","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Annulus","text":"Singular Annulus object that is obtained by indexing a Annuli object.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Cylinders","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Cylinders","text":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup{:Cylinders})(; fields...)\n\nCreates a set of MCMRSimulator.Cylinder objects. Fields can be set using keyword arguments. The following fields are available:\n\nradius: Radius of the cylinder. Field is required. Expected type: Float64.\nrotation: Rotation applied to all obstructions in group. Can be set to a matrix or one of :x, :y, or, :z (see MCMRSimulator.get_rotation). Field is required. Expected type: StaticArraysCore.SMatrix{3, 2, Float64, 6}.  default value: [1.0 0.0; 0.0 1.0; 0.0 0.0]\nR1_surface: Additional longitudinal relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR1_inside: Additional longitudinal relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nR2_surface: Additional transverse relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2_inside: Additional transverse relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_surface: Additional off-resonance field offset (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_inside: Additional off-resonance field offset (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nposition: Spatial offset of obstruction from origin. Field is required. Expected type: StaticArraysCore.MVector{2, Float64}.  default value: [0.0, 0.0]\ng_ratio: Inner/outer radius used for susceptibility calculation Field can be null. Expected type: Float64.  default value: 1.0\nsusceptibility_iso: Isotropic component of the susceptibility (in ppm um). It can be calculated by multiplying the isotropic susceptibility of the simulated tissue by the thickness. Field can be null. Expected type: Float64.  default value: -0.1\nsusceptibility_aniso: Anisotropic component of the susceptibility (in ppm um). It can be calculated by multiplying the anisotropic susceptibility of the simulated tissue by the thickness Field can be null. Expected type: Float64.  default value: -0.1\nlorentz_radius: Only compute field explicitly for cylinders with this Lorentz radius. Field can be null. Expected type: Float64.  default value: 5.0\nrepeats: Length scale on which the obstructions are repeated (um). Field can be null. Expected type: StaticArraysCore.MVector{2, Float64}.\nuse_boundingbox: Use bounding boxes for an initial filtering of possible intersections. Field can be null. Expected type: Bool.  default value: true\ngrid_resolution: Resolution of the grid that the volume is split up into (um). Defaults to roughly one grid element per obstruction. Field can be null. Expected type: Float64.\ndwell_time: Average time a particle stays stuck to the surface (ms). Surface property. Field can be null. Expected type: Float64.\ndensity: Surface density of stuck particles relative to the volume density (um). Surface property. Field can be null. Expected type: Float64.\npermeability: Rate of particle passing through the obstruction in arbitrary units. Surface property. Field can be null. Expected type: Float64.\nrelaxation: Rate of signal loss at each collision. The actual signal loss at each collision is e^(-x * sqrt(t)), where x is this rate and t is the timestep. Surface property. Field can be null. Expected type: Float64.\nsize_scale: Size of the smallest obstructions. If not set explicitly, this will be determined by the minimum radius or distance between objects (see size_scale). Field can be null. Expected type: Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Cylinder","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Cylinder","text":"Singular Cylinder object that is obtained by indexing a Cylinders object.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Walls","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Walls","text":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup{:Walls})(; fields...)\n\nCreates a set of MCMRSimulator.Wall objects. Fields can be set using keyword arguments. The following fields are available:\n\nrotation: Rotation applied to all obstructions in group. Can be set to a matrix or one of :x, :y, or, :z (see MCMRSimulator.get_rotation). Field is required. Expected type: StaticArraysCore.SMatrix{3, 1, Float64, 3}.  default value: [1.0; 0.0; 0.0;;]\nR1: Additional longitudinal relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2: Additional transverse relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance: Additional off-resonance field offset (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nposition: Spatial offset of obstruction from origin. Field is required. Expected type: Float64.  default value: 0.0\nrepeats: Length scale on which the obstructions are repeated (um). Field can be null. Expected type: StaticArraysCore.MVector{1, Float64}.\nuse_boundingbox: Use bounding boxes for an initial filtering of possible intersections. Field can be null. Expected type: Bool.  default value: true\ngrid_resolution: Resolution of the grid that the volume is split up into (um). Defaults to roughly one grid element per obstruction. Field can be null. Expected type: Float64.\ndwell_time: Average time a particle stays stuck to the surface (ms). Surface property. Field can be null. Expected type: Float64.\ndensity: Surface density of stuck particles relative to the volume density (um). Surface property. Field can be null. Expected type: Float64.\npermeability: Rate of particle passing through the obstruction in arbitrary units. Surface property. Field can be null. Expected type: Float64.\nrelaxation: Rate of signal loss at each collision. The actual signal loss at each collision is e^(-x * sqrt(t)), where x is this rate and t is the timestep. Surface property. Field can be null. Expected type: Float64.\nsize_scale: Size of the smallest obstructions. If not set explicitly, this will be determined by the minimum radius or distance between objects (see size_scale). Field can be null. Expected type: Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Wall","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Wall","text":"Singular Wall object that is obtained by indexing a Walls object.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Spheres","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Spheres","text":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup{:Spheres})(; fields...)\n\nCreates a set of MCMRSimulator.Sphere objects. Fields can be set using keyword arguments. The following fields are available:\n\nradius: Radius of the cylinder. Field is required. Expected type: Float64.\nrotation: Rotation applied to all obstructions in group. Can be set to a matrix or one of :x, :y, or, :z (see MCMRSimulator.get_rotation). Field is required. Expected type: StaticArraysCore.SMatrix{3, 3, Float64, 9}.  default value: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]\nR1_surface: Additional longitudinal relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR1_inside: Additional longitudinal relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nR2_surface: Additional transverse relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2_inside: Additional transverse relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_surface: Additional off-resonance field offset (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_inside: Additional off-resonance field offset (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nposition: Spatial offset of obstruction from origin. Field is required. Expected type: StaticArraysCore.MVector{3, Float64}.  default value: [0.0, 0.0, 0.0]\nrepeats: Length scale on which the obstructions are repeated (um). Field can be null. Expected type: StaticArraysCore.MVector{3, Float64}.\nuse_boundingbox: Use bounding boxes for an initial filtering of possible intersections. Field can be null. Expected type: Bool.  default value: true\ngrid_resolution: Resolution of the grid that the volume is split up into (um). Defaults to roughly one grid element per obstruction. Field can be null. Expected type: Float64.\ndwell_time: Average time a particle stays stuck to the surface (ms). Surface property. Field can be null. Expected type: Float64.\ndensity: Surface density of stuck particles relative to the volume density (um). Surface property. Field can be null. Expected type: Float64.\npermeability: Rate of particle passing through the obstruction in arbitrary units. Surface property. Field can be null. Expected type: Float64.\nrelaxation: Rate of signal loss at each collision. The actual signal loss at each collision is e^(-x * sqrt(t)), where x is this rate and t is the timestep. Surface property. Field can be null. Expected type: Float64.\nsize_scale: Size of the smallest obstructions. If not set explicitly, this will be determined by the minimum radius or distance between objects (see size_scale). Field can be null. Expected type: Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Sphere","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Sphere","text":"Singular Sphere object that is obtained by indexing a Spheres object.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Mesh","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Mesh","text":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup{:Mesh})(; fields...)\n\nCreates a set of MCMRSimulator.Triangle objects. Fields can be set using keyword arguments. The following fields are available:\n\ntriangles: Each triangle is defined by 3 vertices into the mesh. Field is required. Expected type: StaticArraysCore.MVector{3, Int64}.\nvertices: Positions of the corners of the triangular mesh. Field is required. Expected type: Vector{StaticArraysCore.MVector{3, Float64}}.\nmyelin: Whether the mesh is myelinated. Field is required. Expected type: Bool.  default value: false\nrotation: Rotation applied to all obstructions in group. Can be set to a matrix or one of :x, :y, or, :z (see MCMRSimulator.get_rotation). Field is required. Expected type: StaticArraysCore.SMatrix{3, 3, Float64, 9}.  default value: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]\nR1_surface: Additional longitudinal relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR1_inside: Additional longitudinal relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nR2_surface: Additional transverse relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2_inside: Additional transverse relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_surface: Additional off-resonance field offset (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_inside: Additional off-resonance field offset (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nsusceptibility_iso: Isotropic component of the susceptibility (in ppm um). It can be calculated by multiplying the isotropic susceptibility of the simulated tissue by the thickness. Field can be null. Expected type: Float64.  default value: -0.1\nsusceptibility_aniso: Anisotropic component of the susceptibility (in ppm um). It can be calculated by multiplying the anisotropic susceptibility of the simulated tissue by the thickness. Field can be null. Expected type: Float64.  default value: -0.1\nlorentz_radius: Only compute field explicitly for triangles with this Lorentz radius. Field can be null. Expected type: Float64.  default value: 5.0\ncomponents: Which component this triangle belongs to. If not provided explicitly, this will be determined based on connectivity. Field can be null. Expected type: Int64.\nrepeats: Length scale on which the obstructions are repeated (um). Field can be null. Expected type: StaticArraysCore.MVector{3, Float64}.\nuse_boundingbox: Use bounding boxes for an initial filtering of possible intersections. Field can be null. Expected type: Bool.  default value: true\ngrid_resolution: Resolution of the grid that the volume is split up into (um). Defaults to roughly one grid element per obstruction. Field can be null. Expected type: Float64.\ndwell_time: Average time a particle stays stuck to the surface (ms). Surface property. Field can be null. Expected type: Float64.\ndensity: Surface density of stuck particles relative to the volume density (um). Surface property. Field can be null. Expected type: Float64.\npermeability: Rate of particle passing through the obstruction in arbitrary units. Surface property. Field can be null. Expected type: Float64.\nrelaxation: Rate of signal loss at each collision. The actual signal loss at each collision is e^(-x * sqrt(t)), where x is this rate and t is the timestep. Surface property. Field can be null. Expected type: Float64.\nsize_scale: Size of the smallest obstructions. If not set explicitly, this will be determined by the minimum radius or distance between objects (see size_scale). Field can be null. Expected type: Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Triangle","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Triangle","text":"Singular Triangle object that is obtained by indexing a Mesh object.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.BendyCylinder","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.BendyCylinder","text":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup{:BendyCylinder})(; fields...)\n\nCreates a set of MCMRSimulator.Ring objects. Fields can be set using keyword arguments. The following fields are available:\n\ncontrol_point: Control points defining the path of the cylinder. Field is required. Expected type: StaticArraysCore.MVector{3, Float64}.\nradius: Radius at each control point. Field is required. Expected type: Float64.\nspline_order: Sets the order of the b-spine interpolating between control points. Field is required. Expected type: Int64.  default value: 3\nmyelin: Whether the cylinder is myelinated. Field is required. Expected type: Bool.  default value: false\nrotation: Rotation applied to all obstructions in group. Can be set to a matrix or one of :x, :y, or, :z (see MCMRSimulator.get_rotation). Field is required. Expected type: StaticArraysCore.SMatrix{3, 3, Float64, 9}.  default value: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]\nR1_surface: Additional longitudinal relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR1_inside: Additional longitudinal relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nR2_surface: Additional transverse relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2_inside: Additional transverse relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_surface: Additional off-resonance field offset (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_inside: Additional off-resonance field offset (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nnsamples: Number of mesh vertices along each ring. Field can be null. Expected type: Int64.  default value: 100\nclosed: After how many repeats in each dimension does the cylinder connect with itself. If not set the cylinder is not closed. Field can be null. Expected type: StaticArraysCore.MVector{3, Int64}.\nsusceptibility_iso: Isotropic component of the susceptibility (in ppm um). It can be calculated by multiplying the isotropic susceptibility of the simulated tissue by the thickness. Field can be null. Expected type: Float64.  default value: -0.1\nsusceptibility_aniso: Anisotropic component of the susceptibility (in ppm um). It can be calculated by multiplying the anisotropic susceptibility of the simulated tissue by the thickness. Field can be null. Expected type: Float64.  default value: -0.1\nlorentz_radius: Only compute field explicitly for triangles with this Lorentz radius. Field can be null. Expected type: Float64.  default value: 5.0\nrepeats: Length scale on which the obstructions are repeated (um). Field can be null. Expected type: StaticArraysCore.MVector{3, Float64}.\nuse_boundingbox: Use bounding boxes for an initial filtering of possible intersections. Field can be null. Expected type: Bool.  default value: true\ngrid_resolution: Resolution of the grid that the volume is split up into (um). Defaults to roughly one grid element per obstruction. Field can be null. Expected type: Float64.\ndwell_time: Average time a particle stays stuck to the surface (ms). Surface property. Field can be null. Expected type: Float64.\ndensity: Surface density of stuck particles relative to the volume density (um). Surface property. Field can be null. Expected type: Float64.\npermeability: Rate of particle passing through the obstruction in arbitrary units. Surface property. Field can be null. Expected type: Float64.\nrelaxation: Rate of signal loss at each collision. The actual signal loss at each collision is e^(-x * sqrt(t)), where x is this rate and t is the timestep. Surface property. Field can be null. Expected type: Float64.\nsize_scale: Size of the smallest obstructions. If not set explicitly, this will be determined by the minimum radius or distance between objects (see size_scale). Field can be null. Expected type: Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Ring","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Ring","text":"Singular Ring object that is obtained by indexing a BendyCylinder object.\n\n\n\n\n\n","category":"type"},{"location":"api/#Geometry-helper-functions","page":"API","title":"Geometry helper functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"load_mesh\nrandom_positions_radii","category":"page"},{"location":"api/#MCMRSimulator.Geometries.User.LoadMesh.load_mesh","page":"API","title":"MCMRSimulator.Geometries.User.LoadMesh.load_mesh","text":"load_mesh(file)\n\nLoads a Mesh from a file.\n\nCurrently only PLY files are supported.\n\nPLY format\n\nPLY stands for Polygon File Format (http://paulbourke.net/dataformats/ply/). PLY IO is handled by PlyIO.jl (https://github.com/JuliaGeometry/PlyIO.jl).\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.User.RandomDistribution.random_positions_radii","page":"API","title":"MCMRSimulator.Geometries.User.RandomDistribution.random_positions_radii","text":"random_positions_radii(box_size, target_density, n_dimensions; distribution=Gamma, mean=1., variance=1., max_iter=1000, min_radius=0.1, max_radius=Inf)\n\nRandomly distributes circles or spheres in space.\n\nArguments:\n\nbox_size: Size of the infinitely repeating box of random positions\ntarget_density: Final density of the circles/spheres. This density will only be approximately reached\nn_dimensions: dimensionality of the space (2 for cicles; 3 for spheres)\ndistribution: distribution from which the radii are drawn (from Distributions.jl)\nmean: mean of the gamma distribution (ignored if distribution explicitly set)\nvariance: variance of the gamma distribution (ignored if distribution explicitly set)\nmax_iter: maximum number of iterations to try to prevent the circles/spheres from overlapping. An error is raised if they still overlap after this number of iterations.\nrepulsion_strength: strength of the repulsion in each step (defaults to 0.001).\nmax_iter_repulse: maximum number of iterations that circles/spheres will be repulsed from each other\nmin_radius: samples from the distribution below this radius will be rejected (in um).\nmax_radius: samples from the distribution above this radius will be rejected (in um).\n\n\n\n\n\n","category":"function"},{"location":"api/#Querying-simulation-output","page":"API","title":"Querying simulation output","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"position\nlongitudinal\ntransverse\nphase\norientation\nget_sequence\nisinside\nstuck\nstuck_to\nget_time","category":"page"},{"location":"api/#MCMRSimulator.Spins.position","page":"API","title":"MCMRSimulator.Spins.position","text":"position(s::Spin)\n\nReturns the position of the spin particle as a vector of length 3.\n\n\n\n\n\nposition.(s::Snapshot)\n\nReturns all the positions of the spin particles as a vector of length-3 vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Spins.longitudinal","page":"API","title":"MCMRSimulator.Spins.longitudinal","text":"longitudinal(spin)\nlongitudinal(snapshot)\n\nReturns the longitudinal magnitude of the spin (i.e., magnitude aligned with the magnetic field) for a single particle (Spin) or averaged across a group of particles in a [Snapshot]. When orientations for multiple sequences are available an array of longitudinal values is returned with a value for each sequence.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Spins.transverse","page":"API","title":"MCMRSimulator.Spins.transverse","text":"transverse(spin)\ntransverse(snapshot)\n\nReturns the transverse spin (i.e., magnitude in the plane perpendicular to the magnetic field) for a single particle (Spin) or averaged across a group of particles in a [Snapshot]. When orientations for multiple sequences are available an array of transverse values is returned with a value for each sequence.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Spins.phase","page":"API","title":"MCMRSimulator.Spins.phase","text":"phase(spin)\nphase(snapshot)\n\nReturns the phase in the x-y plane of the spin for a single particle (Spin) or averaged across a group of particles in a [Snapshot]. When orientations for multiple sequences are available  an array of phase values is returned with a value for each sequence.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Spins.orientation","page":"API","title":"MCMRSimulator.Spins.orientation","text":"orientation(spin)\norientation(snapshot)\n\nReturns the spin orientation as a length-3 vector for a single particle (Spin) or averaged across a group of particles in a [Snapshot]. When orientations for multiple sequences are available an array of vectors is returned with a value for each sequence.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Spins.get_sequence","page":"API","title":"MCMRSimulator.Spins.get_sequence","text":"get_sequence(spin, sequence_index)\nget_sequence(snapshot, sequence_index)\n\nExtracts the spin orientation corresponding to a specific sequence, where the sequence index uses the order in which the sequences where provided in the Simulation.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.Internal.BoundingBoxes.isinside","page":"API","title":"MCMRSimulator.Geometries.Internal.BoundingBoxes.isinside","text":"isinside(obstruction, position)\n\nReturns true if the position is inside the obstruction. This will be inaccurate if the particle with that position is stuck on the surface of the obstruction.\n\n\n\n\n\nisinside([geometry, ]spin)\n\nReturns vector of obstructions that the spin is inside. If geometry is not provided, will return a vector of indices instead. If a non-fixed geometry is provided, will return the number of obstructions that the spin is inside.\n\n\n\n\n\nisinside(grid, position)\n\nGet the indices of obstructions that contain the position.\n\n\n\n\n\nisinside(obstruction_group, position[, stuck_to])\n\nReturns a vector of indices with all the obstructions in FixedObstructionGroup containing the position (in order). For obstructions with only a single inside, will return an empty vector (\"[]\") if the particle is outside and a \"[0]\" if inside.\n\n\n\n\n\nisinside(geometry, position[, stuck_reflection])\n\nReturns a vector of pairs of indices with all the obstructions in FixedGeometry containing the position (in order). The first index indicates the index of the FixedObstructionGroup within the geometry. The second index is the index of the specific FixedObstruction within the obstruction group.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Spins.stuck","page":"API","title":"MCMRSimulator.Spins.stuck","text":"stuck(spin)\n\nReturns true if the spin is stuck on the surface. This can be used to filter a Snapshot using:\n\nonly_stuck = filter(stuck, snapshot)\nonly_free = filter(s -> !stuck(s), snapshot)\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Spins.stuck_to","page":"API","title":"MCMRSimulator.Spins.stuck_to","text":"stuck_to(spin)\n\nReturn the indices of the obstruction the spin is stuck to. Will return (0, 0) for a free spin.\n\n\n\n\n\nstuck_to(spin, geometry)\n\nReturn the internal representation of the obstruction the spin is stuck to. Raises an error if the spin is free.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Methods.get_time","page":"API","title":"MCMRSimulator.Methods.get_time","text":"get_time(snapshot)\nget_time(sequence_component)\nget_time(sequence, sequence_index)\n\nReturns the time in milliseconds that a snapshot was taken or that a sequence component will have effect.\n\n\n\n\n\n","category":"function"},{"location":"api/#Plotting","page":"API","title":"Plotting","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"PlotPlane\nplot_snapshot\nplot_geometry\nplot_trajectory\nplot_off_resonance\nsimulator_movie","category":"page"},{"location":"api/#MCMRSimulator.Plot.PlotPlane","page":"API","title":"MCMRSimulator.Plot.PlotPlane","text":"Defines a finite plane in the 3D space used for plotting.\n\nConstructor\n\nPlotPlane(normal=[0, 0, 1], position=[0, 0, 0]; size=10., sizex=<size>, sizey=<size>, ngrid=100)\n\nArguments:\n\nnormal: length-3 vector with the orientation perpendicular to the plane (default to z-direction).\nposition: position of plane as a length-3 vector (defaults to origin).\nsizex: size of the plane in the x-direction (before rotating to normal).\nsizey: size of the plane in the y-direction (before rotating to normal).\nsize: set default value for sizex and sizey.\nngrid: number of grid elements to split the plane up into for plotting.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Plot.plot_snapshot","page":"API","title":"MCMRSimulator.Plot.plot_snapshot","text":"plot([plot_plane], snapshot; kind=:scatter, kwargs...)\nplot!([scene,] [plot_plane], snapshot; kind=:scatter, kwargs...)\nplot_snapshot([plot_plane], snapshot; kind=:scatter, kwargs...)\nplot_snapshot!([scene,] [plot_plane], snapshot; kind=:scatter, kwargs...)\n\nPlots a Snapshot in a new plot. \n\nThe spins are plotted in 2D projected onto the PlotPlane if one is provided. Otherwise, the spins are plotted in 3D (does not work for kind=:image).\n\nThere are three kinds of snapshot plots available:\n\nScatter plot\n\nDefault (or set using kind=:scatter). Each spin is plotted as a point with the colour set by the transverse magnetisation. Additional keywords are passed on to Makie.scatter (namely, marker, markersize, strokecolor, strokewidth, glowcolor, glowwidth).\n\nDyad plot\n\nSet using kind=:dyad. Each spin is plotted as a dyad. For a 2D dyad the orienation is set by the transverse magnetisation. For a 3D dyad the full magnetisation is used to set the orienation. Additional keywords are passed on to Makie.arrows (namely, arrowsize, arrowhead, arrowtail, linestyle, lengthscale, quality, markerspace, diffuse, specular, shininess).\n\nImage\n\nSet using kind=:image. The average magnetisation is plotted across the PlotPlane.  The colour in each pixel is set by the average transverse magnetisation of the local spins. Set interpolate=false to disable interpolating the colors. This plot will not work in 3D (i.e., a PlotPlane is required).\n\nThis function will only work if Makie is installed and imported.\n\nPlot type\n\nThe plot type alias for the plot_snapshot function is Plot_Snapshot.\n\nAttributes\n\narrowhead =  automatic  — No docs available.\n\narrowsize =  automatic  — No docs available.\n\narrowtail =  automatic  — No docs available.\n\nclip_planes =  automatic  — Clip planes offer a way to do clipping in 3D space. You can set a Vector of up to 8 Plane3f planes here, behind which plots will be clipped (i.e. become invisible). By default clip planes are inherited from the parent plot or scene. You can remove parent clip_planes by passing Plane3f[].\n\ncolor =  automatic  — Set the color.\n\ndepth_shift =  0.0  — adjusts the depth value of a plot after all other transformations, i.e. in clip space, where 0 <= depth <= 1. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).\n\ndiffuse =  0.4  — No docs available.\n\nfxaa =  true  — adjusts whether the plot is rendered with fxaa (anti-aliasing, GLMakie only).\n\nglowcolor =  (:black, 0.0)  — No docs available.\n\nglowwidth =  0.0  — No docs available.\n\ninspectable =  true  — sets whether this plot should be seen by DataInspector.\n\ninspector_clear =  automatic  — Sets a callback function (inspector, plot) -> ... for cleaning up custom indicators in DataInspector.\n\ninspector_hover =  automatic  — Sets a callback function (inspector, plot, index) -> ... which replaces the default show_data methods.\n\ninspector_label =  automatic  — Sets a callback function (plot, index, position) -> string which replaces the default label generated by DataInspector.\n\ninterpolate =  true  — Whether to interpolate for kind=:image.\n\nkind =  :scatter  — Plot format to use (:scatter, :dyad, or :image).\n\nlengthscale =  1.0  — No docs available.\n\nlinestyle =  nothing  — No docs available.\n\nmarker =  @inherit marker  — No docs available.\n\nmarkersize =  @inherit markersize  — No docs available.\n\nmarkerspace =  :pixel  — No docs available.\n\nmodel =  automatic  — Sets a model matrix for the plot. This overrides adjustments made with translate!, rotate! and scale!.\n\nngrid =  20  — Number of grid elements to plot for kind=:image.\n\noverdraw =  false  — Controls if the plot will draw over other plots. This specifically means ignoring depth checks in GL backends\n\nquality =  32  — No docs available.\n\nsequence =  1  — Which magnetisation to plot if multiple sequences were simulated.\n\nshininess =  32.0  — No docs available.\n\nspace =  :data  — sets the transformation space for box encompassing the plot. See Makie.spaces() for possible inputs.\n\nspecular =  0.2  — No docs available.\n\nssao =  false  — Adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with fxaa = true.\n\nstrokecolor =  @inherit markerstrokecolor  — No docs available.\n\nstrokewidth =  @inherit markerstrokewidth  — No docs available.\n\ntransformation =  automatic  — No docs available.\n\ntransparency =  false  — Adjusts how the plot deals with transparency. In GLMakie transparency = true results in using Order Independent Transparency.\n\nvisible =  true  — Controls whether the plot will be rendered or not.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Plot.plot_geometry","page":"API","title":"MCMRSimulator.Plot.plot_geometry","text":"plot([plot_plane,] geometry; kwargs...)\nplot!([scene,] [plot_plane,] geometry; kwargs...)\nplot_geometry([plot_plane,] geometry; kwargs...)\nplot_geometry!([scene,] [plot_plane,] geometry; kwargs...)\n\nPlots a given geometry.  If a PlotPlane is provided the 2D projection of the geometry onto this plane is plotted. Otherwise, the geometry is plotted in 3D.\n\nIf you want to overlay the off-resonance field, call plot_off_resonance first before calling this function.\n\nThis function will only work if a Makie backend is imported.\n\nPlot type\n\nThe plot type alias for the plot_geometry function is Plot_Geometry.\n\nAttributes\n\nalpha =  1.0  — Set the transparancy in a 3D plot (0 being fully transparent and 1 fully opague).\n\nbacklight =  0.0  — Sets a weight for secondary light calculation with inverted normals.\n\nclip_planes =  automatic  — Clip planes offer a way to do clipping in 3D space. You can set a Vector of up to 8 Plane3f planes here, behind which plots will be clipped (i.e. become invisible). By default clip planes are inherited from the parent plot or scene. You can remove parent clip_planes by passing Plane3f[].\n\ncolor =  automatic  — Set the color of the lines (2D) or patches (3D). In 2D it is set to the theme's linecolor by default. In 3D each individual obstruction is by default plotted in a different, distinguishable color.\n\ndepth_shift =  0.0  — adjusts the depth value of a plot after all other transformations, i.e. in clip space, where 0 <= depth <= 1. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).\n\ndiffuse =  1.0  — Sets how strongly the red, green and blue channel react to diffuse (scattered) light.\n\nfxaa =  true  — adjusts whether the plot is rendered with fxaa (anti-aliasing, GLMakie only).\n\nheight =  1.0  — Size to plot in μm of infinite walls and cylinders in 3D plot.\n\ninspectable =  true  — sets whether this plot should be seen by DataInspector.\n\ninspector_clear =  automatic  — Sets a callback function (inspector, plot) -> ... for cleaning up custom indicators in DataInspector.\n\ninspector_hover =  automatic  — Sets a callback function (inspector, plot, index) -> ... which replaces the default show_data methods.\n\ninspector_label =  automatic  — Sets a callback function (plot, index, position) -> string which replaces the default label generated by DataInspector.\n\nlinestyle =  nothing  — Set the linestyle in 2D plots.\n\nlinewidth =  @inherit linewidth  — Set the linewidth in 2D plots.\n\nmaterial =  nothing  — RPRMakie only attribute to set complex RadeonProRender materials.         Warning, how to set an RPR material may change and other backends will ignore this attribute\n\nmodel =  automatic  — Sets a model matrix for the plot. This overrides adjustments made with translate!, rotate! and scale!.\n\nnsamples =  automatic  — Number of samples in mesh used to plot cylinders (default: 100) and spheres (default: 1000) in 3D plot.\n\noverdraw =  false  — Controls if the plot will draw over other plots. This specifically means ignoring depth checks in GL backends\n\nshading =  automatic  — Sets the lighting algorithm used. Options are NoShading (no lighting), FastShading (AmbientLight + PointLight) or MultiLightShading (Multiple lights, GLMakie only). Note that this does not affect RPRMakie.\n\nshininess =  32.0  — Sets how sharp the reflection is.\n\nspace =  :data  — sets the transformation space for box encompassing the plot. See Makie.spaces() for possible inputs.\n\nspecular =  0.2  — Sets how strongly the object reflects light in the red, green and blue channels.\n\nssao =  false  — Adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with fxaa = true.\n\ntransformation =  automatic  — No docs available.\n\ntransparency =  false  — Adjusts how the plot deals with transparency. In GLMakie transparency = true results in using Order Independent Transparency.\n\nvisible =  true  — Controls whether the plot will be rendered or not.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Plot.plot_trajectory","page":"API","title":"MCMRSimulator.Plot.plot_trajectory","text":"plot([plot_plane], snapshots; kwargs...)\nplot!([scene,] [plot_plane], snapshots; kwargs...)\nplot_trajectory([plot_plane], snapshots; kwargs...)\nplot_trajectory!([scene,] [plot_plane], snapshots; kwargs...)\n\nPlots the spin trajectory in a vector of Snapshot on an existing plot scene.\n\nThe spins are plotted in 2D projected onto the PlotPlane if one is provided. Otherwise, the spins are plotted in 3D. At each location along the trajectory, the colour is set by the transverse magnetisation. Additional keywords are passed on to Makie.lines!.\n\nThis function will only work if Makie is installed and imported.\n\nPlot type\n\nThe plot type alias for the plot_trajectory function is Plot_Trajectory.\n\nAttributes\n\nclip_planes =  automatic  — Clip planes offer a way to do clipping in 3D space. You can set a Vector of up to 8 Plane3f planes here, behind which plots will be clipped (i.e. become invisible). By default clip planes are inherited from the parent plot or scene. You can remove parent clip_planes by passing Plane3f[].\n\ncolor =  automatic  — No docs available.\n\ndepth_shift =  0.0  — adjusts the depth value of a plot after all other transformations, i.e. in clip space, where 0 <= depth <= 1. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).\n\nfxaa =  true  — adjusts whether the plot is rendered with fxaa (anti-aliasing, GLMakie only).\n\ninspectable =  true  — sets whether this plot should be seen by DataInspector.\n\ninspector_clear =  automatic  — Sets a callback function (inspector, plot) -> ... for cleaning up custom indicators in DataInspector.\n\ninspector_hover =  automatic  — Sets a callback function (inspector, plot, index) -> ... which replaces the default show_data methods.\n\ninspector_label =  automatic  — Sets a callback function (plot, index, position) -> string which replaces the default label generated by DataInspector.\n\nmodel =  automatic  — Sets a model matrix for the plot. This overrides adjustments made with translate!, rotate! and scale!.\n\noverdraw =  false  — Controls if the plot will draw over other plots. This specifically means ignoring depth checks in GL backends\n\nsequence =  1  — Which magnetisation to plot if multiple sequences were simulated.\n\nspace =  :data  — sets the transformation space for box encompassing the plot. See Makie.spaces() for possible inputs.\n\nssao =  false  — Adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with fxaa = true.\n\ntransformation =  automatic  — No docs available.\n\ntransparency =  false  — Adjusts how the plot deals with transparency. In GLMakie transparency = true results in using Order Independent Transparency.\n\nvisible =  true  — Controls whether the plot will be rendered or not.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Plot.plot_off_resonance","page":"API","title":"MCMRSimulator.Plot.plot_off_resonance","text":"plot_off_resonance(plot_plane, geometry; kwargs...)\nplot_off_resonance!([scene,] plot_plane, geometry; kwargs...)\n\nPlots the off-resonance field generated by a given geometry within the PlotPlane.\n\nThis function will only work if a Makie backend is imported.\n\nPlot type\n\nThe plot type alias for the plot_off_resonance function is Plot_Off_Resonance.\n\nAttributes\n\nalpha =  1.0  — The alpha value of the colormap or color attribute. Multiple alphas like in plot(alpha=0.2, color=(:red, 0.5), will get multiplied.\n\nclip_planes =  automatic  — Clip planes offer a way to do clipping in 3D space. You can set a Vector of up to 8 Plane3f planes here, behind which plots will be clipped (i.e. become invisible). By default clip planes are inherited from the parent plot or scene. You can remove parent clip_planes by passing Plane3f[].\n\ncolormap =  @inherit colormap :viridis  — Sets the colormap that is sampled for numeric colors. PlotUtils.cgrad(...), Makie.Reverse(any_colormap) can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call Makie.available_gradients().\n\ncolorrange =  automatic  — The values representing the start and end points of colormap.\n\ncolorscale =  identity  — The color transform function. Can be any function, but only works well together with Colorbar for identity, log, log2, log10, sqrt, logit, Makie.pseudolog10 and Makie.Symlog10.\n\ndepth_shift =  0.0  — adjusts the depth value of a plot after all other transformations, i.e. in clip space, where 0 <= depth <= 1. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).\n\nfxaa =  true  — adjusts whether the plot is rendered with fxaa (anti-aliasing, GLMakie only).\n\nhighclip =  automatic  — The color for any value above the colorrange.\n\ninspectable =  true  — sets whether this plot should be seen by DataInspector.\n\ninspector_clear =  automatic  — Sets a callback function (inspector, plot) -> ... for cleaning up custom indicators in DataInspector.\n\ninspector_hover =  automatic  — Sets a callback function (inspector, plot, index) -> ... which replaces the default show_data methods.\n\ninspector_label =  automatic  — Sets a callback function (plot, index, position) -> string which replaces the default label generated by DataInspector.\n\nlowclip =  automatic  — The color for any value below the colorrange.\n\nmodel =  automatic  — Sets a model matrix for the plot. This overrides adjustments made with translate!, rotate! and scale!.\n\nnan_color =  :transparent  — The color for NaN values.\n\nngrid =  400  — sets the number of points where the off-resonance field is evaluated before producing the image. Setting this to a higher number will produce a more accurate image of the off-resonance field at the cost of more computing power.\n\noverdraw =  false  — Controls if the plot will draw over other plots. This specifically means ignoring depth checks in GL backends\n\nspace =  :data  — sets the transformation space for box encompassing the plot. See Makie.spaces() for possible inputs.\n\nssao =  false  — Adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with fxaa = true.\n\ntransformation =  automatic  — No docs available.\n\ntransparency =  false  — Adjusts how the plot deals with transparency. In GLMakie transparency = true results in using Order Independent Transparency.\n\nvisible =  true  — Controls whether the plot will be rendered or not.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Plot.simulator_movie","page":"API","title":"MCMRSimulator.Plot.simulator_movie","text":"simulator_movie(filename, simulation, times, size; resolution=(1600, 800), trajectory_init=30, signal_init=10000, framerate=50, plane_orientation=:z, kwargs...)\n\nWrites a movie of the Simulation to the given filename.\n\nEach frame of the movie shows the Snapshot at given times. size is a tuple with the size of the plotted region in the x- and y-direction. If there is a repeating geometry, then it is strongly recommended to use the size of the repeat for size.\n\nKeyword arguments:\n\nresolution: pixel resolution of each frame in the movie.\ntrajectory_init: how many spins to plot on each frame.\nsignal_init: how many spins to use to evaluate the signal evolution.\nframerate: wait time between each subsequent frame in the movie.\nplane_orientation: orienation of the plane on which the spins are projected (see PlotPlane).\n\nAdditional keyword arguments are passed on to plot_snapshot.\n\nThis function will only work if Makie is installed and imported.\n\n\n\n\n\n","category":"function"},{"location":"api/#Probing-MCMR-internals","page":"API","title":"Probing MCMR internals","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"MCMRSimulator.gyromagnetic_ratio\nMCMRSimulator.get_rotation\nMCMRSimulator.get_readouts\nMCMRSimulator.IndexedReadout\nMCMRSimulator.susceptibility_off_resonance\nMCMRSimulator.ObstructionGroup\nMCMRSimulator.IndexedObstruction\nMCMRSimulator.nvolumes\nMCMRSimulator.fix\nMCMRSimulator.fix_susceptibility\nMCMRSimulator.FixedGeometry\nMCMRSimulator.FixedObstructionGroup\nMCMRSimulator.surface_relaxation\nMCMRSimulator.surface_density\nMCMRSimulator.dwell_time\nMCMRSimulator.permeability\nMCMRSimulator.GlobalProperties\nMCMRSimulator.R1\nMCMRSimulator.R2\nMCMRSimulator.off_resonance\nMCMRSimulator.install_cli\nMCMRSimulator.run_main","category":"page"},{"location":"api/#MCMRSimulator.Constants.gyromagnetic_ratio","page":"API","title":"MCMRSimulator.Constants.gyromagnetic_ratio","text":"gyromagnetic ratio of a proton (1H) in water in kHz/T\n\n\n\n\n\n","category":"constant"},{"location":"api/#MCMRSimulator.Methods.get_rotation","page":"API","title":"MCMRSimulator.Methods.get_rotation","text":"get_rotation(rotation_mat, ndim)\n\nReturns a (3, ndim) rotation matrix, that is the relevant part of the full 3x3 rotation_mat to map to the x-axis (if ndim is 1) or the x-y plance (if ndim is 2). If ndim is 3, the full rotation matrix rotation_mat is returned.\n\nget_rotation(vector, ndim; reference_dimension)\n\nReturns the (3, ndim) rotation matrix mapping the vector to the reference_dimension. By default, the reference_dimension is the x-direction (ifndimis 1 or 3) or the z-direction (ifndimis 2).vectorandreference_dimension` can be a length 3 array or one of the symbols :x, :y, or :z (representing vectors in those cardinal directions).\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.SequenceParts.get_readouts","page":"API","title":"MCMRSimulator.SequenceParts.get_readouts","text":"get_readouts(sequence, start_time; readouts=nothing, nTR=1, skip_TR=0)\n\nReturns a iterator of the readouts (IndexedReadout objects) that will be used for the given sequence in the simulator.\n\nThis can be used to identify which readouts will be (or have been) used in the simulation by running: collect(get_readouts(sequence, snapshot.current_time; kwargs...)) where snapshot is the starting snapshot (which has a current_time of 0 by default) and kwargs are the keyword arguments used in readout (i.e., readouts,nTR, andskip_TR`).\n\nBy default the readout/ADC objects with the actual sequence definition are used. These can be overriden by readouts, which can be set to a vector of the timings of the readouts within each TR.\n\nNon-repeating sequences\n\nThis is the behaviour if both nTR and skip_TR are not set by the user. Any readouts before the start_time are ignored. Any readouts after the start_time (whether from the readouts keyword or within the sequence definition) are returned.\n\nRepeating sequences\n\nThis is the behaviour if either nTR or skip_TR or both are not set by the user. If at start_time any of the readouts in the current TR have already passed, then the readout will only start in the next TR (unless skip_TR is set to -1). We will skip an additional number of TRs given by skip_TR (default: 0). Then readouts will continue for the number of TRs given by nTR (default: 1).\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.SequenceParts.IndexedReadout","page":"API","title":"MCMRSimulator.SequenceParts.IndexedReadout","text":"IndexedReadout(time, TR, readout)\n\nRepresents a readout in an MR sequence.\n\nGenerate these for a sequence of interest using get_readouts.\n\nAll indices are integers. They refer to:\n\ntime: time since beginning of sequence in ms\nTR: which TR the simulation is in (defaults to 0 if not set).\nreadout: which readout within the TR (or total sequence) this is.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Grid.susceptibility_off_resonance","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Grid.susceptibility_off_resonance","text":"susceptibility_off_resonance(susceptibility_grid, position[, inside])\n\nComputes the susceptibility off-resonance caused by a SusceptibilityGrid at given position.\n\nThe field is computed in ppm. Knowledge of the scanner B0 is needed to convert it into KHz.\n\n\n\n\n\nsusceptibility_off_resonance(simulation, spin)\n\nComputes the susceptibility off-resonance caused by all susceptibility sources in the Simulation affecting the Spin\n\nThe field is computed in ppm. Knowledge of the scanner B0 is needed to convert it into KHz.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup","text":"Parent type of all geometry objects like Cylinders or Mesh.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.IndexedObstruction","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.IndexedObstruction","text":"A single instance of an ObstructionGroup obtained by indexing.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.nvolumes","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.nvolumes","text":"nvolumes(group)\n\nFor any ObstructionType with group_volumes, this computes the number of distinct volumes.\n\nThis is mainly used to compute the number of distinct components in a mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.User.Fix.fix","page":"API","title":"MCMRSimulator.Geometries.User.Fix.fix","text":"fix(user_geometry; permeability=0., density=0., dwell_time=0., relaxation=0.)\n\nCreates a fixed version of the user-created geometry that will be used internally by the simulator.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.User.FixSusceptibility.fix_susceptibility","page":"API","title":"MCMRSimulator.Geometries.User.FixSusceptibility.fix_susceptibility","text":"fix_susceptibility(geometry)\n\nCreate a new FixedSusceptibility based on the user-defined geometry settings.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedGeometry","page":"API","title":"MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedGeometry","text":"FixedGeometry([obstruction_groups...])\n\nA collection of FixedObstructionGroup objects each reperesenting part of the geometry.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup","page":"API","title":"MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup","text":"A fixed version of ObstructionGroup that is used internally within the simulator.\n\nThis is the main internal representation of a group of identical FixedObstruction objects.\n\nProperties:\n\nobstructions: vector of the actual FixedObstruction objects.\nparent_index: Index of this group within the larger FixedGeometry.\noriginal_index: Index of this group within the original user-provided geometry.\nrotation: rotation from global 3-dimensional space to the 1, 2, or 3-dimensional space of the obstructions.\ninv_rotation: inverse of the rotation above\ngrid: Grid object on which the obstruction intersections have been precomputed. This speeds up the detection of intersections.\nbounding_boxes: vector of BoundingBox objects for each obstruction. These are used to predect whether a spin could intersect with the obstruction.\nvolume: R1, R2, and off-resonance properties of the spins inside the obstructions.\nsurface: R1, R2, off-resonance, surfacedensity and dwelltime properties of particles stuck to the surface. Also, contains the permeability and surface relaxation to process collsions.\nvertices: vector of vertices (only used for a mesh).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Properties.surface_relaxation","page":"API","title":"MCMRSimulator.Geometries.Internal.Properties.surface_relaxation","text":"surface_relaxation(geometry, reflection)\n\nReturns the surface_relaxation experienced by the spin hitting the surface represented by a Reflection. The geometry has to be a FixedGeometry.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.Internal.Properties.surface_density","page":"API","title":"MCMRSimulator.Geometries.Internal.Properties.surface_density","text":"surface_density(geometry, reflection)\n\nReturns the surface_density experienced by the spin hitting the surface represented by a Reflection. The geometry has to be a FixedGeometry.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.Internal.Properties.dwell_time","page":"API","title":"MCMRSimulator.Geometries.Internal.Properties.dwell_time","text":"dwell_time(geometry, reflection)\n\nReturns the dwell_time experienced by the spin hitting the surface represented by a Reflection. The geometry has to be a FixedGeometry.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.Internal.Properties.permeability","page":"API","title":"MCMRSimulator.Geometries.Internal.Properties.permeability","text":"permeability(geometry, reflection)\n\nReturns the permeability experienced by the spin hitting the surface represented by a Reflection. The geometry has to be a FixedGeometry.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Properties.GlobalProperties","page":"API","title":"MCMRSimulator.Properties.GlobalProperties","text":"GlobalProperties(; R1=0, R2=0, off_resonance=0)\n\nStores global MRI and collision properties.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Properties.R1","page":"API","title":"MCMRSimulator.Properties.R1","text":"R1(snapshot, geometry, global_properties)\nR1(spins, geometry, global_properties)\nR1(positions, geometry, global_properties)\n\nReturns the R1 experienced by the Spin objects given the surface and volume properties of the FixedGeometry. Alternatively, the position of the spins can be provided. In that case the spins will be presumed to be free.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Properties.R2","page":"API","title":"MCMRSimulator.Properties.R2","text":"R2(snapshot, geometry, global_properties)\nR2(spins, geometry, global_properties)\nR2(positions, geometry, global_properties)\n\nReturns the R2 experienced by the Spin objects given the surface and volume properties of the FixedGeometry. Alternatively, the position of the spins can be provided. In that case the spins will be presumed to be free.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Properties.off_resonance","page":"API","title":"MCMRSimulator.Properties.off_resonance","text":"off_resonance(snapshot, geometry, global_properties)\noff_resonance(spin(s), geometry, global_properties)\noff_resonance(position(s), geometry, global_properties)\n\nComputes the off-resonance field experienced by each spin in the Snapshot.\n\nA tuple is returned with:\n\nthe off-resonance field due to susceptibility sources in ppm (e.g., myelin/iron).\nthe off-resonance field due to other sources in kHz (i.e., off_resonance=... set by the user).\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.CLI.install_cli","page":"API","title":"MCMRSimulator.CLI.install_cli","text":"install_cli()\n\nInstalls the command line interface for \n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.CLI.run_main","page":"API","title":"MCMRSimulator.CLI.run_main","text":"run_main(args=ARGS; kwargs...)\n\nMain run command for the command line interface.\n\nAny keyword arguments are passed on to ArgParse.ArgParseSettings.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-modules","page":"API","title":"Internal modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The internals of these sub-modules are considered private and might change at any time.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Each of these modules corresponds to a file in the gitlab repository","category":"page"},{"location":"api/","page":"API","title":"API","text":"MCMRSimulator\nMCMRSimulator.Constants\nMCMRSimulator.Methods\nMCMRSimulator.Spins\nMCMRSimulator.Evolve\nMCMRSimulator.Relax\nMCMRSimulator.Properties\nMCMRSimulator.Plot\nMCMRSimulator.Subsets\nMCMRSimulator.SequenceParts\nMCMRSimulator.Simulations\nMCMRSimulator.TimeSteps\nMCMRSimulator.CLI\nMCMRSimulator.CLI.Geometry\nMCMRSimulator.CLI.Run\nMCMRSimulator.Geometries\nMCMRSimulator.Geometries.User\nMCMRSimulator.Geometries.User.Obstructions\nMCMRSimulator.Geometries.User.Obstructions.Fields\nMCMRSimulator.Geometries.User.Obstructions.ObstructionTypes\nMCMRSimulator.Geometries.User.Obstructions.ObstructionGroups\nMCMRSimulator.Geometries.User.RandomDistribution\nMCMRSimulator.Geometries.User.Fix\nMCMRSimulator.Geometries.User.SizeScales\nMCMRSimulator.Geometries.User.FixSusceptibility\nMCMRSimulator.Geometries.User.LoadMesh\nMCMRSimulator.Geometries.User.JSON\nMCMRSimulator.Geometries.User.ToMesh\nMCMRSimulator.Geometries.User.SplitMesh\nMCMRSimulator.Geometries.Internal\nMCMRSimulator.Geometries.Internal.Properties\nMCMRSimulator.Geometries.Internal.RayGridIntersection\nMCMRSimulator.Geometries.Internal.BoundingBoxes\nMCMRSimulator.Geometries.Internal.Intersections\nMCMRSimulator.Geometries.Internal.Obstructions\nMCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions\nMCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections\nMCMRSimulator.Geometries.Internal.Obstructions.Rounds\nMCMRSimulator.Geometries.Internal.Obstructions.Shifts\nMCMRSimulator.Geometries.Internal.Obstructions.Triangles\nMCMRSimulator.Geometries.Internal.Obstructions.Walls\nMCMRSimulator.Geometries.Internal.FixedObstructionGroups\nMCMRSimulator.Geometries.Internal.Reflections\nMCMRSimulator.Geometries.Internal.Susceptibility\nMCMRSimulator.Geometries.Internal.Susceptibility.Base\nMCMRSimulator.Geometries.Internal.Susceptibility.Cylinder\nMCMRSimulator.Geometries.Internal.Susceptibility.Triangle\nMCMRSimulator.Geometries.Internal.Susceptibility.Annulus\nMCMRSimulator.Geometries.Internal.Susceptibility.Grid\nMCMRSimulator.Geometries.Internal.HitGrids","category":"page"},{"location":"api/#MCMRSimulator.MCMRSimulator","page":"API","title":"MCMRSimulator.MCMRSimulator","text":"This package supports the running of MR Monte Carlo simulations.\n\nIn these simulations hundreds of thousands or millions of Spin particles randomly diffuse through some tissue microstructure. At each timepoint these spins are represented as a Snapshot object. The spin diffusion is constrained by an ObstructionGroup (represented internally as FixedGeometry) The spins of these particles will be evolved based on the Bloch equations with the field strength and relaxation rates set by the local geometry and the effect of one or more MRIBuilder.Sequence objects. All these variables are combined into a single Simulation object.  See Simulation for how to run the simulation.\n\nPlotting support for the sequence and resulting signal is also available based on Makie.jl.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Constants","page":"API","title":"MCMRSimulator.Constants","text":"Defines biophysical constants used in simulator.\n\ngyromagnetic_ratio\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Methods","page":"API","title":"MCMRSimulator.Methods","text":"Defines methods shared across multiple sub-modules.\n\nget_time\nnorm_angle\nMCMRSimulator.get_rotation\noff_resonance\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Spins","page":"API","title":"MCMRSimulator.Spins","text":"Types:\n\nSnapshot\nSpin\nSpinOrientation\nFixedXoshiro\n\nMethods:\n\nlongitudinal\ntransverse\nphase\norientation\nisinside\nstuck\nstuck_to\nget_sequence\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Evolve","page":"API","title":"MCMRSimulator.Evolve","text":"Defines the functions that run the actual simulation:\n\nreadout: get total signal or Snapshot at any MRIBuilder.ADC objects in the sequences.\nevolve: Return a single Snapshot with the state of the simulation at a given time. This snapshot can be used as initialisation for further runs.\n\nAll of these functions call evolve_to_time under the hood to actually run the simulation.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Relax","page":"API","title":"MCMRSimulator.Relax","text":"Implements the Bloch equations to model the spin magnetisation under influence of a sequence during a single timestep.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Properties","page":"API","title":"MCMRSimulator.Properties","text":"Basic interface for setting the simulation properties\n\nFor the main interface see Simulation.\n\nTypes:\n\nMCMRSimulator.GlobalProperties\n\nMethods:\n\nR1\nR2\noff_resonance\nstick_probability\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Plot","page":"API","title":"MCMRSimulator.Plot","text":"This module contains the base plotting functions.\n\nIf Makie is not installed, none of the plotting functions will work. If a Makie backend is installed and importend, concrete methods will be added to these functions by the MakieMCMRSimulator extension. This makes Makie an optional dependency of MCMRSimulator, which will only be required if you want to use the MCMRSimulator plotting capabilities.\n\nIn addition to these empty plotting functions, this module defines the PlotPlane for any 2D-projections and helper functions to project onto this plane.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Subsets","page":"API","title":"MCMRSimulator.Subsets","text":"Support for selecting a subset of the total signal.\n\nTypes:\n\nSubset\n\nFunctions:\n\nget_subset\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.SequenceParts","page":"API","title":"MCMRSimulator.SequenceParts","text":"Breaks up one or more MRIBuilder.Sequence objects into individual timesteps.\n\nThe main interface is by calling iter_parts, which will result into a vector of some subtypes of SequencePart.\n\nTo just get the readouts call MCMRSimulator.get_readouts.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Simulations","page":"API","title":"MCMRSimulator.Simulations","text":"Defines the main Simulation object.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.TimeSteps","page":"API","title":"MCMRSimulator.TimeSteps","text":"Defines the main interface to set the TimeStep of the simulator.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.CLI","page":"API","title":"MCMRSimulator.CLI","text":"Defines the command line interface to MCMRSimulator.jl (mcmr).\n\nFunctions:\n\nMCMRSimulator.run_main\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.CLI.Geometry","page":"API","title":"MCMRSimulator.CLI.Geometry","text":"Defines command line interface for mcmr geometry\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.CLI.Run","page":"API","title":"MCMRSimulator.CLI.Run","text":"Defines the command line interface to mcmr run.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries","page":"API","title":"MCMRSimulator.Geometries","text":"Defines the microstructural environment with which the spins interact.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User","page":"API","title":"MCMRSimulator.Geometries.User","text":"User interface for defining geometry.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions","text":"Defines the types and main methods for user-defined geometries.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Fields","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Fields","text":"Defines a flexible Field interface to set the properties of user-defined geometries.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.ObstructionTypes","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.ObstructionTypes","text":"Defines the properties of a certain geometry type.\n\nTypes:\n\nObstructionType\n\nFunctions:\n\nfields\nkey_value_pairs\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups","text":"Defines ObstructionGroup, which is the parent type of all user-defined geometries.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.RandomDistribution","page":"API","title":"MCMRSimulator.Geometries.User.RandomDistribution","text":"Defines random_positions_radii.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.Fix","page":"API","title":"MCMRSimulator.Geometries.User.Fix","text":"Defines MCMRSimulator.fix.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.SizeScales","page":"API","title":"MCMRSimulator.Geometries.User.SizeScales","text":"Computes a default value for the size scale of different geometries used for timestep calculations.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.FixSusceptibility","page":"API","title":"MCMRSimulator.Geometries.User.FixSusceptibility","text":"Defines MCMRSimulator.fix_susceptibility.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.LoadMesh","page":"API","title":"MCMRSimulator.Geometries.User.LoadMesh","text":"Defines load_mesh.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.JSON","page":"API","title":"MCMRSimulator.Geometries.User.JSON","text":"Supports I/O to and from json\n\nFunctions:\n\nwrite_geometry\nread_geometry\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.ToMesh","page":"API","title":"MCMRSimulator.Geometries.User.ToMesh","text":"Methods that extend the Mesh constructor to convert different types into meshes.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.SplitMesh","page":"API","title":"MCMRSimulator.Geometries.User.SplitMesh","text":"Mesh-specific operations to normalise (i.e., ensure normals point outwards) and split a mesh.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal","page":"API","title":"MCMRSimulator.Geometries.Internal","text":"Internal representation of the tissue geometry.\n\nAll objects are immutable and optimised for both memory usage and computational speed.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Properties","page":"API","title":"MCMRSimulator.Geometries.Internal.Properties","text":"Methods to extract properties from the FixedGeometry.\n\nMRI properties (using MRIProperties):\n\nR1\nR2\noff_resonance\n\nCollision properties:\n\npermeability\nsurface_relaxation\nsurface_density\ndwell_time\n\nOther functions:\n\nmax_timestep_sticking\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.RayGridIntersection","page":"API","title":"MCMRSimulator.Geometries.Internal.RayGridIntersection","text":"Defines ray_grid_intersections, which computes the intersections between a spin path and some grid.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.BoundingBoxes","page":"API","title":"MCMRSimulator.Geometries.Internal.BoundingBoxes","text":"Defines the bounding box and its interface.\n\nTypes:\n\nBoundingBox: N-dimensional box fully containing an obstruction.\n\nFunctions\n\nMCMRSimulator.isinside: returns whether point/spin is inside a bounding box (or other obstruction)\ncould_intersect: returns whether spin trajectory could intersect with obstruction in bounding box\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Intersections","page":"API","title":"MCMRSimulator.Geometries.Internal.Intersections","text":"Defines the Intersection between a spin path and the geometry.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions","text":"Defines all the base obstructions supported by MCMRSimulator.\n\nThey are all sub-types of FixedObstruction.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions","text":"Base types for the API with individually fixed obstructions.\n\nTypes:\n\nFixedObstruction\n\nMethods:\n\ndetect_intersection\nhas_inside\nisinside\nradius\nBoundingBox\nobstruction_type\nrandom_surface_positions\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections","text":"Defines the intersection between a spin path and an obstruction.\n\nTypes:\n\nObstructionIntersection\n\nAttributes:\n\nempty_obstruction_intersections\n\nMethods:\n\nhas_intersection\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.Rounds","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.Rounds","text":"Defines cylinders and spheres and how to intersect with them.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.Shifts","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.Shifts","text":"All base obstructions are assumed to be centered on the origin (except for triangles in the mesh).\n\nThis module defines the Shift from this origin to the actual position in space.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.Triangles","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.Triangles","text":"Triangle within a mesh and how to intersect with them.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.Walls","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.Walls","text":"Infinite walls and how to intersect with them.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.FixedObstructionGroups","page":"API","title":"MCMRSimulator.Geometries.Internal.FixedObstructionGroups","text":"Defines the fixed versions of MCMRSimulator.ObstructionGroup and its methods (including intersection detection).\n\nTypes:\n\nMCMRSimulator.FixedGeometry\nMCMRSimulator.FixedObstructionGroup\n\nMethods:\n\nhas_inside\nisinside\ndetect_intersection\nsize_scale\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Reflections","page":"API","title":"MCMRSimulator.Geometries.Internal.Reflections","text":"Computes the reflection of the spin off some geometry.\n\nThis is also used internally to represent a bound spin.\n\nTypes:\n\nReflection\n\nMethods:\n\ndirection\nhas_hit\nprevious_hit\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility","text":"Base module for computing the off-resonance field from magnetic susceptibility sources.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Base","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Base","text":"Defines parent type and functions for all magnetic susceptibility sources.\n\nTypes:\n\nBaseSusceptibility\n\nFunctions:\n\nsingle_susceptibility\nsingle_susceptibility_gradient\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Cylinder","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Cylinder","text":"Off-resonance field due to magnetic susceptibility of an hollow cylinder, which is approximated as being infinitely thin.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Triangle","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Triangle","text":"Computes the off-resonance field produced by a triangular mesh.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Annulus","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Annulus","text":"Off-resonance field due to magnetic susceptibility of an hollow cylinder.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Grid","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Grid","text":"Defines how to compute the off-resonance field for distant magnetic susceptibility sources.\n\nThe contribution from very distant sources are pre-computed on a SusceptibilityGrid. Intermediate sources are represented as point magnetic susceptibility elements (SusceptibilityGridElement).\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.HitGrids","page":"API","title":"MCMRSimulator.Geometries.Internal.HitGrids","text":"Defines a HitGrid used to precompute the locations of each obstruction within a grid.\n\nThis helps limit the number of intersection calculations required for each spin movement.\n\n\n\n\n\n","category":"module"},{"location":"geometry/#geometry","page":"Geometry","title":"Obstructions to free diffusion","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"MCMRSimulator.jl comes with a variety of basic components that can be used to represent various components in the tissue microstructure.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Component: infinite walls hollow cylinder myelinated annuli hollow sphere mesh bendy cylinder\nConstructor (Julia) Walls Cylinders Annuli Spheres Mesh BendyCylinder\nConstructor (CLI) mcmr geometry create walls mcmr geometry create cylinders or mcmr geometry create-random cylinders mcmr geometry create annuli or mcmr geometry create-random annuli mcmr geometry create spheres or mcmr geometry create-random spheres Generate mesh from tissue samples or generative models (e.g., (Palombo et al., 2019), (Ginsburger et al., 2019), (Callaghan et al., 2020), (Villarreal-Haro et al., 2023)) mcmr geometry create bendy-cylinder\nHinder diffusion ✅ ✅  ✅ ✅ ✅\nSurface relaxation ✅ ✅  ✅ ✅ ✅\nMagnetisation transfer ✅ ✅  ✅ ✅ ✅\nGenerate off-resonance field  ✅ ✅  ✅ ✅\nDifferent relaxation inside  ✅ ✅ ✅ ✅ ✅\nIntrinsic dimensionality 1 2 2 3 3 3","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"The constructors for these components all have a similar interface. Some expect certain component-specific keyword arguments (e.g., radius for Spheres and Cylinders, or the keywords regarding the myelin-induced off-resonance field produced by Cylinders or Annuli). MRI relaxation properties within the obstruction and collision parameters (stuck spins, magnetisation transfer rate & permeability) can be set using keyword arguments as described in the properties section. Finally, these constructors expect a set of keyword arguments that control their location. These arguments are identicaly across all constructors (although the expected input depends on the dimensionality of the component as listed in the table above):","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"position: Set the positions for each generated components (not used in Mesh).\nrepeats: Set the distance with which all components should be repeated.\nrotation: Applies a single rotation to the whole system.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Components with a lower dimensionality are defined by default along the x-axis (for dimensionality of 1) or the x-y plane (for dimensionality of 2).  In other words, the normal of the Walls point in the x-axis by default, while the Cylinders point in the z-axis. Shifts and repeats should only be provided in this lower-dimensional space. The rotation keyword can be used to define these components along other lines/planes (see MCMRSimulator.get_rotation).","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"warning: Warning\nThis repeating geometry means that a spin leaving the geometry at the top of the bounding box, will next see the geometry at the bottom of the bounding box. For this to make sense any geometries going beyond the top of the bounding box should continue at the bottom of the bounding box. Future versions of MCMRSimulator will allow spins to continue in a flipped version of the geometry, which ensures that any geometries crossing the bounding box boundary are continuous (see tracking issue).","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"From the command line all of these keywords are available as flags, which can be seen by running:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"mcmr geometry create walls/cylinders/annuli/spheres/bendy_cylinder --help","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"In Julia, the easiest way to get the documentation for all keywords is to run:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"?Walls/Cylinders/Annuli/Spheres/Mesh/BendyCylinder","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"or by following the links in the table above.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"For example, we can create two base cylinders, which repeat infinitely by running:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"using MCMRSimulator\ngeometry = Cylinders(radius=sqrt(0.5), position=[[0, 0], [1, 1]], repeats=[2, 2])\nusing CairoMakie # hide\nf = plot(PlotPlane(size=4), geometry) # hide\nsave(\"regular_cylinders.png\", f) # hide\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"(Image: Plot showing two cylinders repeating ad infinitum)","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Alternatively, the same configuration could be produced with a single cylinder by providing a rotation.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"using MCMRSimulator\nrotation = [\n    sqrt(0.5) sqrt(0.5) 0.\n    -sqrt(0.5) sqrt(0.5) 0.\n    0. 0. 1.\n    ]\ngeometry = Cylinders(radius=sqrt(0.5), repeats=[sqrt(2), sqrt(2)], rotation=rotation)\nusing CairoMakie # hide\nf = plot(PlotPlane(size=4), geometry) # hide\nsave(\"regular_cylinders2.png\", f) # hide\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"(Image: Plot showing single cylinders repeating ad infinitum)","category":"page"},{"location":"geometry/#Randomly-distributed-cylinders/annuli/spirals","page":"Geometry","title":"Randomly distributed cylinders/annuli/spirals","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"A random set of positions and radii can be created using random_positions_radii. The user in this case sets a target density (70% in the example below) and over which length scale the configuration should repeat itself (20x20 micrometer in the example below).","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"using MCMRSimulator # hide\nusing Random; Random.seed!(1234) # hide\n(positions, outer_radii) = random_positions_radii((20, 20), 0.7, 2)\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"From the command line this functionality is available by running mcmr geometry create-random cylinders/annuli/spheres.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"These can be used to produce randomly distributed cylinders:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"geometry = Cylinders(radius=outer_radii, position=positions, repeats=(20, 20))\nusing CairoMakie # hide\nf = plot(PlotPlane(size=20), geometry) # hide\nsave(\"random_cylinders.png\", f) # hide\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"(Image: Illustrating configuration of random cylinders)","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"When used as initialisation for annuli or spirals, an inner radius will also need to be computed:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"geometry = Annuli(inner=0.8 .* outer_radii, outer=outer_radii, position=positions, repeats=(20, 20))\nusing CairoMakie # hide\nf = plot(PlotPlane(size=20), geometry) # hide\nsave(\"random_annuli.png\", f) # hide\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"(Image: Illustrating configuration of random annuli)","category":"page"},{"location":"tutorial_cli/#tutorial_cli","page":"Tutorial (CLI)","title":"Tutorial","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"This tutorial will walk through an example of modelling the MRI signal evolution for a diffusion-weighted sequence. The spins in this simulation will be constrained by regularly packed cylinders. This tutorial will use the command line interface, which we assume is available through the mcmr command (see installation instructions). If you would prefer to interact with MCMRSimulator in Julia, you can find a tutorial doing the same analysis here.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The command line tool requires one or more MRI sequence definitions as input. These can be supplied as pulseq files, such as those produced by MRIBuilder.jl.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"In general, running a simulation will consist of the following two steps:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"Creating a geometry using one or more calls to mcmr geometry (full description).\nRunning the actual simulation using mcmr run.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We will look through each of these steps below.","category":"page"},{"location":"tutorial_cli/#Defining-the-geometry","page":"Tutorial (CLI)","title":"Defining the geometry","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"First we will define a geometry formed of regularly packed axons. This is represented by a single cylinder pointing in the z-direction with a radius of 1 micrometer that repeats itself every 2.5 micrometer (in both the x-, and y-direction).","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr geometry create cylinders 1 geometry.json --radius 1 --repeats 2.5,2.5","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"geometry create cylinders 1 geometry.json --radius 1 --repeats 2.5,2.5\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"This will create a JSON file with the full information on the geometry:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\ntext = read(\"geometry.json\", String)\nMarkdown.parse(\"```json\\n$(text)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"You can see how that the repeats and radius keywords have been set to our predefined values. You can alter these and other geometry properties by editing this JSON directly or using the flags when creating the geometry. For a full overview of these flags, you can run:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr geometry create cylinders --help","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"geometry create cylinders --help\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"How these various properties affect the simulation is described here.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The procedure to create Walls, Spheres, or Annuli is very similar as for the Cylinders illustrated above. Randomly distributed cylinders, annuli, and spheres can be created using mcmr geometry create-random.","category":"page"},{"location":"tutorial_cli/#Defining-the-sequence","page":"Tutorial (CLI)","title":"Defining the sequence","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"In this case we will use an idealised DWI sequence produced by MRIBuilder.jl. Note that any pulseq file can be used instead.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"using MRIBuilder\nseq = DWI(TE=80, bval=2., Δ=40, δ=:min, TR=2000)\nwrite_sequence(\"dwi.seq\", seq)\n\n# Optional to plot the sequence\nusing CairoMakie\nf = plot_sequence(seq)\nf\nsave(\"tutorial_cli_sequence.png\", f); # hide\nnothing # hide","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"(Image: )","category":"page"},{"location":"tutorial_cli/#Running-the-simulation","page":"Tutorial (CLI)","title":"Running the simulation","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"To get instructions on running the simulations, we can check the help message of mcmr run:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run --help","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run --help\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We can see that in addition to defining the geometry and the sequence, we can also control the simulation properties such as the --diffusivity, --R1, and --R2.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The simulation is initialised by randomly distributing a number of spins (set by --Nspins) uniformly across a bounding box with size given by --voxel-size. This initial state might also contain bound spins (if the --density flag was set to a non-zero value during the geometry generation).","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The DWI sequence defined above contains a MRIBuilder.SingleReadout object at the echo time (80 ms). By default, this is used for readout:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run geometry.json dwi.seq -o signal.csv","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run geometry.json dwi.seq -o signal.csv --seed=1\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"This produces the CSV file, which looks like","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\ntext = read(\"signal.csv\", String)\nMarkdown.parse(\"```\\n$(text)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The columns in this file store the following information:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"\"sequence\": integer; index of the sequence (always 1 if only single sequence used)\n\"bvec\": integer; index of the gradient orientation (if a --bvec flag is provided)\n\"TR\": integer; index of the repetition time that this data was acquired (between 1 and the value of --nTR)\n\"readout\": integer; index of the readout within a TR.\n\"subset\": integer; index of the subset of the total signal (e.g., intra-axonal) that has been output (see the --subset flag). The total signal will always be included with \"subset\" of 0.\n\"nspins\": total number of spins contributing to the signal (might change for certain subsets of spins)\n\"longitudinal\": average longitudinal signal\n\"transverse\": average transverse signal\n\"phase\": average phase of the signal (in degrees)\n\"Sx\": signal strength in the x-direction\n\"Sy\": signal strength in the y-direction","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We can also output the signal of specific subsets of spins. For example, in the following we request to separately the output for just the spins inside the cylinders and just the spins outside of the cylinders.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run geometry.json dwi.seq -o signal.csv --subset inside --subset outside","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run geometry.json dwi.seq -o signal2.csv --subset inside --subset outside --seed=2\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We can see two additional rows in the output.  These new rows are the in same order as the --subset flags provided to mcmr run and can be distinguished based on the \"subset\" column.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\ntext = read(\"signal2.csv\", String)\nMarkdown.parse(\"```\\n$(text)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We can see in the second row that inside the cylinders the transverse signal is very close to the number of spins,  indicating that there has been very little dephasing due to the diffusion weighting inside the cylinders. On the other hand, we did lose most of the signal outside of the cylinders (i.e., the transverse signal is much lower than the number of spins in the third row). All the spins are either inside or outside the cylinders, so in this case the first row is simply the sum of the next two.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"A more complete state of all the spins can be produced using the --output-snapshot flag. For example, the command","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run geometry.json dwi.seq --output-snapshot snapshot.csv","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run geometry.json dwi.seq --output-snapshot snapshot.csv --seed=3\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"will produce a file named \"snapshot.csv\" with:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\nlines = split(read(\"snapshot.csv\", String), '\\n')\ntext = join(lines[1:5], '\\n')\nMarkdown.parse(\"```csv\\n$(text)\\n...\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"Each row corresponds to the state of a single spin. In addition to all the columns listed above, we now have 4 more columns:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"\"spin\": integer; index of the spin\n\"x\"/\"y\"/\"z\": floats; position of the spin at the time of the readout","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The readout times can be adjusted using the --nTR, --time, and --skip-TR flags.","category":"page"},{"location":"properties/#properties","page":"MRI/collision properties","title":"Simulation properties","text":"","category":"section"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"How the spins behave is determined by the tissue geometry, the applied MRI sequences, and user-provided flags determining how the spin magnetisation evolves. Here we discuss how the spin magnetisation evolution can be affected by these user-provided flags.","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"For example, one such flag is the diffusivity, which can be set as a keyword argument while generating the Simulation.","category":"page"},{"location":"properties/#MRI-properties","page":"MRI/collision properties","title":"MRI properties","text":"","category":"section"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"MRI properties determine the spin evolution for free and stuck particles. They include:","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"the longitudinal relaxation rate R1\nthe transverse relaxation rate R2\nthe global off_resonance field (i.e., any off-resonance not caused by the sequence or the geometry)","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"At the Simulation level these parameters can be set by supplying the R1, R2, or off_resonance flags (see MCMRSimulator.GlobalProperties), such as:","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"simulation = Simulation(sequences, R2=1/80)","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"These MRI properties can be locally altered when defining the geometry. In the geometry they can be seperately set for spins stuck to the geometry surface or those spins that are inside specific objects in the geometry. The total relaxation rate (and off-resonance field) is set by the sum of the global value, the value set for any surface the spin is stuck to, and the value set for any obstruction that the spin is inside of. A single spin might be inside of multiple obstructions at once, if they overlap. In that case, all of the overlapping compartments will be considered. For the off-resonance field there might also be a contribution of the magnetic suscpetibility of any Cylinders, Annuli, or Mesh.","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"If not set at the global or local level, there will be no longitudinal or transverse relaxation and there will be no off-resonance field.","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"From the command line interface, the global parameters are set during the mcmr run command using --diffusivity, --R1, and --R2 keywords. Local parameters will already have been set at an earlier stage during the creation of the geometry using mcmr geometry create/create-random.","category":"page"},{"location":"properties/#Collision-properties","page":"MRI/collision properties","title":"Collision properties","text":"","category":"section"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"Collision properties determine the behaviour of spins at the time of a collision. Like MRI properties they can be set at the global level (while creating Simulation) or overwritten at the local level (geometry). There are four such properties:","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"MCMRSimulator.surface_relaxation: the rate with which transverse signal is lost at every collision. This rate is multiplied by the square root of the timestep to ensure the actual attenuation is timestep-indeptendent.\nMCMRSimulator.permeability: the rate of spins passing through the surface (arbitrary units). Set to infinity for a purely permeable surface and to zero for an impermeable surface (default). If the spins do not pass through, they will undergo regular reflection (or get stuck, see below). Like MT_fraction it will be adjusted to take into account the timestep.\nMCMRSimulator.surface_density and MCMRSimulator.dwell_time: These control the density and dwell time of spins on the surface. Depending on the MRI properties assigned to these stuck particles (see above), these stuck particles can be used to represent water stuck at the membranes due to surface tension or spins in the membrane itself (which is in exchange with the free water through magnetisation transfer).","category":"page"},{"location":"installation/#installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"MCMRSimulator is an application written in the Julia language. You can run simulations either directly from the Julia REPL, in a Jupyter notebook, or using the command line interface.","category":"page"},{"location":"installation/#Installing-the-simulator-for-a-specific-project","page":"Installation","title":"Installing the simulator for a specific project","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"First install julia 1.11 from the official website. Make sure to install julia 1.11. Julia 1.12 is not supported yet.\nCreate a directory for the project for which you are going to use the simulator. We will install MCMRSimulator in isolation just for this project. This ensures that if we install a newer version of the simulator for another project in the future, it will not interfere with the reproducibility of the results of this project. We will refer to this newly created project directory below as \"<project_dir>\".\nStart the julia REPL in a terminal ($ julia --project=<project_dir>). The --project flag ensures that we create and activate a Julia environemnt just for this project. This will create a \"Project.toml\" and \"Manifest.toml\" inside the directory specifying the installed packages (such as the MCMR simulator).\nEnter the package manager by pressing \"]\"\nFirst install the required MRIBuilder.jl using pkg> add https://git.fmrib.ox.ac.uk/ndcn0236/mribuilder.jl.git.\nThen install MCMRSimulator.jl using pkg> add https://git.fmrib.ox.ac.uk/ndcn0236/mcmrsimulator.jl.git.\n(Optional) Install one of the Makie backends for plotting (e.g., pkg> add CairoMakie).\n(Optional) If you want to use a Jupyter notebook for this project, you will also have to install an IJulia kernel. You can find instructions to do so below.\nPress \"[backspace]\" to leave the package manager.\n(Optional) To install the MCMRSimulator command line interface (CLI) run the following in the main julia REPL: using MCMRSimulator; MCMRSimulator.install_cli(destdir=\"...\"), where destdir is the target directory for the executable (called mcmr by default). Ensure that the destdir is a directory that is in your PATH variable.","category":"page"},{"location":"installation/#Running-MCMRSimulator","page":"Installation","title":"Running MCMRSimulator","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"After this installation process, you can run MCMRSimulator in one of the following ways:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia REPL: Start the REPL in a terminal by typing $ julia --project=<project_dir>. Afterwards type using MCMRSimulator to import the simulator. You can now follow the steps in the MCMRSimulator tutorial using Julia.\nJupyter notebook: Make sure that you install IJulia using the instructions below. This will allow you to start a notebook in jupyter running in Julia. Within this notebook, you can follow the steps in the MCMRSimulator tutorial using Julia.\nCommand line interface: If you followed the instructions in step 4 above, you can run the MCMRSimulator command line interface simply by typing mcmr in the terminal. If it is not working, you might want to redo step 4 above and pay attention to any warning messages. With this alias set up, you can now follow the command line tutorial.","category":"page"},{"location":"installation/#Updating-MCMRSimulator","page":"Installation","title":"Updating MCMRSimulator","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"First check the CHANGELOG to find a list of changes since your current version. If you decide to update:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Start the julia REPL again in a terminal ($ julia --project=<project_dir>)\nEnter the package manager by pressing \"]\"\nUpdate all installed packages using by typing update and pressing enter (pkg> update).","category":"page"},{"location":"installation/#Sharing-your-MCMRSimulator-installation","page":"Installation","title":"Sharing your MCMRSimulator installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To share the exact environment used by your installation of MCMRSimulator, simply go to the <project_dir> directory and locate the files named \"Project.toml\" and \"Manifest.toml\". Transfer these files to any other computer, to ensure that they install the exact same version of all Julia packages used (see https://pkgdocs.julialang.org/v1/environments/ for more details).","category":"page"},{"location":"installation/#jupyter_install","page":"Installation","title":"Running MCMRSimulator in a Jupyter notebook","text":"","category":"section"},{"location":"installation/#Installing-the-Julia-kernel","page":"Installation","title":"Installing the Julia kernel","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"You only have to run the following once:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e \"import Pkg; Pkg.add(\\\"IJulia\\\"); Pkg.build(\\\"IJulia\\\")\" ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"This line installs and builds IJulia in the main, global environment. This will create a new jupyter kernel just for Julia. This global environment is available within any local environments, so we only have to do this once across any number of Julia projects.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To test whether this has worked, start a Jupyter notebook (or Jupyter lab). If you have FSL installed, you can do so using fslpython -m notebook. Within the Jupyter notebook interface press \"New\". The Julia kernel should show up here with its version number. (Image: )","category":"page"},{"location":"installation/#Using-the-simulator-with-this-Julia-kernel","page":"Installation","title":"Using the simulator with this Julia kernel","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you followed the steps in the previous section, the Julia kernel will be installed in its own environment separate from the simulator. To use the simulator using this kernel, we simply start a notebook and then switch to an environment that has the MCMR simulator installed (i.e., created as described above). You can do this by including a block at the top of the notebook with the following code:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.activate(\"<project dir>\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"where \"<project_dir>\" is the directory where we installed the simulator.","category":"page"},{"location":"tutorial_julia/#tutorial_julia","page":"Tutorial (Julia)","title":"Tutorial","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"This tutorial will walk through an example of modelling the MRI signal evolution for a diffusion-weighted sequence. The spins in this simulation will be constrained by regularly packed cylinders. This tutorial will use the programatic Julia interface, which you can run in the Julia REPL or in a Jupyter notebook. If you would prefer to use the command line interface, you can find a tutorial doing the same analysis here.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"After installation we can load MCMRSimulator.jl using","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"using MCMRSimulator\nusing CairoMakie  # used for plotting; use GLMakie or WGLMakie for interactive plots\nupdate_theme!(Theme(Axis=(xgridvisible=false, ygridvisible=false))) # hide grid lines","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"In general, running a simulation will consist of the following three steps:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Defining the microstructure and one or more sequences by creating an appropriate Simulation object.\nInitialising Snapshot with one or more Spin objects.\nSimulating a random walk of the spins through the microstructure and the MR signal produced by those spins.\nPlotting the MR signal or storing it to disk.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"We will look through each of these steps below.","category":"page"},{"location":"tutorial_julia/#Defining-the-simulation","page":"Tutorial (Julia)","title":"Defining the simulation","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The first step is to define the environment through which the spins will evolve. We will do so by creating an appropriate Simulation object. This Simulation will contain information on the microstructure, how spins interact with that microstructure, and the enabled sequence(s).","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"These different steps are described in more detail in other sections of this documentation:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"How to define the microstrutural geometry\nControlling spin behaviour","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"For a discussion on sequence generation see MRIBuilder.jl.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"First we will define a geometry formed of regularly packed axons. This is represented by a single cylinder with a radius of 1 micrometer that repeats itself every 2.5 micrometer (in both the x-, and y-direction).","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"import Random; Random.seed!(1) # hide\ngeometry = Cylinders(radius=1., repeats=[2.5, 2.5])\n\nf = plot(PlotPlane(size=5), geometry)\nxlims!(f.axis, -2.5, 2.5)\nylims!(f.axis, -2.5, 2.5)\nf\nsave(\"tutorial_geometry.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"More complicated geometries can be generated as described here. More details on plotting geometries can be found in the plot_geometry documentation.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The next step is to define a sequence using MRIBuilder.jl.  Here we will adopt a single diffusion-weighted MRI sequence.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"using MRIBuilder\nsequence = DWI(bval=2., TE=80, TR=300, scanner=Siemens_Prisma)\nf = plot_sequence(sequence)\nf\nsave(\"tutorial_sequence.png\", f); # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Once we have both a geometry and one or more sequences, we can put them together in a Simulation object:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"simulation = Simulation(sequence, R2=0.012, R1=3e-3, diffusivity=2., off_resonance=0.1, geometry=geometry)\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"By default there is no T1 or T2 relaxation and a diffusivity of 3 um^2/ms. Enabling spin relaxation and diffusion requires setting the appropriate parameters in the Simulation as seen here. The spin relaxation rates can be different in different compartments as described here.","category":"page"},{"location":"tutorial_julia/#Initialising-the-simulation","page":"Tutorial (Julia)","title":"Initialising the simulation","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The current state of the simulation at any time is given by a Snapshot object. This is essentially a vector of Spin objects with a time stamp. Each Spin represents a single diffusing particle. Besides containing its current position, it also contains its contribution to the MR signal for each of the sequences in the simulation and whether it is stuck on any surfaces.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The recommended way to initialise is to call Snapshot(<number of spins>, <simulation>, [bounding_box]). This will create randomly distributed spins within some BoundingBox. By default this bounding box is an isotropic voxel with a size of 1 mm centered on the origin.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"After initialisation or after running the simulation, the Snapshot can be later filtered to include only spins inside/outside specific compartments or only include free/bound spins using [get_subset].","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The simulation can also be initialised explicitly using a sequence of positions (i.e., length-3 vectors) with the initial spin positions.  Note that such a simulation will start with all spins free and not necessarily randomly distributed, which means it might take some time to reach an equilibrium.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"For each of these initialisations the initial magnetisation can be explicitly set using the transverse, longitudinal, and phase flags. The default is for spins to start in equilibrium (i.e., transverse magnetisation of 0 and longitudinal magnetisation of 1).","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Finally, one could start a simulation using a Snapshot from a previous simulation.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"note: Deterministic spins\nEach Spin is assigned a random number state at creation, which will be used for its future evolution. This means that after creation of a spin or a Snapshot its future is fully determined. This ensures that when a spin is evolved through the same simulation multiple times, it sill follow the same path each time. This allows improved comparisons between simulations with the same geometry, but different sequences/physics. However, it can lead to confusing results (e.g., a simulation initialised with fill(Spin(), 500) will contain 500 spins all following the exact same path).","category":"page"},{"location":"tutorial_julia/#Running-the-simulation","page":"Tutorial (Julia)","title":"Running the simulation","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The main way to run a simulation is by calling readout. This function takes a Snapshot and a Simulation as input (or a number of spins, which will be used to generate a new Snapshot on the fly). There are various ways to define when the output will be read out (as described in the readout documentation).","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Here, we will illustrate various examples of using this function:","category":"page"},{"location":"tutorial_julia/#Simple-signal-readouts","page":"Tutorial (Julia)","title":"Simple signal readouts","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Most sequences will contain one or more MRIBuilder.SingleReadout or MRIBuilder.ADC objects, which define when the sequence will be read out during each repetition time (TR). To get the signal at this time, we can simply call:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"readout(1000, simulation)","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"This signal is not truely representative from what we expect in a true diffusion-weighted MRI sequence, because the longitudinal signal has not had a chance to relax across multiple repetition times. To see what the signal will look like after such equilibriation, we can delay our readout with several TRs:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"readout(1000, simulation, skip_TR=2)","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"In addition, to the total signal, we can also get the signal associated with individual compartments:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"readout(1000, simulation, subset=[Subset(inside=true), Subset(inside=false)])","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Note that we now get two signal outputs. The first respresents the signal within the cylinders, which is very close to number of spins,  indicating that there has been very little dephasing due to the diffusion weighting inside the cylinders. On the other hand, we did lose most of the signal outside of the cylinders. All the spins are either inside or outside the cylinders, so in this case the first row is simply the sum of the next two.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Instead of just running the simulation for multiple TRs without readouts,  we could also visualise the equilibriation process by outputting the signal for multiple TRs:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"signals = readout(1000, simulation, nTR=6)\nf = lines(longitudinal.(signals))\nlines!(transverse.(signals))\nf\nsave(\"tutorial_equil.png\") # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"At each timepoint readout by default will return the total MR signal (for each sequence) as a MCMRSimulator.SpinOrientationSum object. From this one can estimate the transverse component, the longitudinal component, and the phase. The longitudinal and transverse functions are used above to get those respective components.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"We can also override, when the signal will be read out, by passing on the readout times as a third argument to readout. Here we use this to plot the actual transverse signal evolution.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"times = 0:0.1:100\n# simulate 3000 spins for a single repetition time\naverage_signals = readout(3000, simulation, times)\nf = lines(times, transverse.(average_signals)/3000.)\nsave(\"tutorial_transverse.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"tutorial_julia/#Reading-out-the-full-snapshot","page":"Tutorial (Julia)","title":"Reading out the full snapshot","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Instead of returning just the total signal readout can also return the full spin state in a Snapshot object by setting the return_snapshot keyword to true. Note that this is very memory intensive, so is only recommended when you only output a small number of timepoints or a small number of spins.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Here, we use this to visualise the trajectory of spins through the geometry. To plot the trajectory we first need to output the state of the all spins at a high temporal resolution:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"# Simulate 2 spins with given starting positions for 3 ms\nsnapshots = readout([[0, 0, 0], [1, 1, 0]], simulation, 0:0.01:3., return_snapshot=true)\n\npp = PlotPlane(size=5.)\nf = plot(pp, geometry)\nplot(pp, snapshots)\nf\nsave(\"tutorial_trajectory2D.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: ) In this plot the color at each timepoint encodes the spin orientation. The brightness of the spin indicates the size of the transverse component with purely longitudinal spins being in black. The color of the spin encodes the phase of the MR signal in the transverse plane.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The trajectories can also be plotted in 3D:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"f = plot(snapshots)\nsave(\"tutorial_trajectory3D.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: ) More details on plotting trajectories can be found in the plot_trajectory documentation.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"We can also use this future to plot the complete Snapshot at a specific time.  In this example we do not set this time explicitly, so it will default to the time of the sequence MRIBuilder.SingleReadout/MRIBuilder.ADC as discussed above:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"snapshot = readout(3000, simulation, return_snapshot=true)\npp = PlotPlane(size=2.5)\nf = plot(pp, snapshot)\nplot!(pp, geometry)\nf\nsave(\"tutorial_snapshot.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: ) We can see that the spins within the cylinder stay far more in-sync with each other (i.e., they have a more uniform colour), than those outside of the cylinder.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Note that object returned when return_snapshot=true is the same Snapshot object as was used to initialise this simulation. This means that it can be used as an initialisation for future simulations.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"One complication with this occurs when running a Simulation with multiple sequences. Often, these different sequences will readout at different times. So, each Snapshot object returned by readout will only contain the spin magnetisation of the sequence that is readout at that particular time. To get a Snapshot object with the spin states for all sequences, you can use the evolve function instead.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"More details on plotting snapshots can be found in the plot_snapshot documentation. For example, the same snapshot can also be plotted using dyads or as an image:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"f = plot(pp, snapshot, kind=:dyad)\nplot!(pp, geometry)\nf\nsave(\"tutorial_snapshot_dyad.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"f = plot(pp, snapshot, kind=:image)\nplot!(pp, geometry)\nf\nsave(\"tutorial_snapshot_image.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MCMRSimulator.jl allows simulation of MR signal generation using Monte Carlo simulations. The spin evolution of randomly diffusing particles is tracked under influence of one or more MR sequences. At present, the simulator allows to model","category":"page"},{"location":"","page":"Home","title":"Home","text":"Free diffusion and diffusion restricted by Walls, Cylinders, Spheres, and/or a triangular Mesh.\nR1 and R2 relaxation using global or local R1/R2 parameters.\nMR sequences consisting of arbitrary RF pulses, gradients, and readouts (built using MRIBuilder or read from pulseq files).\nOff-resonance magnetic field generation by myelinated cylinders or meshes.\nMagnetisation transfer between liquid spins and bound spins in membranes.\nMembrane permeability (i.e., exchange)\nSurface relaxation\nSurface tension of membranes causing spins to get temporarily \"stuck\" when they hit a membrane","category":"page"},{"location":"","page":"Home","title":"Home","text":"Future (potential) features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Macromolecular pool not bound to the membrane\nOff-resonance field by iron particles\nContribution from metabolites (i.e., spectroscopy)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We use the following units throughout (unless otherwise noted):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Times are in ms. Equivalently, RF pulse amplitudes and off-resonance magnetic fields are in kHz (i.e., 1/ms).\nPositions are in um. So, gradients are in kHz/um (not mT/m).\nAngles are in degrees (not radians). These are used for phases (of spins and RF pulses) as well as RF pulse flip angles. \nMagnetic susceptibilities are in parts per million (ppm).","category":"page"},{"location":"#How-to-get-started?","page":"Home","title":"How to get started?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If MCMRSimulator is not yet installed, follow the installation instructions.\nLook through one of the tutorials. There are two available, depending on which interface you prefer to use:\nFor the command line interface: CLI tutorial.\nFor the julia interface: Julia tutorial.\nIf you want more information on a specific topic, you can check one of the more dedicated sections:\nGeometry.\nMRI & collision properties.\nFor sequences see MRIBuilder.jl.\nFull API.","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The original simulator was written by Michiel Cottaar.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other contributors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Zhiyu Zheng","category":"page"},{"location":"#Movie-of-spins-moving-through-cylinders","page":"Home","title":"Movie of spins moving through cylinders","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<iframe src=\"https://ox.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=b6211751-2743-4bb8-b65a-af5d011a8684&autoplay=true&offerviewer=false&showtitle=false&showbrand=false&captions=false&interactivity=none\" style=\"border: 1px solid #464646;\" allowfullscreen allow=\"autoplay\"></iframe>","category":"page"}]
}
