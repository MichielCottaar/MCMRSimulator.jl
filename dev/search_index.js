var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = MCMRSimulator","category":"page"},{"location":"api/#api","page":"API","title":"MCMRSimulator.jl API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This is the API for MCMRSimulator. For a more friendly introduction, click here","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MCMRSimulator]","category":"page"},{"location":"api/#MCMRSimulator.MCMRSimulator","page":"API","title":"MCMRSimulator.MCMRSimulator","text":"This package supports the running of MR Monte Carlo simulations.\n\nIn these simulations hundreds of thousands or millions of particles randomly diffuse through some tissue microstructure constrained by a series of Obstruction objects. The spins of these particles will be evolved by the effect of one or more Sequence objects as well as spatially varying Field objecs describing the R1, R2, diffusivity, and off-resonance fields. Off-resonance fields can also be generated by the Obstruction objects themselves. All of these variables are combined into a single Simulation object.  See Simulation for how to run the simulation.\n\nPlotting support for the output is also available based on Makie.jl.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Siemens_Connectom","page":"API","title":"MCMRSimulator.Siemens_Connectom","text":"Siemens 3T Connectom MRI scanner (Qiuyun Fan, Cornelius Eichner, Maryam Afzali, Lars Mueller, Chantal M. W. Tax, Mathias Davids, Mirsad Mahmutovic, Boris Keil, Berkin Bilgic, Kawin Setsompop, Hong-Hsi Lee, Qiyuan Tian, Chiara Maffei, Gabriel {Ramos-Llord{\\'e}n}, Aapo Nummenmaa, Thomas Witzel, Anastasia Yendiki, Yi-Qiao Song, Chu-Chung Huang, Ching-Po Lin, Nikolaus Weiskopf, Alfred Anwander, Derek K. Jones, Bruce R. Rosen, Lawrence L. Wald, Susie Y. Huang (2022)).\n\n\n\n\n\n","category":"constant"},{"location":"api/#MCMRSimulator.Siemens_Prisma","page":"API","title":"MCMRSimulator.Siemens_Prisma","text":"Siemens MAGNETOM 3T Prisma MRI scanner (https://www.siemens-healthineers.com/en-uk/magnetic-resonance-imaging/3t-mri-scanner/magnetom-prisma).\n\n\n\n\n\n","category":"constant"},{"location":"api/#MCMRSimulator.Siemens_Terra","page":"API","title":"MCMRSimulator.Siemens_Terra","text":"Siemens MAGNETOM 7T Terra MRI scanner (https://www.siemens-healthineers.com/en-uk/magnetic-resonance-imaging/7t-mri-scanner/magnetom-terra)\n\n\n\n\n\n","category":"constant"},{"location":"api/#MCMRSimulator.Annulus","page":"API","title":"MCMRSimulator.Annulus","text":"Annulus(inner_radius, outer_radius; chi_I=-0.1, chi_A=-0.1, myelin=false)\n\nCreate an annulus with an inner and outer radius. Using annuli is recommended. Water can freely diffuse within the inner radius, and between the inner and outer radius, but not in between. Myelin can be added by setting myelin to true. Restrictions are only present at the inner and outer cylinder, not in the myelin in between.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.BaseObstruction","page":"API","title":"MCMRSimulator.BaseObstruction","text":"Base obstruction type hindering free diffusion.\n\nThese obstructions are always perfectly aligned with the main axes and centered at the origin (except for Mesh). They can be moved/rotated/repeated by applying TransformObstruction.\n\nThe dimensionality N indicates the dimensionality of the input data  (1 for Wall, 2 for Cylinder, 3 for Sphere or Mesh).\n\nEach obstruction needs to define the following interface:\n\ndetect_collision: returns any interesection between the movement and the obstruction\nproduces_off_resonance, optional: whether the obstruction produces an off-resonance field (false by default). If true, the obstruction should also define:\nlorentz_off_resonance: computes the off-resonance due to the obstruction at position\ntotal_susceptibility: computes total susceptibility caused by this obstruction\nisinside: true if position is inside the obstruction\nBoundingBox: returns a [BoundingBox] fully containing the obstruction\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.BoundingBox","page":"API","title":"MCMRSimulator.BoundingBox","text":"BoundingBox(lower::PosVector, upper::PosVector)\nBoundingBox(obstruction::Obstruction)\nBoundingBox(obstructions)\n\nCreates a bounding box containing one or more Obstruction. For infinitely repeated objects (using TransformObstruction) the bounding box of the central object is returned.\n\nCheck whether particles are inside using isinside.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Collision","page":"API","title":"MCMRSimulator.Collision","text":"Collision(distance, normal, properties; index=0, inside=false)\n\nA detected collision along the movement.\n\nParameters\n\ndistance: number between 0 and 1 indicating the distance of the collision from the origin (0) to the destination point (1)\nnormal: normal of the obstruction at the collision site. To get correct reflection the normal should point in the direction of the incoming particle.\nproperties: ObstructionProperties of the obstruction the spin collided with.\nindex: Index of which triangle in Mesh got hit\ninside: Whether the obstruction was hit on the inside or the outside. For a mesh triangle the outside is considered in the direction of the normal. For a wall the outside is in the positive direction.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.CollisionProperties","page":"API","title":"MCMRSimulator.CollisionProperties","text":"CollisionProperties(MT_fraction, permeability)\n\nObject used to define the collision properties within a ObstructionProperties or a [GlobalProperties] object. Values of NaN are used in [ObstructionProperties] to indicate that the default collision parameter should be used.\n\nThese properties can be retrieved using:\n\nMT_fraction\npermeability\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.ConcreteShape","page":"API","title":"MCMRSimulator.ConcreteShape","text":"ConcreteShape(t0, t1, max_amplitude, shape)\n\nA 1-dimensional amplitude profile extending from t0 to t1 with maximum amplitude of max_amplitude. The amplitude profile is defined by a Shape.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.ConcreteShape-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"API","title":"MCMRSimulator.ConcreteShape","text":"ConcreteShape(times, amplitudes)\n\nCreates an amplitude profile by linearly interpolating the amplitudes between the given times. Times and amplitudes should be vectors of the same length.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.ConcreteShape-Tuple{}","page":"API","title":"MCMRSimulator.ConcreteShape","text":"ConcreteShape()\n\nProduces a ConcreteShape with only zero amplitude.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Cylinder","page":"API","title":"MCMRSimulator.Cylinder","text":"Cylinder(radius; chi_I=-0.1, chi_A=-0.1, g_ratio=1)\n\nCreates a hollow cylinder with a radius of radius micrometer (default 1 micrometer) at the given location (default: origin). Generate cylinders using cylinders. See Myelinated cylinders for an explanation of the myelin sheath.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.FixedXoshiro","page":"API","title":"MCMRSimulator.FixedXoshiro","text":"Immutable version of the Xoshiro random number generator state\n\nUsed to store the current state in the Spin object. To evolve the spin in a predictable manner set the seed using copy!(spin.rng, Random.TaskLocalRNG).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Float","page":"API","title":"MCMRSimulator.Float","text":"Float type used during the simulation (default: Float64). This has to be changed in the code.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometry","page":"API","title":"MCMRSimulator.Geometry","text":"Geometry(obstructions...)\n\nRepresents the tissue geometry as one or more TransformObstruction objects. Any BaseObstruction passed on will be converted into a TransformObstruction before being added to the geometry.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.GlobalProperties","page":"API","title":"MCMRSimulator.GlobalProperties","text":"GlobalProperties(; MT_fraction=0, permeability=0, R1=0, T1=Inf, R2=0, T2=Inf, off_resonance=0)\n\nDefines a default set of collision and relaxation parameters for a simulation. These parameters can be locally overriden by ObstructionProperties.\n\nParameters can be accessed using their accessors:\n\nMT_fraction\npermeability\nT1\nR1\nT2\nR2\noff_resonance\n\nThey can be set using global_properites.<property> = <value>.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.GridShape","page":"API","title":"MCMRSimulator.GridShape","text":"GridShape(bounding_box::BoundingBox, size::SVector{3, Int})\nGridShape(bounding_box::BoundingBox, size::Int)\n\nDefines a 3D grid within the BoundingBox.  size sets the number of voxels along each dimension. Setting size to a single integer will set that number along each dimension  (except dimensions of infinite size, which are always just one voxel wide).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.InstantGradient","page":"API","title":"MCMRSimulator.InstantGradient","text":"InstantGradient(; qvec=[0, 0, 0], q_origin=0, time=0.)\n\nInfinitely short gradient pulse that encodes phase information given by qvec (units: number of rotations/um) and q_origin (units: number of rotations).\n\nThe number of time a spins at given position is rotated is given by qvec â‹… position + q_origin.\n\nThe pulse is applied at given time (in milliseconds). Retrieve this time using get_time.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.InstantRFPulse","page":"API","title":"MCMRSimulator.InstantRFPulse","text":"InstantRFPulse(;time=0., flip_angle=0., phase=0.)\n\nInstantaneous radio-frequency pulse that flips the spins by flip_angle degrees in a plane perpendicular to an axis in the x-y plane with an angle of phase degrees with respect to the x-axis at given time. Angles are in degrees and the time is in milliseconds. Angles can be retrieved using flip_angle and phase. Time can be retrieved using get_time.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.MRGradients","page":"API","title":"MCMRSimulator.MRGradients","text":"MRGradients(Gx, Gy, Gz, origin)\nMRGradients(times, amplitudes; origin=[0, 0, 0])\nMRGradients([(time0, amplitude0), (time1, amplitude1), ...]; origin=[0, 0, 0])\nMRGradients()\n\nDefines a gradient profile with the gradients (unit: kHz/um) linearly interpolated between the given times (unit: ms). The gradients are centered on given origin (unit: um). They can be sampled using gradient.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.MRIProperties","page":"API","title":"MCMRSimulator.MRIProperties","text":"MRIProperties(; R1=, R2=, T1=, T2=, off_resonance=)\n\nObject used to define the MRI relaxation properties within a ObstructionProperties or a [GlobalProperties] object. Either the relaxation rate (R1/R2) or the relaxation time (T1/T2) should be set (or neither).\n\nValues of NaN are used in [ObstructionProperties] to indicate that the default relaxation parameter should be used.\n\nThese relaxation variables can be retrieved using:\n\nT1\nR1\nT2\nR2\noff_resonance\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Mesh","page":"API","title":"MCMRSimulator.Mesh","text":"Mesh(vertices, triangles)\n\nAn Obstruction formed from a triangular mesh.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Movement","page":"API","title":"MCMRSimulator.Movement","text":"Intermediate object used internally to represent a movement from one position to another\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Obstruction","page":"API","title":"MCMRSimulator.Obstruction","text":"Supertype of any obstruction to the free diffusion of water. Some might also generate off-resonance fields.\n\nThere are two types of obstructions:\n\nBaseObstruction with the basic obstructions (walls, sphere, cylinders, meshes)\nTransformObstruction, which transform the base obstructions\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.ObstructionProperties","page":"API","title":"MCMRSimulator.ObstructionProperties","text":"ObstructionProperties(; MT_fraction=NaN, permeability=NaN, R1_inside=NaN, T1_inside=NaN, R2_inside=NaN, T2_inside=NaN, off_resonance_inside=NaN)\n\nDefines the collision and relaxation properties for an obstruction. Either the relaxation rate (R1/R2) or the relaxation time (T1/T2) should be set (or neither).\n\nCollision parameters can be retreived using their accessors: MT_fraction, and permeability.\n\nMRI relaxation parameters within the obstruction can be retrieved by calling their accessor on obstruction_properties.inside. The accessors are T1, R1, T2, R2, and off_resonance.\n\nValues of NaN are used internally to indicate that the default parameters (from GlobalProperties) should be used.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.PlotPlane","page":"API","title":"MCMRSimulator.PlotPlane","text":"Defines a finite plane in the 3D space used for plotting.\n\nConstructor\n\nPlotPlane(normal::PosVector=[0, 0, 1], position::PosVector=[0, 0, 0]; size=10., sizex=<size>, sizey=<size>, ngrid=100)\n\nArguments:\n\nnormal: length-3 vector with the orientation perpendicular to the plane (default to z-direction).\nposition: position of plane as a length-3 vector (defaults to origin).\nsizex: size of the plane in the x-direction (before rotating to normal).\nsizey: size of the plane in the y-direction (before rotating to normal).\nsize: set default value for sizex and sizey.\nngrid: number of grid elements to split the plane up into for plotting.\n\nSpin projection onto plane\n\nSee project for details on how spins are projected onto the PlotPlane.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.PosVector","page":"API","title":"MCMRSimulator.PosVector","text":"General definition used for length-3 vectors. Mostly used for positions.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.RFPulse","page":"API","title":"MCMRSimulator.RFPulse","text":"RFPulse(times, amplitudes[, phases]; phase0=0., off_resonance=0)\n\nCreates a radio-frequency block between times t0 and t1. At time t0 the phase of the transverse B1 magnetic field is equal to phase0 (given in degrees).\n\nThe amplitude and frequency modulation profile of the RF pulse are provided as functions:\n\nThe amplitude represents the strength of the magnetic field in kHz the transverse plane as a function of time (between t0 and t1). This should always be positive.\nThe phase represents the offset from the Larmor frequency in degrees as a function of time (between t0 and t1). If not provided explicitly, the phase at time t is determined by the initial phase (in degrees) and the off-resonance (in kHz).\n\nThe functions amplitude, phase, and off_resonance are used to get the value at a specific t or averaged between two times.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Readout","page":"API","title":"MCMRSimulator.Readout","text":"Readout(;time=0)\n\nReadout the spins at the given time (in milliseconds) each TR\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Scanner","page":"API","title":"MCMRSimulator.Scanner","text":"Scanner(;B0=3., max_gradient=Inf, max_slew_rate=Inf, units=:kHz)\n\nProperties of an MRI scanner relevant for the MR signal simulations.\n\nB0: magnetic field strength (in Tesla)\nmax_gradient: maximum gradient strength long each axis.\nmax_slew_rate: maximum rate of change in the gradient strength\n\nBy default gradient and slew_rate are expected to be provided in units of, respectively, kHz/um and kHz/um/ms. However, if the keyword units=:Tesla is set, the gradient and slew_rate can be provided in terms of respectively mT/m and \n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Sequence","page":"API","title":"MCMRSimulator.Sequence","text":"Sequence(;TR, gradients=nothing, pulses=nothing, scanner=Scanner(B0), B0=3., interplate_gradients=:step)\n\nAn MR sequence represented by a series of pulses repeated with a given repetition time (TR).\n\nPossible sequence components are:\n\nRFPulse: Radio-frequency pulse with user-provided amplitude and phase profile.\nInstantRFPulse: instantaneous approximation of a radio-frequency pulse flipping the spin orientations.\nInstantGradient: instantaneous gradients encoding spatial patterns in the spin phase distribution.\nReadout: Store the spins at this timepoint.\n\nThe previous/current/next RF pulse at a specific time is given by previous_pulse, current_pulse, or next_pulse.  All of these will return nothing if there is no previous/current/next pulse. The same functions exist for the previous/current/next instantaneous pulse (i.e., InstantRFPulse or InstantGradient),      namely previous_instant, current_instant, or next_instant.  Note that all gradients/pulses repeat every TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Shape","page":"API","title":"MCMRSimulator.Shape","text":"Shape(times, amplitudes; normalise=false)\n\nDefines a 1D Shape for an RF pulse or gradient profile. Times should be between 0 and 1 (inclusive). Amplitudes should start and end at 0 and range between 0 and 1 (for RF pulses) and -1 and 1 (for gradients). Errors are ranged if times/amplitudes are outside of these ranges (although normalise=true can be used to simply adjust the shape to match these constraints).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Shape-Tuple{MCMRSimulator.CompressedPulseSeqShape}","page":"API","title":"MCMRSimulator.Shape","text":"Shape(shape::CompressedPulseSeqShape, step_size)\n\nCreate a Shape object based on the pulseseq Shape format presuming each sample is step_size milliseconds apart.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Simulation","page":"API","title":"MCMRSimulator.Simulation","text":"Simulation(\n    sequences; geometry=Obstruction[], diffusivity=0.,\n    R1=0, T1=Inf, R2=0, T2=Inf, off_resonance=0, MT_fraction=0, permeability=0,, \n    timestep=nothing, gradient_precision=0.01, sample_displacement=5, sample_off_resonance=10,\n)\n\nDefines the setup of the simulation and stores the output of the run.\n\nArgument\n\nGeneral parameters:\n\nsequences: Vector of Sequence objects. During the spin random walk the simulation will keep track of the spin magnetisations for all of the provided sequences.\ngeometry: Set of obstructions, which can be used to restrict the diffusion, produce off-resonance fields, alter the local T1/T2 relaxation, and as sources of magnetisation transfer.\ndiffusivity: Rate of the random motion of the spins in um^2/ms.\n\nMRI properties\n\nThese parameters determine the evolution and relaxation of the spin magnetisation.\n\nR1/T1: sets the longitudinal relaxation rate (R1 in kHz) or relaxation time (T1=1/R1 in ms). This determines how fast the longitudinal magnetisation returns to its equilibrium value of 1.\nR2/T2: sets the transverse relaxation rate (R2 in kHz) or relaxation time (T2=1/R2 in ms). This determines how fast the transverse magnetisation is lost.\noff_resonance: Size of the off-resonance field in this voxel in kHz.\n\nThese MRI properties can be overriden for spins inside the BaseObstruction objects of the geoemtry.\n\nCollision parameters\n\nThese parameters determine how parameters behave when hitting the BaseObstruction objects of the geoemtry. They can be overriden for individual [BaseObstruction] objects.\n\nMT_fraction: the fraction of magnetisation transfered between the obstruction and the water spin at each collision.\npermeability: the probability that the spin will pass through the obstruction.\n\nNote that MT_fraction and permeability are internally adjusted to make their effect independent of the timestep (see correct_for_timestep).\n\nTimestep parameters\n\nThese parameters (timestep, gradient_precision, sample_displacement, sample_off_resonance) control the timepoints at which the simulation is evaluated. The default values should work well. For more details on how to adjust them, see TimeController.\n\nRunning the simulation\n\nTo run a Snapshot of spins through the simulations you can use one of the following functions:\n\nevolve: evolves the spins in the snapshot until a single given time and returns that state in a new Snapshot.\ntrajectory: returns full spin trajectory (recommended only for small number of spins).\nsignal: returns signal variation over time.\nreadout: returns the snapshots at the sequence readouts.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Snapshot","page":"API","title":"MCMRSimulator.Snapshot","text":"Represents the positions and orientations of multiple Spin objects at a specific time.\n\nNote that times are in milliseconds and positions in micrometer.  The equilibrium longitudinal spin (after T1 relaxation) is always 1.\n\nUseful constructors\n\nSnapshot(positions; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)\nSnapshot(nspins::Integer; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)\n\nCreates a new Snapshot at the given time with perfectly longitudinal spins initialised for simulating nsequences sequences. This initial spin locations are given by positions (Nx3 matrix or sequence of vectors of size 3). Alternatively the number of spins can be given in which case the spins are randomly distributed in a 1x1x1 mm box centered on the origin.\n\nSnapshot(snap::Snapshot{1}, nsequences)\n\nReplicates the positions and orientations for a single sequence in the input snapshot across nsequences.\n\nExtracting summary information\n\nlongitudinal(snapshot) to get the nsequences spin magnitudes in the z-direction (equilibrium of 1) averaged over all spins\ntransverse(snapshot) to get the nsequences spin magnitudes in the x-y-plane averaged over all spins\nphase(snapshot) to get the nsequences spin angles in x-y plane (in degrees) averaged over all spins\norientation(snapshot) to get a (nsequencesx3) matrix with the spin orientations in 3D space averaged over all spins\nSpinOrientation(snapshot) to get a nsequences vector of [SpinOrientation] objects with the average spin orientation across all spins\nposition.(snapshot) to get a the position for each spin in a vector (no averaging applied)\n\nInformation for a single sequence can be extracted by calling get_sequence first.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Sphere","page":"API","title":"MCMRSimulator.Sphere","text":"Sphere([radius[, location]])\n\nCreates a hollow sphere with a radius of radius micrometer (default 1 micrometer) at the given location (default: origin). Generate spheres using spheres.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Spin","page":"API","title":"MCMRSimulator.Spin","text":"Spin particle with a position and nsequences spin orientations (stored as SpinOrientation).\n\nA random number generator is stored in the Spin object as well, which will be used for evolving the spin into the future in a reproducible manner.\n\nConstructors\n\nSpin(;nsequences=1, position=[0, 0, 0], longitudinal=1., transverse=0., phase=0.)\n\nCreates a new spin with nsequences identical spin orientations (given by longitudinal, transverse, and phase flags). The spin will start at given position.\n\nSpin(reference_spin::Spin{1}, nsequences)\n\nCreate a new spin with the same position as reference_spin with the orientation of reference_spin replicated nsequences times.\n\nExtracting spin information\n\nlongitudinal to get the nsequences spin magnitudes in the z-direction (equilibrium of 1)\ntransverse to get the nsequences spin magnitudes in the x-y-plane\nphase to get the nsequences spin angles in x-y plane (in degrees)\norientation to get a (nsequencesx3) matrix with the spin orientations in 3D space\nposition to get a length-3 vector with spin location\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.SpinOrientation","page":"API","title":"MCMRSimulator.SpinOrientation","text":"SpinOrientation(longitudinal, transverse, phase)\n\nThe spin orientation. Usually created as part of a Spin object.\n\nSpinOrientation(snapshot::Snapshot)\n\nReturns the average spin orientations of all Spin objects in the Snapshot.\n\nThis information can be extracted using:\n\nlongitudinal to get the spin in the z-direction (equilibrium of 1)\ntransverse to get the spin in the x-y-plane\nphase to get the spin angle in x-y plane (in degrees)\norientation to get the spin orientation as a length-3 vector\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Spiral","page":"API","title":"MCMRSimulator.Spiral","text":"Spiral(inner, outer; theta0=0., thickness=0.014)\n\nCreates a spiral starting from inner to outer radius. The distance between subsequent wraps is thickness micrometer. The angle of the start of the wraps is theta0.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.TransformObstruction","page":"API","title":"MCMRSimulator.TransformObstruction","text":"TransformObstruction(base_type, args...; positions=nothing, repeats=0., rotation=I(3), lorentz_radius=10., kwargs...)\nTransformObstruction(base; positions=nothing, repeats=0., rotation=I(3), lorentz_radius=10.)\n\nTransforms the BaseObstruction objects in base in one of several ways:\n\nApply the shifts defined by positions (none applied by default).\nInfinitely repeat the base obstruction every repeats.\nRotate the base obstructions by rotation.\n\nThe BaseObstruction objects an already be initialised. If a BaseObstruction type is given instead it will be initialised using args and kwargs not used by TransformObstruction.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Wall","page":"API","title":"MCMRSimulator.Wall","text":"Wall()\n\nWall stretching to infinite along two dimensions. Generate walls using walls.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.B0-Tuple{Scanner}","page":"API","title":"MCMRSimulator.B0","text":"B0(scanner)\nB0(sequence)\n\nReturns the magnetic field strength of the scanner in Tesla.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.amplitude-Tuple{MCMRSimulator.RFPulse, Number}","page":"API","title":"MCMRSimulator.amplitude","text":"amplitude(rf_pulse, t1[, t2])\n\nComputes the amplitude of the RFPulse at time t1 in kHz. If t2 is also provided, the average amplitude between times t1 and t2 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.amplitude-Tuple{MCMRSimulator.Shape, Number}","page":"API","title":"MCMRSimulator.amplitude","text":"amplitude(shape, time)\n\nReturns the amplitude of the shape at the given time using linear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.amplitude_derivative-Union{Tuple{N}, Tuple{MCMRSimulator.Shape{N}, Number}} where N","page":"API","title":"MCMRSimulator.amplitude_derivative","text":"amplitude_derivative(shape, time)\n\nReturns the derivative of the shape at the specific time. At control points the derivative is always assumed to be the one of the next block.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.amplitude_integral-Tuple{MCMRSimulator.Shape, Number, Number}","page":"API","title":"MCMRSimulator.amplitude_integral","text":"amplitude_integral(shape, t0, t1)\n\nIntegrate the amplitude from t0 to t1.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.amplitude_integral-Union{Tuple{T}, Tuple{MCMRSimulator.Shape, T, AbstractVector{T}}} where T<:Number","page":"API","title":"MCMRSimulator.amplitude_integral","text":"amplitude_integral(shape, t0, times)\n\nIntegrate the amplitude from t0 to all the times in times (all assumed to be larger than t0 and strictly increasing).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.amplitude_integral_step","page":"API","title":"MCMRSimulator.amplitude_integral_step","text":"amplitude_integral_step(shape, index, t0, t1)\n\nIntegrate the amplitude from t0 to t1 assuming that both are within the single step (given by index). This is a helper function for amplitude_integral.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.annuli-Tuple","page":"API","title":"MCMRSimulator.annuli","text":"annuli(inner, outer; myelin=false, chi_I=-0.1, chi_A=-0.1, positions=[0, 0], repeats=[Inf, Inf], rotation=I(3)\n\nCreates one or more Annulus with given inner and outer radii. Myelinated annuli can be created by setting the myelin to true. All parameters can be either a single value or a vector of values.\n\nThe positions, repeats, and rotation control the annulus position and orientation and is explained in  more detail in Defining the geometry. Additional keyword arguments are available to set generic obstruction settings as described in ObstructionProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.apply!-Tuple{InstantRFPulse, SpinOrientation}","page":"API","title":"MCMRSimulator.apply!","text":"apply!(sequence_component, spin_orientation[, position])\n\nApplies given sequence component to the spin orientation. This updates the existing spin orientation. Some pulses (e.g., InstantGradient) require positional information as well.\n\napply!(sequence_components, spin)\napply!(sequence_components, snapshot)\n\nApply all sequence components to the spin orientation in the Spin or to all the spins in Snapshot. Sequence components (see Sequence) can be nothing if there is no sequence component at this time.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.collided-Tuple{MCMRSimulator.BaseObstruction, MCMRSimulator.Collision}","page":"API","title":"MCMRSimulator.collided","text":"collided(o::BaseObstruction, c::Collision)\n\nReturns true if the collision c hit the obstruction o.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.color-Tuple{Union{Spin{1}, SpinOrientation}}","page":"API","title":"MCMRSimulator.color","text":"color(orient::SpinOrientation; saturation=1.)\n\nReturns a color representing the spin orientation in the transverse (x-y) plane. Brighter colors have a larger transverse component, so that spins with no transverse component are black. The actual color encodes the spin orientation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.constant_pulse-Tuple{Number, Number, Number}","page":"API","title":"MCMRSimulator.constant_pulse","text":"constant_pulse(t0, t1, flip_angle; phase0=0., off_resonance=0.)\n\nCreates an RF pulse with a constant amplitude resulting in given flip_angle (for spins at off_resonance).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.corners-Tuple{MCMRSimulator.BoundingBox{3}}","page":"API","title":"MCMRSimulator.corners","text":"corners(bb::BoundingBox)\n\nReturns a vector of all corners of the BoundingBox.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.correct_collisions-Tuple{MCMRSimulator.Movement, Any}","page":"API","title":"MCMRSimulator.correct_collisions","text":"correct_collision(movement, geometry)\n\nSplits the given movement from point A to point B into multiple steps that bounce off the given obstructions. This function assumes perfect reflection rather than the diffuse reflection used in draw_step. It is used to test the collision detection and resolution, but not actually used in the simulations.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.cylinders-Tuple","page":"API","title":"MCMRSimulator.cylinders","text":"cylinders(radii; g_ratio=1, chi_I=-0.1, chi_A=-0.1, positions=[0, 0], repeats=[Inf, Inf], rotation=I(3)\n\nCreates one or more Cylinders with given radius (or vector of radii). Myelinated cylinders can be created by setting the g_ratio to a different value that 1. All parameters can be either a single value or a vector of values. The positions, repeats, and rotation control the cylinder position and orientation and is explained in  more detail in Defining the geometry. Additional keyword arguments are available to set generic obstruction settings as described in ObstructionProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.derive_qval_time-Tuple{Union{Nothing, Real}, Union{Nothing, Real}, Union{Nothing, Real}, Real}","page":"API","title":"MCMRSimulator.derive_qval_time","text":"derive_qval_time(max_diffusion_time; bval=nothing, diffusion_time=nothing, qval=nothing)\n\nDerives b-value, diffusion time, and q-value from each other assuming short pulses\n\nReturns a tuple with the q-value and diffusion time.\n\nThe strength of the diffusion weighting can be defined in 3 ways:\n\nnot setting anything or only setting the diffusion time: in this case no diffusion weighting is applied (b=0).\nsetting only the b-value or q-value: in this case a diffusion_time of TE/2 is assumed.\nsetting two out of three of the b-value, diffusion_time, and qval. The last one will be calculated.\n\nIf all three are defined an AssertionError is raised if they do not agree with each other.\n\nAssumes equation of b = q^2 Delta, where\n\nbval is the diffusion-weighted strength (b-value) in msum^2.   \nqval is the gradient applied due to the diffusion-weighted gradients in the spin phase field (1mu m).    For a square pulse this is computed as gamma G delta.\ndiffusion_time (Delta) is the diffusion time defined for infinitely short pulses as the time between the diffusion-weighted gradients (in ms).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.detect_collision","page":"API","title":"MCMRSimulator.detect_collision","text":"detect_collision(movement, geometry[, previous])\n\nReturns a Collision object if the given movement crosses any obstructions. The first collision is always returned. If no collision is detected, empty_collision will be returned\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.detect_collision-2","page":"API","title":"MCMRSimulator.detect_collision","text":"detect_collision(movement, base_obstruction, previous_collision)\n\nReturns any intersection between the Movement and the [BaseObstruction].\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.draw_step!-Tuple{Spin, Float64, Float64, MCMRSimulator.GlobalProperties}","page":"API","title":"MCMRSimulator.draw_step!","text":"draw_step!(spin::Spin, diffusivity, timestept, default_properties, [, geometry])\n\nUpdates the spin based on a random movement through the given geometry for a given timestep:\n\ndraws the next location of the particle after timestep with given diffusivity.   If provided, this displacement will take into account the obstructions in geometry.\nthe spin orientation might be affected by collisions with the obstructions in geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.dwi-Tuple{}","page":"API","title":"MCMRSimulator.dwi","text":"dwi(; TE=80., TR=2000., bval/qval/gradient_strength, diffusion_time=TE/2, gradient_duration, readout_time=0., scanner=Scanner(B0=3.), orientation = [1., 0, 0])\n\nCreates a diffusion-weighted pulsed gradient spin echo MRI sequence\n\nThe timings of the RF pulses is set by TE and TR.  The gradient timings will also be affected by gradient_duration, diffusion_time, scanner (which sets the ramp time) and readout_time:\n\nBy default the gradient durations are set to the maximum value possible within the echo time (TE) keeping in mind the time needed for the MR readout (readout_time) and the time needed to ramp to the maximum gradient strength (set by the scanner).\nWhen gradient_duration is set to 0, the gradient pulses are assumed to be instanteneous (i.e., using InstantGradient). The time between these instant gradients can be set using diffusion_time (defaults to TE/2).\n\nThe strength of the diffusion gradients is set by one of bval (units: ms/um^2), qval (units: 1/um), or gradient_strength (units: kHz/um). If this strength exceeds the maximum allowed for the scanner an AssertionError is raised. The gradient orientation is set by orientation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.dyad_snapshot!-Tuple","page":"API","title":"MCMRSimulator.dyad_snapshot!","text":"dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)\n\nPlots the spins in the Snapshot projected onto given PlotPlane as arrows.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.dyad_snapshot-Tuple","page":"API","title":"MCMRSimulator.dyad_snapshot","text":"dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)\n\nPlots the spins in the Snapshot projected onto given PlotPlane as arrows.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.effective_pulse-Tuple{MCMRSimulator.RFPulse, Number, Number}","page":"API","title":"MCMRSimulator.effective_pulse","text":"effective_pulse(RFPulse, t0, t1)\neffective_pulse(sequence, t0, t1)\n\nRepresents the effect of the RF pulse between times t0 and t1 as an InstantRFPulse.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.effective_pulse-Tuple{Sequence, Number, Number}","page":"API","title":"MCMRSimulator.effective_pulse","text":"effective_pulse(sequence, t1, t2)\n\nReturns the InstantRFPulse that has the same effect as the radio-frequency pulses (RFPulse) in the provided sequence will have between t1 and t2.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.empty_mri_properties-Tuple{MCMRSimulator.MRIProperties}","page":"API","title":"MCMRSimulator.empty_mri_properties","text":"empty_mri_properties(properties)\n\nReturns true if none of the parameters have been set\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N","page":"API","title":"MCMRSimulator.evolve","text":"evolve(snapshot, simulation[, new_time])\n\nEvolves the Snapshot through the Simulation to a new time. Returns a Snapshot at the new time, which can be used as a basis for further simulation. By default it will simulate till the start of the next TR.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.evolve_to_time!-Union{Tuple{N}, Tuple{Spin{N}, Simulation{N}, StaticArraysCore.SVector{N, Tuple{InstantRFPulse, InstantRFPulse}}, Float64, Float64}} where N","page":"API","title":"MCMRSimulator.evolve_to_time!","text":"evolve_to_time(spin, simulation, current_time, new_time)\n\nEvolve a single spin to the next time of interest. This takes into account both random diffusion of the spin's position and relaxation of the MR spin orientation. It is used internally when evolving Simulation objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.evolve_to_time-Union{Tuple{N}, Tuple{Snapshot{N}, Simulation{N}, Float64}} where N","page":"API","title":"MCMRSimulator.evolve_to_time","text":"evolve_to_time(snapshot, simulation, new_time)\n\nEvolves the full Snapshot through the Simulation to the given new_time. Multi-threading is used to evolve multiple spins in parallel. This is used internally when calling any of the snapshot evolution methods (e.g., evolve).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.expand","page":"API","title":"MCMRSimulator.expand","text":"expand(bb::BoundingBox, ratio=1.)\n\nExpand or shrink the BoundingBox so that it grows/shrinks by ratio along each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.fit_time-Tuple{}","page":"API","title":"MCMRSimulator.fit_time","text":"fit_time(gradient_duration, diffusion_time, ramp_time, readout_time, TE)\n\nArranges the timing of gradients given the duration of gradient, diffusion time, ramp time, readout time and TE. By default it will try to arrange to gradients symmetrically arround the 180 degree pulse. If not feasible, it will make readout right after the rephasing gradient and calculate the dephasing gradient's timing based on the rephasing gradient.\n\nThis function is not supposed to be called individually! So no check for the arguments will happen, assuming all have been checked by dwigradients1D and all will not be nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.flip_angle-Tuple{InstantRFPulse}","page":"API","title":"MCMRSimulator.flip_angle","text":"flip_angle(instant_pulse)\n\nReturns the flip angle of the InstantRFPulse in degrees.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.get_sequence-Tuple{Spin, Any}","page":"API","title":"MCMRSimulator.get_sequence","text":"get_sequence(spin, sequence_index)\nget_sequence(snapshot, sequence_index)\n\nExtracts the spin orientation corresponding to a specific sequence, where the sequence index uses the order in which the sequences where provided in the Simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.get_time-Tuple{Snapshot}","page":"API","title":"MCMRSimulator.get_time","text":"get_time(snapshot)\nget_time(sequence_component)\nget_time(sequence, sequence_index)\n\nReturns the time in milliseconds that a snapshot was taken or that a sequence component will have effect.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.gradient-Tuple{AbstractVector, Sequence, Number}","page":"API","title":"MCMRSimulator.gradient","text":"gradient([position, ], sequence, t1[, t2])\n\nGets the off-resonance field (units: kHz) at given position at time t1 (or integrated between times t1 and t2). If position is not supplied the MR gradient is returned as a PosVector (units: kHz/um).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.gradient-Tuple{MRGradients, Number}","page":"API","title":"MCMRSimulator.gradient","text":"gradient([position, ]sequence/grad, time)\ngradient([position, ]sequence/grad, t1, t2)\n\nGet gradient strength generated by grad (MRGradients object) at a specific time or averaged over a period between t1 and t2. If no position is provided, the gradient is returned as a length-3 vector in units of mT/m. If a position is provided, the gradient is returned at that position as a float quantifying the off-resonance field in units of microTesla.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.image_snapshot!-Tuple","page":"API","title":"MCMRSimulator.image_snapshot!","text":"image_snapshot(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)\nimage_snapshot!(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)\n\nPlots the spins in the Snapshot projected onto given PlotPlane. The average spin orientation across the plot plane is plotted using the colour coding from color.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.image_snapshot-Tuple","page":"API","title":"MCMRSimulator.image_snapshot","text":"image_snapshot(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)\nimage_snapshot!(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)\n\nPlots the spins in the Snapshot projected onto given PlotPlane. The average spin orientation across the plot plane is plotted using the colour coding from color.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.inside_MRI_properties-Tuple{MCMRSimulator.Geometry, StaticArraysCore.SVector{3, Float64}, MCMRSimulator.MRIProperties}","page":"API","title":"MCMRSimulator.inside_MRI_properties","text":"inside_MRI_properties(geometry, spin/position, global_props)\n\nComputes the MRI parameters for the spin based on some global settings (global_props) and any overriding of those settings in the geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.inside_MRI_properties-Union{Tuple{N}, Tuple{MCMRSimulator.BaseObstruction{N}, StaticArraysCore.SVector{N, Float64}}} where N","page":"API","title":"MCMRSimulator.inside_MRI_properties","text":"inside_MRI_properties(obstruction, position)\n\nReturns the inside MRI properties of the obstruction only if the position is within the property. For positions outside of the MRI properties an empty MRIProperties is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.isinside-Tuple{Any, AbstractVector}","page":"API","title":"MCMRSimulator.isinside","text":"isinside(obstruction/geometry/bounding_box, position)\nisinside(obstructions/geometry/bounding_box, spin)\nisinside(obstructions/geometry/bounding_box, snapshot)\n\nTest whether the particles are inside a BaseObstruction, TransformObstruction, Geometry or BoundingBox object.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.load_mesh-Tuple{IO}","page":"API","title":"MCMRSimulator.load_mesh","text":"load_mesh(file)\n\nLoads a Mesh from a file.\n\nCurrently only PLY files are supported (see ply_from_mesh)\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.longitudinal","page":"API","title":"MCMRSimulator.longitudinal","text":"transverse(spin)\ntransverse(snapshot)\n\nReturns the longitudinal magnitude of the spin (i.e., magnitude aligned with the magnetic field) for a single particle (Spin) or averaged across a group of particles in a [Snapshot]. When orientations for multiple sequences are available an array of longitudinal values is returned with a value for each sequence.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.lorentz_off_resonance","page":"API","title":"MCMRSimulator.lorentz_off_resonance","text":"lorentz_off_resonance(base_obstruction, position, b0_field, repeat_dist, radius, nrepeats)\n\nComputes the off-resonance field produced by the obstruction (BaseObstruction) at the given position given the b0_field. The field generated by any repeats of the base obstruction within a distance of radius will also be considered (presuming the obstruction repeats every repeat_dist). This maximum number of repeats that need to be considered is precomputed as nrepeats.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.max_gradient","page":"API","title":"MCMRSimulator.max_gradient","text":"max_gradient(scanner[, units])\n\nReturns the maximum magnetic field gradient of the scanner in kHz/um. By setting units to :Tesla, the gradient strength can be returned in mT/m instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.max_slew_rate","page":"API","title":"MCMRSimulator.max_slew_rate","text":"max_slew_rate(scanner[, units])\n\nReturns the maximum magnetic field slew rate of the scanner in kHz/um/ms. By setting units to :Tesla, the slew rate can be returned in T/m/s instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.merge_mri_parameters","page":"API","title":"MCMRSimulator.merge_mri_parameters","text":"merge_mri_parameters(properties[, default_values=<empty>])\n\nMerges multiple MRI properties into one. An error is raised if they are inconsistent with each other\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.mesh_grid_intersection-Tuple{MCMRSimulator.GridShape, Vector{StaticArraysCore.SVector{3, Float64}}, Vector{StaticArraysCore.SVector{3, Int64}}}","page":"API","title":"MCMRSimulator.mesh_grid_intersection","text":"mesh_grid_intersection(shape, vertices, triangles)\n\nDetermines for each voxel in the grid with which triangles it intersects.\n\nAlgorithm\n\nWe follow the algorithm proposed by https://fileadmin.cs.lth.se/cs/Personal/TomasAkenine-Moller/code/triboxtam.pdf, which is based on the separating axis theorem.\n\nWe project each voxel in the grid and each triangle on a series of 9 axes:\n\nthe normals of the cube ([1, 0, 0], [0, 1, 0], [0, 0, 1])\nthe normal of the triangle\nthe cross products of any edge of the cube (same as normals) and the edges of the triangle (total of 9 tests)\n\nIf the cube and triangle do not overlap along any of these axes, they are non-overlapping. If they overlap along all axes, the triangle and cube overlap\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.norm_angle-Tuple{Any}","page":"API","title":"MCMRSimulator.norm_angle","text":"norm_angle(angle)\n\nNormalises an angle in degrees, so that it is between it is in the range (-180, 180]\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.normal-Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}","page":"API","title":"MCMRSimulator.normal","text":"normal(p1, p2, p3)\n\nComputes the normal of a triangle formed by the three points\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.off_resonance-Tuple{Cylinder, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}","page":"API","title":"MCMRSimulator.off_resonance","text":"off_resonance(cylinder, position, b0_field)\n\nComputed by the hollow cylinder fiber model from Samuel Wharton, Richard Bowtell (2012).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.off_resonance-Tuple{MCMRSimulator.RFPulse, Number}","page":"API","title":"MCMRSimulator.off_resonance","text":"off_resonance(rf_pulse, t1[, t2])\n\nComputes the offresonance of the RFPulse at time t1 in kHz. If t2 is also provided, the average offresonance between times t1 and t2 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.orientation","page":"API","title":"MCMRSimulator.orientation","text":"orientation(spin)\norientation(snapshot)\n\nReturns the spin orientation as a length-3 vector for a single particle (Spin) or averaged across a group of particles in a [Snapshot]. When orientations for multiple sequences are available an array of vectors is returned with a value for each sequence.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.perfect_dwi-Tuple{}","page":"API","title":"MCMRSimulator.perfect_dwi","text":"perfect_dwi(; TE=80., TR=2000., bval=nothing, diffusion_time=nothing, qval=nothing, orientation = [0, 0, 1.])\n\nCreates a standard diffusion-weighted MRI sequence\n\nThis produces a pulsed gradient spin echo (PGSE) sequence with perfect RF pulses  and infinitely short diffusion-weighted gradients.\n\nThe procedure for defining the diffusion-weighted gradient strength is defined by derive_qval_time. The orientation parameter only sets the gradient orientation, not the strength.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.phase","page":"API","title":"MCMRSimulator.phase","text":"phase(spin)\nphase(snapshot)\n\nReturns the phase in the x-y plane of the spin for a single particle (Spin) or averaged across a group of particles in a [Snapshot]. When orientations for multiple sequences are available  an array of phase values is returned with a value for each sequence.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.phase-Tuple{InstantRFPulse}","page":"API","title":"MCMRSimulator.phase","text":"phase(instant_pulse)\n\nReturns the angle in the x-y plane of the axis around with the InstantRFPulse rotates in degrees.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.phase-Tuple{MCMRSimulator.RFPulse, Number}","page":"API","title":"MCMRSimulator.phase","text":"phase(rf_pulse, t1[, t2])\n\nComputes the phase of the RFPulse at time t1 in degrees. If t2 is also provided, the average phase between times t1 and t2 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.plot_geometry!-Tuple","page":"API","title":"MCMRSimulator.plot_geometry!","text":"plot(plot_plane, geometry)\nplot!(plot_plane, geometry)\nplot_geometry(plot_plane, geometry)\nplot_geometry!(plot_plane, geometry)\n\nPlots the intersections of geometry in the PlotPlane.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.plot_geometry-Tuple","page":"API","title":"MCMRSimulator.plot_geometry","text":"plot(plot_plane, geometry)\nplot!(plot_plane, geometry)\nplot_geometry(plot_plane, geometry)\nplot_geometry!(plot_plane, geometry)\n\nPlots the intersections of geometry in the PlotPlane.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.plot_off_resonance!-Tuple","page":"API","title":"MCMRSimulator.plot_off_resonance!","text":"plot_off_resonance(plot_plane, geometry)\nplot_off_resonance(plot_plane, geometry)\n\nPlots the off-resonance of geometry in the PlotPlane.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.plot_off_resonance-Tuple","page":"API","title":"MCMRSimulator.plot_off_resonance","text":"plot_off_resonance(plot_plane, geometry)\nplot_off_resonance(plot_plane, geometry)\n\nPlots the off-resonance of geometry in the PlotPlane.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.plot_snapshot","page":"API","title":"MCMRSimulator.plot_snapshot","text":"plot(plot_plane, snapshot; kwargs...)\nplot!(plot_plane, snapshot; kwargs...)\nplot_snapshot(plot_plane, snapshot; kwargs...)\nplot_snapshot!(plot_plane, snapshot; kwargs...)\n\nPlots the spins in the Snapshot projected onto given PlotPlane. Each spin is represented by an arrow showing the transverse component of the spin (for a total of the first ndyads spins). The average spin orientation across the plot plane is plotted using the colour coding from color.\n\nThis combines the plotting from image_snapshot and dyad_snapshot.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.plot_trajectory2d!-Tuple","page":"API","title":"MCMRSimulator.plot_trajectory2d!","text":"plot(snapshots)\nplot!(snapshots)\nplot_trajectory3d(snapshots)\nplot_trajectory3d!(snapshots)\n\nPlots trajectory of the spins in a sequence of Snapshot objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.plot_trajectory2d-Tuple","page":"API","title":"MCMRSimulator.plot_trajectory2d","text":"plot(snapshots)\nplot!(snapshots)\nplot_trajectory3d(snapshots)\nplot_trajectory3d!(snapshots)\n\nPlots trajectory of the spins in a sequence of Snapshot objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.plot_trajectory3d!-Tuple","page":"API","title":"MCMRSimulator.plot_trajectory3d!","text":"plot(snapshots)\nplot!(snapshots)\nplot_trajectory3d(snapshots)\nplot_trajectory3d!(snapshots)\n\nPlots trajectory of the spins in a sequence of Snapshot objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.plot_trajectory3d-Tuple","page":"API","title":"MCMRSimulator.plot_trajectory3d","text":"plot(snapshots)\nplot!(snapshots)\nplot_trajectory3d(snapshots)\nplot_trajectory3d!(snapshots)\n\nPlots trajectory of the spins in a sequence of Snapshot objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.ply_from_mesh-Tuple{Any}","page":"API","title":"MCMRSimulator.ply_from_mesh","text":"ply_from_mesh(file)\n\nLoads a Mesh from a PLY file. PLY stands for Polygon File Format (http://paulbourke.net/dataformats/ply/). PLY IO is handled by PlyIO.jl (https://github.com/JuliaGeometry/PlyIO.jl).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.position-Tuple{Snapshot}","page":"API","title":"MCMRSimulator.position","text":"position.(s::Snapshot)\n\nReturns all the positions of the spin particles as a vector of length-3 vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.position-Tuple{Spin}","page":"API","title":"MCMRSimulator.position","text":"position(s::Spin)\n\nReturns the position of the spin particle as a vector of length 3.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.produces_off_resonance-Tuple{MCMRSimulator.BaseObstruction}","page":"API","title":"MCMRSimulator.produces_off_resonance","text":"produces_off_resonance(base_obstruction)\n\nWhether the obstruction produces an off-resonance field. The field will be computed using [lorentz_off_resonance]\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.produces_off_resonance-Tuple{MCMRSimulator.Geometry}","page":"API","title":"MCMRSimulator.produces_off_resonance","text":"produces_off_resonance(geometry)\n\nWhether any obstruction produces an off-resonance field. The field will be computed using [off_resonance]\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.project","page":"API","title":"MCMRSimulator.project","text":"project(position, transform::TransformObstruction)\n\nComputes the position in the space of the obstructions wrapped by the TransformObstruction.\n\nproject(position, grid::GridShape)\n\nComputes the voxel index for the position on the GridShape.  This will return a result even if the point is outside of the grid. Use isinside(position, grid) to check that.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.project-Tuple{PlotPlane, StaticArraysCore.SVector{3, Float64}}","page":"API","title":"MCMRSimulator.project","text":"project(plot_plane, position)\nproject(plot_plane, snapshot)\n\nTransforms the position (length-3 vector) or Snapshot to a space, where the PlotPlane lies in the x-y-plane centered on origin.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.project_geometry-Union{Tuple{N}, Tuple{PlotPlane, TransformObstruction{N, M, K, O} where {M, K, O<:MCMRSimulator.BaseObstruction{N}}}} where N","page":"API","title":"MCMRSimulator.project_geometry","text":"project_geometry(plot_plane, transform)\n\nProjects the plane on the intrinsic plane of the obstructions deformed by transform.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.project_on_grid-Tuple{PlotPlane, Snapshot{1}, Int64}","page":"API","title":"MCMRSimulator.project_on_grid","text":"project_on_grid(plot_plane, snap, ngrid)\n\nSpins from the Snapshot are projected onto the grid defined by PlotPlane in two ways:\n\nalong the normal spins are projected onto the plane from infinitely far (TODO: give finite extent)\nin the other directions any spins are projected onto the plane using mod(position[1], sizex) and mod(position[2], sizey).   This assumes that the geometry and field repeats itself ad infinitum beyond the PlotPlane (TODO: allow this assumption to be turned off).\n\nIn effect, this means that all spins are projected onto the PlotPlane. The average spin orientation in each grid cell is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.propose_times-Tuple{MCMRSimulator.TimeController, Number, Number, AbstractVector{<:Sequence}, Number}","page":"API","title":"MCMRSimulator.propose_times","text":"propose_times(simulation::Simulation, t_start, t_end)\npropose_times(time_controller::TimeController, t_start, t_end, sequences, diffusivity)\n\nComputes the timepoints at which the simulation will be evaluated when running from t_start to t_end.\n\nThe following timepoints will always be included\n\nAny multiple of the TR\nAny RF pulse\nAny change in the gradient strength\n\nAdditional timepoints will be added to ensure that:\n\nat any time the timestep is larger than time_controller.gradient_precision times D^-13 (G gamma)^-23.\nbetween t_start and t_end there are at least time_controller.sample_displacement timepoints.\nbetween any control point of the sequence gradient there are at least time_controller.sample_displacement timepoints.\nbetween an RF pulse and a subsequent RF pulse or tend there are at least `timecontroller.sampleoffresonance` timepoints.\nDuring an RF block the rotation around the maximum magnetic field will be at most time_controller.rf_rotation radians. For a specific RFBlock these timepoints can be found using propose_times(rf_block, rf_rotation, B0).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.random_annuli-Tuple{Any}","page":"API","title":"MCMRSimulator.random_annuli","text":"random_annuli(target_density; repeats, g_ratio=0.8, distribution=Distributions.Gamma, mean_radius=1., variance_radius=0.5, max_iter=1000, myelin=false, chi_I=-0.1, chi_A=-0.1, rotation=I(3))\n\nGenerate infinitely repeating box with non-overlapping annuli.\n\nA rectangle with the size of repeats will be filled with annuli for a total surface density of target_density. The annulus outer radii will be drawn from the selected distribution (if not set, a Gamma distribution is used with given mean_radius and var_radius). An error is raised if no solution for non-overlapping annuli is found. The inner radius with respect to the outer radius is set by the g-ratio. Other annuli parameters (besides inner, outer, positions, and repeats) are identical as in mr.annuli.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.random_cylinders-Tuple{Any}","page":"API","title":"MCMRSimulator.random_cylinders","text":"random_cylinders(target_density; repeats, distribution=Distributions.Gamma, mean_radius=1., variance_radius=0.5, max_iter=1000, g_ratio=1., chi_I=-0.1, chi_A=-0.1, rotation=I(3))\n\nGenerate infinitely repeating box with non-overlapping cylinders.\n\nA rectangle with the size of repeats will be filled with cylinders for a total surface density of target_density. The cylinder radii will be drawn from the selected distribution (if not set, a Gamma distribution is used with given mean_radius and var_radius). An error is raised if no solution for non-overlapping cylinders is found. Other cylinder parameters (besides radii, shifts, and repeats) are identical as in mr.cylinders.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.random_gauss-Tuple{Float64, Float64}","page":"API","title":"MCMRSimulator.random_gauss","text":"random_gauss(diffusivity, timestep)\n\nDraws a random step from a Gaussian distribution with a variance of 2 * diffusivity * timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.random_on_sphere-Tuple{}","page":"API","title":"MCMRSimulator.random_on_sphere","text":"random_on_sphere()\n\nDraws a random orientation on the unit sphere as a length-3 vector\n\nThe z-orientation is drawn a random number between -1 and 1. The angle in the x-y plane is drawn as a random number between 0 and 2Ï€. This results in an unbiased random distribution across the sphere.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.random_positions_radii-Tuple{Any, Real, Int64}","page":"API","title":"MCMRSimulator.random_positions_radii","text":"random_positions_radii(box_size, target_density, n_dimensions; distribution=Gamma, mean=1., variance=1., max_iter=1000)\n\nRandomly distributes circles or spheres in space.\n\nArguments:\n\nbox_size: Size of the infinitely repeating box of random positions\ntarget_density: Final density of the circles/spheres. This density will only be approximately reached\nn_dimensions: dimensionality of the space (2 for cicles; 3 for spheres)\ndistribution: distribution from which the radii are drawn (from Distributions.jl)\nmean: mean of the gamma distribution (ignored if distribution explicitly set)\nvariance: variance of the gamma distribution (ignored if distribution explicitly set)\nmax_iter: maximum number of iterations to try to prevent the circles/spheres from overlapping. An error is raised if they still overlap after this number of iterations.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.random_spheres-Tuple{Any}","page":"API","title":"MCMRSimulator.random_spheres","text":"random_spheres(target_density; repeats, distribution=Distributions.Gamma, mean_radius=1., variance_radius=0.5, max_iter=1000, rotation=I(3))\n\nGenerate infinitely repeating box with non-overlapping spheres.\n\nA box with the size of repeats will be filled with spheres for a total volume density of target_density. The sphere radii will be drawn from the selected distribution (if not set, a Gamma distribution is used with given mean_radius and var_radius). An error is raised if no solution for non-overlapping spheres is found. Other sphere parameters (besides radii, positions, and repeats) are identical as in mr.spheres.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.random_spirals-Tuple{Any}","page":"API","title":"MCMRSimulator.random_spirals","text":"random_spirals(target_density; repeats, g_ratio=0.8, distribution=Distributions.Gamma, mean_radius=1., variance_radius=0.5, max_iter=1000, rotation=I(3))\n\nGenerate infinitely repeating box with non-overlapping spirals.\n\nA rectangle with the size of repeats will be filled with spirals for a total surface density of target_density. The spiral outer radii will be drawn from the selected distribution (if not set, a Gamma distribution is used with given mean_radius and var_radius). An error is raised if no solution for non-overlapping annuli is found. The inner radius with respect to the outer radius is set by the g-ratio. Other spiral parameters (besides inner, outer, positions, and repeats) are identical as in mr.spirals.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.ray_grid_intersections-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Float64}, StaticArraysCore.SVector{N, Float64}}} where N","page":"API","title":"MCMRSimulator.ray_grid_intersections","text":"ray_grid_intersections([grid, ]origin, destination)\n\nComputes all voxels crossed by a ray between origin and destination with a GridShape (default infinitely extending 1x1x1 grid). Both origin and destination are length-3 vectors. The returned object is an iterator returning a tuple with:\n\n3-length vector with the voxel that we are crossing through\nFloat with the time the ray entered voxel (0=origin, 1=destination)\n3-length vector with position within voxel that the ray entered (i.e., numbers between 0 and 1)\nFloat with the time the ray left the voxel (0=origin, 1=destination)\n3-length vector with position within voxel that the ray left (i.e., numbers between 0 and 1)\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.read_pulseseq-Tuple{Any}","page":"API","title":"MCMRSimulator.read_pulseseq","text":"read_pulseseq(filename; scanner=Scanner(B0=B0), B0=3., TR=<sequence duration>)\n\nReads a sequence from a pulseq file (http://pulseq.github.io/). Pulseq files can be produced using matlab (http://pulseq.github.io/) or python (https://pypulseq.readthedocs.io/en/master/).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.readout-Union{Tuple{N}, Tuple{Any, Simulation{N}}} where N","page":"API","title":"MCMRSimulator.readout","text":"readout(snapshot, simulation)\n\nEvolves the spins in the Snapshot through the Simulation. Returns the Snapshot at every Readout in the simulated sequences during a single TR. If no TR is explicitly selected, it will return the current TR if the snapshot has not passed any readouts and the next TR otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.relax!","page":"API","title":"MCMRSimulator.relax!","text":"relax!(spin_orientation, timestep, mri, additional_off_resonance=0)\n\nUpdates [SpinOrientation] after evolving for timestep with given R1(mri) (1/ms), R2(mri) (1/ms), and off_resonance(mri) + additional_off_resonance (kHz).\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.rotate_bvec-Tuple{AbstractVector{<:Tuple{Real, Real}}, Any}","page":"API","title":"MCMRSimulator.rotate_bvec","text":"rotate_bvec(gradients, bvec)\n\nRotates the gradients in gradients to align with bvec.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.scatter_snapshot!-Tuple","page":"API","title":"MCMRSimulator.scatter_snapshot!","text":"plot(snapshot)\nplot!(snapshot)\nscatter_snapshot(snapshot)\nscatter_snapshot!(snapshot)\n\nPlots the spin positions in the Snapshot in 3D color coded by the spin's orientation (see color).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.scatter_snapshot-Tuple","page":"API","title":"MCMRSimulator.scatter_snapshot","text":"plot(snapshot)\nplot!(snapshot)\nscatter_snapshot(snapshot)\nscatter_snapshot!(snapshot)\n\nPlots the spin positions in the Snapshot in 3D color coded by the spin's orientation (see color).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.sequence_plot","page":"API","title":"MCMRSimulator.sequence_plot","text":"plot(sequence)\nplot!(sequence)\nplot_sequence(sequence)\nplot_sequence!(sequence)\n\nCreates a visual representation of a Sequence diagram.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.signal-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N","page":"API","title":"MCMRSimulator.signal","text":"signal(snapshot, simulation, times=[TR])\n\nEvolves the Snapshot through the Simulation and outputs the total signal at the requested times. To get the full snapshot at each timepoint use trajectory. Returns a vector of SpinOrientation object with the total signal at each time in times.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.spheres-Tuple","page":"API","title":"MCMRSimulator.spheres","text":"spheres(radii; positions=[[0, 0, 0]], repeats=[Inf, Inf, Inf], rotation=I(3))\n\nCreates one or more Spheres with given radius (or vector of radii). The positions, repeats, and rotation control the sphere positions and is explained in  more detail in Defining the geometry. Additional keyword arguments are available to set generic obstruction settings as described in ObstructionProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.spiral_theta-Tuple{Spiral, StaticArraysCore.SVector{2, Float64}}","page":"API","title":"MCMRSimulator.spiral_theta","text":"spiral_theta(spiral, position; assume_inner)\n\nComputes the location of the particle within the spiral. This function returns 0 if the particle has just entered the inner part of the spiral. Each wrap further outwards will add 2Ï€ to the result.\n\nWhen the particle is at the spiral edge, assume_inner should be set to true if the particle should be considered just on the inner side of the surface or to false if it should be considered just on the outer surface.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.spirals-Tuple","page":"API","title":"MCMRSimulator.spirals","text":"spirals(inner, outer; theta0=0., thickness=0.014, myelin=false, chi_I=-0.1, chi_A=-0.1, positions=[0, 0], repeats=[Inf, Inf], rotation=I(3)\n\nCreates one or more Spiral. Spirals range from inner to outer radii starting at an angle of theta0. Each wrap has a thickness of thickness micrometers. Inner/outer cylinders can be added using respectively the inner_cylinder and outer_cylinder flags (default: only inner cylinder).\n\nMyelinated spirals can be created by setting the myelin to true. All parameters can be either a single value or a vector of values.\n\nThe positions, repeats, and rotation control the annulus position and orientation and is explained in  more detail in Defining the geometry. Additional keyword arguments are available to set generic obstruction settings as described in ObstructionProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.total_susceptibility-Tuple{MCMRSimulator.BaseObstruction}","page":"API","title":"MCMRSimulator.total_susceptibility","text":"total_susceptibility(obstruction)\n\nComputes total surface (for 2D) or volume (for 3D) susceptibility of a base obstruction.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.trajectory-Union{Tuple{N}, Tuple{Any, Simulation{N}}, Tuple{Any, Simulation{N}, Any}} where N","page":"API","title":"MCMRSimulator.trajectory","text":"trajectory(snapshot, simulation, times=[TR])\n\nEvolves the Snapshot through the Simulation and outputs at the requested times. Returns a vector of Snapshot objects with the current state of each time in times. When you are only interested in the signal at each timepoint, use signal instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.transfer!-Tuple{SpinOrientation, Float64}","page":"API","title":"MCMRSimulator.transfer!","text":"transfer!(orientation, MT_fraction)\n\nLoses MT_fraction spin from orientation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.transverse","page":"API","title":"MCMRSimulator.transverse","text":"transverse(spin)\ntransverse(snapshot)\n\nReturns the transverse spin (i.e., magnitude in the plane perpendicular to the magnetic field) for a single particle (Spin) or averaged across a group of particles in a [Snapshot]. When orientations for multiple sequences are available an array of transverse values is returned with a value for each sequence.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.walls-Tuple{}","page":"API","title":"MCMRSimulator.walls","text":"walls(positions=0, repeats=Inf, rotation=I(3))\n\nCreates one or more Walls. The positions, repeats, and rotation control the wall position and orientation and is explained in  more detail in Defining the geometry. Additional keyword arguments are available to set generic obstruction settings as described in ObstructionProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieCore.plot!-Tuple{MakieCore.Combined{MCMRSimulator.dyad_snapshot}}","page":"API","title":"MakieCore.plot!","text":"dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)\ndyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)\n\nPlots the spins in the Snapshot projected onto given PlotPlane. Each spin is represented by an arrow showing the transverse component of the spin.\n\n\n\n\n\n","category":"method"},{"location":"off_resonance/#off_resonance","page":"Magnetic susceptibility","title":"Off-resonance field","text":"","category":"section"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"The off-resonance field will have three components:","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"A global offset or gradient caused by the head shape (set within the Microstructure or Simulation object).\nThe MRI gradients set within the sequence definition.\nThe local off-resonance field caused by myelin, iron, blood, etc. For now only myelin is supported as described in the rest of this section.","category":"page"},{"location":"off_resonance/#Myelin-off-resonance","page":"Magnetic susceptibility","title":"Myelin off-resonance","text":"","category":"section"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"The myelin surrounding some axons contributes to the off-resonance field experienced by the spins in the neighbourhood. Within MCMRSimulator.jl this off-resonance field is modeled in one of three ways:","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"As an infinitely narrow sheath surrounding the cylinders.\nAs uniform myelin between the inner and outer radius of an annulus.\nTODO: as a spiral\nTODO: as a mesh","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"By default all of these components do not generate an off-resonance field. The myelin will have to be explicitly turned on.","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"In all cases the magnetic susceptibility of myelin is set by two values:","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"the isotropic magnetic susceptibiility (chi_I flag)\nthe anisotropic magnetic susceptibiility (chi_A flag)","category":"page"},{"location":"off_resonance/#Myelinated_cylinders","page":"Magnetic susceptibility","title":"Myelinated cylinders","text":"","category":"section"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"The cylinder can be wrapped in a myelin sheath by setting g_ratio to a different value from 1. The myelin sheath will be infinitely thin, when considering collisions.","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"import Random; Random.seed!(2) # hide\nusing MCMRSimulator\n(positions, radii) = random_positions_radii((20, 20), 0.7, 2)\ngeometry = cylinders(radii; repeats=[20, 20], positions=positions, rotation=:y, g_ratio=0.6)\n\nusing CairoMakie\npp = PlotPlane(:y, size=20)  # plane used for plotting\nf = plot_off_resonance(pp, geometry)  # plot off-resonance field generated by geometry\nplot!(pp, geometry)  # plot the actual geometry\nsave(\"myelinated_cylinders.png\", f) # hide\nnothing # hide","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"(Image: Myelinated, thin cylinders)","category":"page"},{"location":"off_resonance/#Mathematical-details","page":"Magnetic susceptibility","title":"Mathematical details","text":"","category":"section"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"To still get realistic off-resonance fields for infinitely thin myelin shells, we have to slightly adjust the equations for the field generated by Samuel Wharton, Richard Bowtell (2012).  Within the cylinder the off-resonance field the field given by Samuel Wharton, Richard Bowtell (2012) is:","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"fracDelta omegaomega_0 = frac34 chi_A sin^2 theta ln left(fracr_or_iright)","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"Given a user-defined g-ratio (g=r_ir_o) this becomes:","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"fracDelta omegaomega_0 = -frac34 chi_A sin^2 theta ln g = omega_rm internal sin^2 theta","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"where omega_rm internal equiv -frac34 chi_A ln g is precomputed when the Cylinder is created. This is multiplied by sin^2 theta when callling off_resonance for the cylinder.","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"Outside of the cylinder the field is given by Samuel Wharton, Richard Bowtell (2012) as:","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"fracDelta omegaomega_0 = left(chi_I + chi_A4 right) sin^2 theta fraccos 2 phi2 fracr_0^2 - r_i^2r^2","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"Here are field depends on exactly how the inner and outer radius are related with the single cylinder radius (r_c). We choose r_c equiv (r_i + r_o)2. In that case r_0^2 - r_i^2 = 4 * r_c^2 frac1 - g^2(1 + g)^2 and hence:","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"fracDelta omegaomega_0 = 2 left(chi_I + chi_A4 right) sin^2 theta (2 cos^2 phi - 1) fracr_c^2r^2 frac1-g^2(1 + g)^2","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"where we have also used cos 2 phi = (2 cos^2 phi - 1). Once again we pre-compute most of this equation (omega_rm external equiv 2 left(chi_I + chi_A4 right) r_c^2 frac1-g^2(1 + g)^2 when the Cylinder is created. This is multiplied by sin^2 theta (2 cos^2 phi - 1)  r^2 when callling off_resonance for the cylinder.","category":"page"},{"location":"off_resonance/#Myelinated_annuli","page":"Magnetic susceptibility","title":"Myelinated annuli","text":"","category":"section"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"This fills the Annulus with myelin between the inner and outer radius. The off-resonance field from this myelin is given by Samuel Wharton, Richard Bowtell (2012).","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"import Random; Random.seed!(2) # hide\nusing MCMRSimulator\n(positions, radii) = random_positions_radii((20, 20), 0.7, 2)\ngeometry = annuli(0.6 .* radii, radii; repeats=[20, 20], positions=positions, rotation=:y, myelin=true)\n\nusing CairoMakie\npp = PlotPlane(:y, size=20)\nf = plot_off_resonance(pp, geometry)\nplot!(pp, geometry)\nsave(\"myelinated_annuli.png\", f) # hide\nnothing # hide","category":"page"},{"location":"off_resonance/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"(Image: Myelinated, thin annuli)","category":"page"},{"location":"obstructions/#geometry","page":"Geometry","title":"Obstructions to free diffusion","text":"","category":"section"},{"location":"obstructions/#Defining-the-geometry","page":"Geometry","title":"Defining the geometry","text":"","category":"section"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"MCMRSimulator.jl comes with a variety of basic components that can be used to represent various components in the tissue microstructure.","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"Component Class Constructor Dimensionality\ninfinite walls Wall walls 1\nhollow infinite cylinder Cylinder cylinders 2\nAnnulus with inner and outer cylinders Annulus annuli 2\nSpirals Spiral spirals 2\nhollow sphere Sphere spheres 3\nmesh Mesh see Defining a mesh 3","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"The constructors for these components all have a similar interface. Some expect certain component-specific arguments (e.g., radii for spheres and cylinders. Some also have component-specific keyword argumetns (e.g., the keywords regarding the off-resonance produces by Myelinated cylinders). MRI relaxation properties within the obstruction and collision parameters (magnetisation transfer rate & permeability) can be set using keyword arguments as described in ObstructionProperties. Finally, they expect a set of keyword arguments that control their location. These arguments are identicaly across all constructors (although the expected input depends on the dimensionality of the component as listed in the table above):","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"positions: Set the positions for each generated components\nrepeats: Set the distance with which all components should be repeated\nrotation: Applies a single rotation to the whole system.","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"Components with a lower dimensionality are defined by default along the x-axis (for dimensionality of 1) or the x-y plane (for dimensionality of 2).  In other words, the normal of the walls point in the x-axis by default, while the cylinders point in the z-axis. Shifts and repeats should only be provided in this lower-dimensional space. The rotation can be used to define these components along other lines/planes.","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"For example, we can create two base cylinders, which repeeat infinitely by running:","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"using MCMRSimulator\ngeometry = cylinders(sqrt(0.5), positions=[[0, 0], [1, 1]], repeats=[2, 2])\nusing CairoMakie # hide\nf = plot(PlotPlane(size=4), geometry) # hide\nsave(\"regular_cylinders.png\", f) # hide\nnothing # hide","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"(Image: Plot showing two cylinders repeating ad infinitum)","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"Alternatively, the same configuration could be produced with a single cylinder by providing a rotation.","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"using MCMRSimulator\nrotation = [\n    sqrt(0.5) sqrt(0.5) 0.\n    -sqrt(0.5) sqrt(0.5) 0.\n    0. 0. 1.\n    ]\ngeometry = cylinders(sqrt(0.5), repeats=[sqrt(2), sqrt(2)], rotation=rotation)\nusing CairoMakie # hide\nf = plot(PlotPlane(size=4), geometry) # hide\nsave(\"regular_cylinders2.png\", f) # hide\nnothing # hide","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"(Image: Plot showing single cylinders repeating ad infinitum)","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"Myelin can be added to the cylinders, spirals, or annuli as described here.","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"A geometry is defined by either the TransformObstruction returned by a single call to these constructors or by an array of TransformObstruction objects.","category":"page"},{"location":"obstructions/#Randomly-distributed-cylinders/annuli/spirals","page":"Geometry","title":"Randomly distributed cylinders/annuli/spirals","text":"","category":"section"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"A random set of positions and radii can be created using random_positions_radii. The user in this case sets a target density (70% in the example below) and over which length scale the configuration should repeat itself (20x20 micrometer in the example below).","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"using MCMRSimulator # hide\n(positions, outer_radii) = random_positions_radii((20, 20), 0.7, 2)\nnothing # hide","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"These can be used to produce randomly distributed cylinders:","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"geometry = cylinders(outer_radii; positions=positions, repeats=(20, 20))\nusing CairoMakie # hide\nf = plot(PlotPlane(size=20), geometry) # hide\nsave(\"random_cylinders.png\", f) # hide\nnothing # hide","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"(Image: Illustrating configuration of random cylinders)","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"When used as initialisation for annuli or spirals, an inner radius will also need to be computed:","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"inner_radii = 0.8 .* outer_radii\ngeometry = annuli(inner_radii, outer_radii; positions=positions, repeats=(20, 20))\nusing CairoMakie # hide\nf = plot(PlotPlane(size=20), geometry) # hide\nsave(\"random_annuli.png\", f) # hide\nnothing # hide","category":"page"},{"location":"obstructions/","page":"Geometry","title":"Geometry","text":"(Image: Illustrating configuration of random annuli)","category":"page"},{"location":"obstructions/#Defining-a-mesh","page":"Geometry","title":"Defining a mesh","text":"","category":"section"},{"location":"sequence/#sequence","page":"Sequence","title":"MR sequences","text":"","category":"section"},{"location":"sequence/#Pulseseq-sequences","page":"Sequence","title":"Pulseseq sequences","text":"","category":"section"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"The recommended way to define sequences is to use pulseq sequence format (http://pulseq.github.io/). Pulseq sequences can be generated using matlab (http://pulseq.github.io/) or python (https://pypulseq.readthedocs.io/en/master/). They can be loaded into MCMRSimulator using read_pulseq.","category":"page"},{"location":"sequence/#Built-in-MR-sequences","page":"Sequence","title":"Built-in MR sequences","text":"","category":"section"},{"location":"sequence/#Diffusion-weighted-MRI","page":"Sequence","title":"Diffusion-weighted MRI","text":"","category":"section"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"A pulsed-gradient spin-echo can be created using dwi","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"using MCMRSimulator # hide\nsequence = dwi(TR=100., bval=3.)\nusing CairoMakie # hide\nf = plot(sequence) # hide\nsave(\"dwi_sequence.png\", f) # hide\nnothing # hide","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"(Image: DWI sequence diagram)","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"using MCMRSimulator # hide\nsequence = dwi(TR=100., bval=3., gradient_duration=0.)\nusing CairoMakie # hide\nf = plot(sequence) # hide\nsave(\"dwi_sequence_delta_0.png\", f) # hide\nnothing # hide","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"(Image: DWI sequence diagram with instanteneous gradients)","category":"page"},{"location":"sequence/#Custom-MR-sequences","page":"Sequence","title":"Custom MR sequences","text":"","category":"section"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"In MCMRSimulator.jl an MR Sequence describes the RF pulses and gradients applied by the MRI scanner.","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"This sequence contains of:","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"RF pulses, which can be instantaneous (InstantRFPulse) or be described more realistically as RF amplitude/phase profiles ([RFPulse])\nGradients. Like RF pulses they can be approximated as instanteneous (InstantGradient) or have a finite duration (MRGradients)\nReadouts (Readout). These are always instanteneous as realistic modelling of an actual MRI readout would require modelling the whole brain and receiver coil configuration, which is far beyond the scope of this simulator.","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"Each of these sequence components will play identically every repetition time (TR) of the sequence.","category":"page"},{"location":"sequence/#Defining-the-MR-gradients","page":"Sequence","title":"Defining the MR gradients","text":"","category":"section"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"The MRI scanner gradients cause the spins to precess at different rates in different part of the tissue. This encodes the spin location into the spin orientation and can hence be used to measure the movement of spins (e.g., in diffusion-weighted MRI). Crusher gradients are also commonly used to get rid of unwanted signal contributions due to imperfect RF pulses.","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"The gradient profile over time can be modeled as a MRGradients object.  The off-resonance field at a specific time (or integrated over a timespan) and position can be computed using gradient.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MCMRSimulator.jl allows simulation of MR signal generation using Monte Carlo simulations. The spin evolution of randomly diffusing particles is tracked under influence of one or more MR sequences. At present, the simulator allows to model","category":"page"},{"location":"","page":"Home","title":"Home","text":"Free diffusion and diffusion restricted by walls, cylinders, spirals (experimental, spheres, or meshes\nT1 and T2 relaxation using global T1/T2 parameters\nMR sequences consisting of RF pulses, gradients, and readouts\nOff-resonance field generation by myelinated cylinders\nMagnetisation transfer between liquid spins and membranes\nMembrane permeability (i.e., exchange)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Future (potential) features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Surface tension of membranes causing spins to get temporarily \"stuck\" when they hit a membrane\nKeeping track of the membrane longitudinal magnetisation (allowing for more realistic magnetisation transfer)\nOff-resonance field generated by myelinated meshes\nOff-resonance field by iron particles\nContribution from metabolites (i.e., spectroscopy)","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: beta\nThis MR simulator is still under very active development and the API might still change substantially at any time!","category":"page"},{"location":"","page":"Home","title":"Home","text":"We use the following units throughout (unless otherwise noted):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Times are in ms. Equivalently, RF pulse amplitudes and off-resonance fields are in kHz (i.e., 1/ms).\nPositions are in um. So, gradients are in kHz/um (not mT/m).\nAngles are in degrees (not radians). These are used for phases (of spins and RF pulses) as well as RF pulse flip angles. \nSusceptibilities are in ppm.","category":"page"},{"location":"#Movie-of-spins-moving-through-cylinders","page":"Home","title":"Movie of spins moving through cylinders","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<iframe src=\"https://ox.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=b6211751-2743-4bb8-b65a-af5d011a8684&autoplay=true&offerviewer=false&showtitle=false&showbrand=false&captions=false&interactivity=none\" style=\"border: 1px solid #464646;\" allowfullscreen allow=\"autoplay\"></iframe>","category":"page"},{"location":"#installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First install julia (e.g., from the official website or using juliaup).\nStart julia in the terminal ($ julia).\nEnter the package manager by pressing \"]\"\nInstall MCMRSimulator.jl (pkg> add https://git.fmrib.ox.ac.uk/ndcn0236/mcmrsimulator.jl.git)\nInstall one of the Makie backends for plotting (e.g., pkg> add CairoMakie)\nPress \"[backspace]\" to leave the package manager","category":"page"},{"location":"","page":"Home","title":"Home","text":"After this installation, you should be able to follow the steps in the tutorial below or create your own simulations.","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This tutorial will walk through an example of modelling the MRI signal evolution for a diffusion-weighted sequence. The spins in this simulation will be constrained by regularly packed cylinders. After installation we can load MCMRSimulator.jl using","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MCMRSimulator\nusing CairoMakie  # used for plotting; use GLMakie or WGLMakie for interactive plots","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, running a simulation will consist of the following three steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Defining the microstructure and on or more sequences by creating an appropriate Simulation object.\nInitialising one or more Spin objects.\nSimulating a random walk of the spins through the microstructure and the MR signal produced by those spins.\nPlotting the MR signal or storing it to disk.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We will look through each of these steps below.","category":"page"},{"location":"#Defining-the-simulation","page":"Home","title":"Defining the simulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The first step is to define the environment through which the spins will evolve. We will do so by creating an appropriate Simulation object. This Simulation will contain information on the microstructure, the MR physics, and the enabled sequences.","category":"page"},{"location":"","page":"Home","title":"Home","text":"These different steps are described in more detail in other sections of this documentation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"How to define the microstrutural geometry\nGenerate off-resonance fields due to the microstructural geometry\nSequence generation","category":"page"},{"location":"","page":"Home","title":"Home","text":"First we will define the geometry formed of regularly packed axons. This is represented by a single cylinder with a radius of 1 micrometer that repeats itself every 2.5 micrometer (in both the x-, and y-direction).","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Random; Random.seed!(1) # hide\ngeometry = cylinders(1., repeats=[2.5, 2.5])\n\nf = plot(PlotPlane(size=5), geometry)\nsave(\"tutorial_geometry.png\", f) # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: ) More complicated geometries can be generated as described here including geometries with magnetic susceptibility that produce off-resonance fields (see here).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The next step is to define a sequence.  Here we will adopt a single diffusion-weighted MRI sequence.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sequence = dwi(bval=2., TR=300, TE=80, scanner=Siemens_Prisma)  # default gradient orientation in the x-direction\nf = plot(sequence)\nsave(\"tutorial_sequence.png\", f); # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once we have both a geometry and one or more sequences, we can put them together in a Simulation object (click on this object for more details on the many options available when setting up a simulation):","category":"page"},{"location":"","page":"Home","title":"Home","text":"simulation = Simulation(sequence, R2=0.012, R1=3e-3, diffusivity=2., off_resonance=0.1, geometry=geometry)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that we actually have to set the R2, R1, and diffusivity to non-zero values to enable those pieces of physics.","category":"page"},{"location":"#Initialising-the-simulation","page":"Home","title":"Initialising the simulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We can initialise the simulation in one of three ways:","category":"page"},{"location":"","page":"Home","title":"Home","text":"An integer value indicating the number of spins to be simulated. The spins will be randomly distributed through a 1mm x 1mm x 1mm voxel and start in equilibrium.\nA sequence of positions (i.e., length-3 vectors) with the initial spin positions.\nA Snapshot (i.e., collection of spins with a timestamp) from a previous simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We will see examples of all three below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each Spin represents a single diffusing particle. Besides containing its current position, it also contains its contribution to the MR signal for each of the sequences in the simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At each timepoint the current state of the spins is represented by a Snapshot.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Deterministic spins\nEach Spin is assigned a random number state at creation, which will be used for its future evolution. This means that after creation of a spin or a Snapshot its future is fully determined. This ensures that when a spin is evolved through the same simulation multiple times, it sill follow the same path each time. This allows improved comparisons between simulations with the same geometry, but different sequences/physics. However, it can lead to confusing results (e.g., a simulation initialised with fill(Spin(), 500) will contain 500 spins all following the exact same path).","category":"page"},{"location":"#Running-the-simulation","page":"Home","title":"Running the simulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Running the simulation is done through 4 functions, for which examples are shown below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"trajectory: follow the full state evolution for a small number of spins\nevolve: evolve a large number of spins for a specific time\nreadout: return the spin states at the time of the sequence readouts\nsignal: return the average signal at high temporal resolution","category":"page"},{"location":"#Illustrating-trajectories","page":"Home","title":"Illustrating trajectories","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We will start by illustrating the 2D trajectory for two spins, one inside and one outside of the cylinder. To plot the trajectory we first need to output the state of the all spins at a high temporal resolution, which can be done using trajectory:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Simulate 2 spins with given starting positions for 3 ms\nsnapshots = trajectory([[0, 0, 0], [1, 1, 0]], simulation, 0:0.01:3.)\n\npp = PlotPlane(size=5.)\nf = plot(pp, geometry)\nplot_trajectory2d!(pp, snapshots)\nsave(\"tutorial_trajectory2D.png\", f) # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: ) In this plot the color at each timepoint encodes the spin orientation. The brightness of the spin indicates the size of the transverse component with purely longitudinal spins being in black. The color of the spin encodes the phase of the MR signal in the transverse plane.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The trajectories can also be plotted in 3D:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f = plot_trajectory3d(snapshots)\nsave(\"tutorial_trajectory3D.png\", f) # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"When simulating a large number of spins, storing the spin state every timestep would become very memory-intensive. To get around this we will typically either store the average signal at a high temporal resolution or the full state at a low resolution. Let's have a look of examples for both.","category":"page"},{"location":"#Signal-evolution","page":"Home","title":"Signal evolution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To store the total signal evolution we can use signal. At each timepoint this will return the total MR signal (for each sequence) as a SpinOrientation object. From this one can estimate the transverse component, the longitudinal component, and the phase. Here we plot the transverse component of the signal evolution as an example","category":"page"},{"location":"","page":"Home","title":"Home","text":"times = 0:0.1:sequence.TR\naverage_signals = signal(3000, simulation, times)  # simulate 3000 spins for a single repetition time\nf = plot(sequence)\nlines!(times, transverse.(average_signals)/3000.)\nsave(\"tutorial_transverse.png\", f) # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Readout-at-specific-times","page":"Home","title":"Readout at specific times","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We can return a Snapshot at any time simply by running:","category":"page"},{"location":"","page":"Home","title":"Home","text":"snapshot = evolve(3000, simulation, 80.)\npp = PlotPlane(size=2.5)\nf = plot(pp, snapshot)\nplot!(pp, geometry)\nsave(\"tutorial_snapshot.png\", f) # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: ) The color encoding is the same as for the trajectory plot above. The brightness encodes the size of the transverse component, while the color encodes the phase of the MR signal in the transverse plane. We can see that outside of the cylinder the signal contribution is significantly reduced. The black arrows show the transverse spin for some random spins.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The snapshot returned by evolve can be used as a starting point for further simulations. We can use this to plot the longitudinal signal at the first and third TR using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"first_TR_start = Snapshot(1000)\nfifth_TR_start = evolve(first_TR_start, simulation, sequence.TR * 2)\n\nf = plot(sequence)\n\ntimes = 0:0.1:100.\nfor start in (first_TR_start, fifth_TR_start)\n    simulated_signals = signal(start, simulation, times .+ start.time)\n    lines!(times, longitudinal.(simulated_signals)/3000., cycle=[:color])\nend\nsave(\"tutorial_longitudinal.png\", f) # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sequences will usually contain one or more Readout objects to mark the readout times. To get the Snapshot at these readouts during one repetition time, you can use readout.","category":"page"}]
}
