var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Callaghan, R.; Alexander, D. C.; Palombo, M. and Zhang, H. (2020). Config: Contextual Fibre Growth to Generate Realistic Axonal Packing for Diffusion Mri Simulation. NeuroImage 220, 117107.\n\n\n\nGinsburger, K.; Matuschke, F.; Poupon, F.; Mangin, J.-F. c.; Axer, M. and Poupon, C. (2019). MEDUSA: A GPU-based Tool to Create Realistic Phantoms of the Brain Microstructure Using Tiny Spheres. Neuroimage 193, 10–24.\n\n\n\nPalombo, M.; Alexander, D. C. and Zhang, H. (2019). A Generative Model of Realistic Brain Cells with Application to Numerical Simulation of the Diffusion-Weighted MR Signal. NeuroImage 188, 391–402. Accessed on Nov 16, 2022.\n\n\n\nVillarreal-Haro, J. L.; Gardier, R.; Canales-Rodríguez, E. J.; Fischi-Gomez, E.; Girard, G.; Thiran, J.-P. and Rafael-Patiño, J. (2023). CACTUS: A Computational Framework for Generating Realistic White Matter Microstructure Substrates. Frontiers in Neuroinformatics 17. Accessed on Aug 22, 2023.\n\n\n\n","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = MCMRSimulator","category":"page"},{"location":"api/#api","page":"API","title":"MCMRSimulator.jl API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This is the API for MCMRSimulator. For a more user-friendly introduction, click here.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [\n    MCMRSimulator,\n    MCMRSimulator.Constants,\n    MCMRSimulator.Methods,\n    MCMRSimulator.Properties,\n    MCMRSimulator.Geometries,\n    MCMRSimulator.Geometries.User,\n    MCMRSimulator.Geometries.User.Obstructions,\n    MCMRSimulator.Geometries.User.Obstructions.Fields,\n    MCMRSimulator.Geometries.User.Obstructions.ObstructionTypes,\n    MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups,\n    MCMRSimulator.Geometries.User.Fix,\n    MCMRSimulator.Geometries.User.FixSusceptibility,\n    MCMRSimulator.Geometries.User.LoadMesh,\n    MCMRSimulator.Geometries.User.RandomDistribution,\n    MCMRSimulator.Geometries.User.SplitMesh,\n    MCMRSimulator.Geometries.User.JSON,\n    MCMRSimulator.Geometries.User.ToMesh,\n    MCMRSimulator.Geometries.Internal,\n    MCMRSimulator.Geometries.Internal.RayGridIntersection,\n    MCMRSimulator.Geometries.Internal.BoundingBoxes,\n    MCMRSimulator.Geometries.Internal.Obstructions,\n    MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections,\n    MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions,\n    MCMRSimulator.Geometries.Internal.Obstructions.Walls,\n    MCMRSimulator.Geometries.Internal.Obstructions.Rounds,\n    MCMRSimulator.Geometries.Internal.Obstructions.Triangles,\n    MCMRSimulator.Geometries.Internal.Obstructions.Shifts,\n    MCMRSimulator.Geometries.Internal.Gridify,\n    MCMRSimulator.Geometries.Internal.Intersections,\n    MCMRSimulator.Geometries.Internal.Reflections,\n    MCMRSimulator.Geometries.Internal.FixedObstructionGroups,\n    MCMRSimulator.Geometries.Internal.Properties,\n    MCMRSimulator.Geometries.Internal.Susceptibility,\n    MCMRSimulator.Geometries.Internal.Susceptibility.Base,\n    MCMRSimulator.Geometries.Internal.Susceptibility.Parent,\n    MCMRSimulator.Geometries.Internal.Susceptibility.Cylinder,\n    MCMRSimulator.Geometries.Internal.Susceptibility.Annulus,\n    MCMRSimulator.Geometries.Internal.Susceptibility.Triangle,\n    MCMRSimulator.Geometries.Internal.IsInsideMesh,\n    MCMRSimulator.Spins,\n    MCMRSimulator.TimeSteps,\n    MCMRSimulator.Relax,\n    MCMRSimulator.SequenceParts,\n    MCMRSimulator.Simulations,\n    MCMRSimulator.Subsets,\n    MCMRSimulator.Evolve,\n    MCMRSimulator.Plot,\n    MCMRSimulator.CLI,\n    MCMRSimulator.CLI.Geometry,\n    MCMRSimulator.CLI.Run,\n]","category":"page"},{"location":"geometry/#geometry","page":"Geometry","title":"Obstructions to free diffusion","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"MCMRSimulator.jl comes with a variety of basic components that can be used to represent various components in the tissue microstructure.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Component: infinite walls hollow cylinder myelinated annuli hollow sphere mesh bendy cylinder\nConstructor (Julia) Walls Cylinders Annuli Spheres Mesh BendyCylinder\nConstructor (CLI) mcmr geometry create walls mcmr geometry create cylinders or mcmr geometry create-random cylinders mcmr geometry create annuli or mcmr geometry create-random annuli mcmr geometry create spheres or mcmr geometry create-random spheres Generate mesh from tissue samples or generative models (e.g., (Palombo et al., 2019), (Ginsburger et al., 2019), (Callaghan et al., 2020), (Villarreal-Haro et al., 2023)) mcmr geometry create bendy-cylinder\nHinder diffusion ✅ ✅  ✅ ✅ ✅\nSurface relaxation ✅ ✅  ✅ ✅ ✅\nMagnetisation transfer ✅ ✅  ✅ ✅ ✅\nGenerate off-resonance field  ✅ ✅  ✅ ✅\nDifferent relaxation inside  ✅ ✅ ✅ ✅ ✅\nIntrinsic dimensionality 1 2 2 3 3 3","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"The constructors for these components all have a similar interface. Some expect certain component-specific keyword arguments (e.g., radius for Spheres and Cylinders, or the keywords regarding the myelin-induced off-resonance field produced by Cylinders or Annuli). MRI relaxation properties within the obstruction and collision parameters (stuck spins, magnetisation transfer rate & permeability) can be set using keyword arguments as described in the properties section. Finally, these constructors expect a set of keyword arguments that control their location. These arguments are identicaly across all constructors (although the expected input depends on the dimensionality of the component as listed in the table above):","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"position: Set the positions for each generated components (not used in Mesh).\nrepeats: Set the distance with which all components should be repeated.\nrotation: Applies a single rotation to the whole system.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Components with a lower dimensionality are defined by default along the x-axis (for dimensionality of 1) or the x-y plane (for dimensionality of 2).  In other words, the normal of the Walls point in the x-axis by default, while the Cylinders point in the z-axis. Shifts and repeats should only be provided in this lower-dimensional space. The rotation keyword can be used to define these components along other lines/planes (see get_rotation).","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"From the command line all of these keywords are available as flags, which can be seen by running:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"mcmr geometry create walls/cylinders/annuli/spheres/bendy_cylinder --help","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"In Julia, the easiest way to get the documentation for all keywords is to run:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"?Walls/Cylinders/Annuli/Spheres/Mesh/BendyCylinder","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"or by following the links in the table above.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"For example, we can create two base cylinders, which repeat infinitely by running:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"using MCMRSimulator\ngeometry = Cylinders(radius=sqrt(0.5), position=[[0, 0], [1, 1]], repeats=[2, 2])\nusing CairoMakie # hide\nf = plot(PlotPlane(size=4), geometry) # hide\nsave(\"regular_cylinders.png\", f) # hide\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"(Image: Plot showing two cylinders repeating ad infinitum)","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Alternatively, the same configuration could be produced with a single cylinder by providing a rotation.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"using MCMRSimulator\nrotation = [\n    sqrt(0.5) sqrt(0.5) 0.\n    -sqrt(0.5) sqrt(0.5) 0.\n    0. 0. 1.\n    ]\ngeometry = Cylinders(radius=sqrt(0.5), repeats=[sqrt(2), sqrt(2)], rotation=rotation)\nusing CairoMakie # hide\nf = plot(PlotPlane(size=4), geometry) # hide\nsave(\"regular_cylinders2.png\", f) # hide\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"(Image: Plot showing single cylinders repeating ad infinitum)","category":"page"},{"location":"geometry/#Randomly-distributed-cylinders/annuli/spirals","page":"Geometry","title":"Randomly distributed cylinders/annuli/spirals","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"A random set of positions and radii can be created using random_positions_radii. The user in this case sets a target density (70% in the example below) and over which length scale the configuration should repeat itself (20x20 micrometer in the example below).","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"using MCMRSimulator # hide\nusing Random; Random.seed!(1234) # hide\n(positions, outer_radii) = random_positions_radii((20, 20), 0.7, 2)\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"From the command line this functionality is available by running mcmr geometry create-random cylinders/annuli/spheres.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"These can be used to produce randomly distributed cylinders:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"geometry = Cylinders(radius=outer_radii, position=positions, repeats=(20, 20))\nusing CairoMakie # hide\nf = plot(PlotPlane(size=20), geometry) # hide\nsave(\"random_cylinders.png\", f) # hide\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"(Image: Illustrating configuration of random cylinders)","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"When used as initialisation for annuli or spirals, an inner radius will also need to be computed:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"geometry = Annuli(inner=0.8 .* outer_radii, outer=outer_radii, position=positions, repeats=(20, 20))\nusing CairoMakie # hide\nf = plot(PlotPlane(size=20), geometry) # hide\nsave(\"random_annuli.png\", f) # hide\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"(Image: Illustrating configuration of random annuli)","category":"page"},{"location":"tutorial_cli/#tutorial_cli","page":"Tutorial (CLI)","title":"Tutorial","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"This tutorial will walk through an example of modelling the MRI signal evolution for a diffusion-weighted sequence. The spins in this simulation will be constrained by regularly packed cylinders. This tutorial will use the command line interface, which we assume is available through the mcmr command (see installation instructions). If you would prefer to interact with MCMRSimulator in Julia, you can find a tutorial doing the same analysis here.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The command line tool requires one or more MRI sequence definitions as input. These can be supplied as pulseq files, such as those produced by MRIBuilder.jl.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"In general, running a simulation will consist of the following two steps:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"Creating a geometry using one or more calls to mcmr geometry (full description).\nRunning the actual simulation using mcmr run.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We will look through each of these steps below.","category":"page"},{"location":"tutorial_cli/#Defining-the-geometry","page":"Tutorial (CLI)","title":"Defining the geometry","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"First we will define a geometry formed of regularly packed axons. This is represented by a single cylinder pointing in the z-direction with a radius of 1 micrometer that repeats itself every 2.5 micrometer (in both the x-, and y-direction).","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr geometry create cylinders 1 geometry.json --radius 1 --repeats 2.5,2.5","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"geometry create cylinders 1 geometry.json --radius 1 --repeats 2.5,2.5\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"This will create a JSON file with the full information on the geometry:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\ntext = read(\"geometry.json\", String)\nMarkdown.parse(\"```json\\n$(text)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"You can see how that the repeats and radius keywords have been set to our predefined values. You can alter these and other geometry properties by editing this JSON directly or using the flags when creating the geometry. For a full overview of these flags, you can run:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr geometry create cylinders --help","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"geometry create cylinders --help\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"How these various properties affect the simulation is described here.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The procedure to create Walls, Spheres, or Annuli is very similar as for the Cylinders illustrated above. Randomly distributed cylinders, annuli, and spheres can be created using mcmr geometry create-random.","category":"page"},{"location":"tutorial_cli/#Defining-the-sequence","page":"Tutorial (CLI)","title":"Defining the sequence","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"In this case we will use an idealised DWI sequence produced by MRIBuilder.jl. Note that any pulseq file can be used instead.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"using MRIBuilder\nseq = DWI(TE=80, bval=2., Δ=40, δ=:min, TR=2000)\nwrite_sequence(\"dwi.seq\", seq)\n\n# Optional to plot the sequence\nusing CairoMakie\nf = plot_sequence(seq)\nf\nsave(\"tutorial_cli_sequence.png\", f); # hide\nnothing # hide","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"(Image: )","category":"page"},{"location":"tutorial_cli/#Running-the-simulation","page":"Tutorial (CLI)","title":"Running the simulation","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"To get instructions on running the simulations, we can check the help message of mcmr run:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run --help","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run --help\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We can see that in addition to defining the geometry and the sequence, we can also control the simulation properties such as the --diffusivity, --R1, and --R2.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The simulation is initialised by randomly distributing a number of spins (set by --Nspins) uniformly across a bounding box with size given by --voxel-size. This initial state might also contain bound spins (if the --density flag was set to a non-zero value during the geometry generation).","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The DWI sequence defined above contains a MRIBuilder.SingleReadout object at the echo time (80 ms). By default, this is used for readout:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run geometry.json dwi.seq -o signal.csv","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run geometry.json dwi.seq -o signal.csv --seed=1\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"This produces the CSV file, which looks like","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\ntext = read(\"signal.csv\", String)\nMarkdown.parse(\"```\\n$(text)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The columns in this file store the following information:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"\"sequence\": integer; index of the sequence (always 1 if only single sequence used)\n\"bvec\": integer; index of the gradient orientation (if a --bvec flag is provided)\n\"TR\": integer; index of the repetition time that this data was acquired (between 1 and the value of --nTR)\n\"readout\": integer; index of the readout within a TR.\n\"subset\": integer; index of the subset of the total signal (e.g., intra-axonal) that has been output (see the --subset flag). The total signal will always be included with \"subset\" of 0.\n\"nspins\": total number of spins contributing to the signal (might change for certain subsets of spins)\n\"longitudinal\": average longitudinal signal\n\"transverse\": average transverse signal\n\"phase\": average phase of the signal (in degrees)\n\"Sx\": signal strength in the x-direction\n\"Sy\": signal strength in the y-direction","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We can also output the signal of specific subsets of spins. For example, in the following we request to separately the output for just the spins inside the cylinders and just the spins outside of the cylinders.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run geometry.json dwi.seq -o signal.csv --subset inside --subset outside","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run geometry.json dwi.seq -o signal2.csv --subset inside --subset outside --seed=2\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We can see two additional rows in the output.  These new rows are the in same order as the --subset flags provided to mcmr run and can be distinguished based on the \"subset\" column.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\ntext = read(\"signal2.csv\", String)\nMarkdown.parse(\"```\\n$(text)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We can see in the second row that inside the cylinders the transverse signal is very close to the number of spins,  indicating that there has been very little dephasing due to the diffusion weighting inside the cylinders. On the other hand, we did lose most of the signal outside of the cylinders (i.e., the transverse signal is much lower than the number of spins in the third row). All the spins are either inside or outside the cylinders, so in this case the first row is simply the sum of the next two.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"A more complete state of all the spins can be produced using the --output-snapshot flag. For example, the command","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run geometry.json dwi.seq --output-snapshot snapshot.csv","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run geometry.json dwi.seq --output-snapshot snapshot.csv --seed=3\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"will produce a file named \"snapshot.csv\" with:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\nlines = split(read(\"snapshot.csv\", String), '\\n')\ntext = join(lines[1:5], '\\n')\nMarkdown.parse(\"```csv\\n$(text)\\n...\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"Each row corresponds to the state of a single spin. In addition to all the columns listed above, we now have 4 more columns:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"\"spin\": integer; index of the spin\n\"x\"/\"y\"/\"z\": floats; position of the spin at the time of the readout","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The readout times can be adjusted using the --nTR, --time, and --skip-TR flags.","category":"page"},{"location":"properties/#properties","page":"MRI/collision properties","title":"Simulation properties","text":"","category":"section"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"How the spins behave is determined by the tissue geometry, the applied MRI sequences, and user-provided flags determining how the spin magnetisation evolves. Here we discuss how the spin magnetisation evolution can be affected by these user-provided flags.","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"For example, one such flag is the diffusivity, which can be set as a keyword argument while generating the Simulation.","category":"page"},{"location":"properties/#MRI-properties","page":"MRI/collision properties","title":"MRI properties","text":"","category":"section"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"MRI properties determine the spin evolution for free and stuck particles. They include:","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"the longitudinal relaxation rate R1\nthe transverse relaxation rate R2\nthe global off_resonance field (i.e., any off-resonance not caused by the sequence or the geometry)","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"At the Simulation level these parameters can be set by supplying the R1, R2, or off_resonance flags (see GlobalProperties), such as:","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"simulation = Simulation(sequences, R2=1/80)","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"These MRI properties can be locally altered when defining the geometry. In the geometry they can be seperately set for spins stuck to the geometry surface or those spins that are inside specific objects in the geometry. The total relaxation rate (and off-resonance field) is set by the sum of the global value, the value set for any surface the spin is stuck to, and the value set for any obstruction that the spin is inside of. A single spin might be inside of multiple obstructions at once, if they overlap. In that case, all of the overlapping compartments will be considered. For the off-resonance field there might also be a contribution of the magnetic suscpetibility of any Cylinders, Annuli, or Mesh.","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"If not set at the global or local level, there will be no longitudinal or transverse relaxation and there will be no off-resonance field.","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"From the command line interface, the global parameters are set during the mcmr run command using --diffusivity, --R1, and --R2 keywords. Local parameters will already have been set at an earlier stage during the creation of the geometry using mcmr geometry create/create-random.","category":"page"},{"location":"properties/#Collision-properties","page":"MRI/collision properties","title":"Collision properties","text":"","category":"section"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"Collision properties determine the behaviour of spins at the time of a collision. Like MRI properties they can be set at the global level (while creating Simulation) or overwritten at the local level (geometry). There are four such properties:","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"MCMRSimulator.surface_relaxivity: the fraction of transverse signal lost (and longitudinal signal regained) at every collision. This fraction is adjusted to take into account the timestep (see MCMRSimulator.correct_for_timestep). Note that this is not the recommended way to model magnetisation transfer. Instead, we recommend using the surface_density as discussed below.\nMCMRSimulator.permeability: the probability of the spin passing through the surface. If the spins do not pass through, they will undergo regular reflection (or get stuck, see below). Like MT_fraction it will be adjusted to take into account the timestep (see MCMRSimulator.correct_for_timestep).\nMCMRSimulator.surface_density and MCMRSimulator.dwell_time: These control the density and dwell time of spins on the surface. Depending on the MRI properties assigned to these stuck particles (see above), these stuck particles can be used to represent water stuck at the membranes due to surface tension or spins in the membrane itself (which is in exchange with the free water through magnetisation transfer).","category":"page"},{"location":"installation/#installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"MCMRSimulator is an application written in the Julia language. You can run simulations either directly from the Julia REPL, in a Jupyter notebook, or using the command line interface.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"For now, it is only possible to install MCMRSimulator using the built-in Julia package manager.  In the future, we will also provide docker and singularity images to make it possible to run the command line interface without installing julia.","category":"page"},{"location":"installation/#global_julia","page":"Installation","title":"Global Julia installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"First install julia from the official website.\nChoose a directory, where you will install MCMRSimulator. If you want to install a single version of MCMRSimulator, this might just be any folder in your home directory. If you want to associate the MCMRSimulator with a specific project, you might want to select a directory within that project. We will refer to this chosen directory below as \"<project_dir>\".\nStart the julia REPL in a terminal ($ julia --project=<project_dir>).\nEnter the package manager by pressing \"]\"\nInstall MCMRSimulator.jl using pkg> add https://git.fmrib.ox.ac.uk/ndcn0236/mcmrsimulator.jl.git.\n(Optional) Install one of the Makie backends for plotting (e.g., pkg> add CairoMakie).\n(Optional) If you want to use a Jupyter notebook, you will also have to install IJulia. You can find instructions to do so at https://github.com/JuliaLang/IJulia.jl.\nPress \"[backspace]\" to leave the package manager.\n(Optional) To install the MCMRSimulator command line interface (CLI) run the following in the main julia REPL: using MCMRSimulator; MCMRSimulator.install_cli(destdir=\"...\"), where destdir is the target directory for the executable (called mcmr by default). Ensure that the destdir is a directory that is in your PATH variable.","category":"page"},{"location":"installation/#Running-MCMRSimulator","page":"Installation","title":"Running MCMRSimulator","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"After this installation process, you can run MCMRSimulator in one of the following ways:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia REPL: Start the REPL in a terminal by typing $ julia --project=<project_dir>. Afterwards type using MCMRSimulator to import the simulator. You can now follow the steps in the MCMRSimulator tutorial using Julia.\nJupyter notebook: Make sure that you install IJulia using the instructions above. This will allow you to start a notebook in jupyter running in Julia. Within this notebook, you can follow the steps in the MCMRSimulator tutorial using Julia.\nCommand line interface: If you followed the instructions in step 4 above, you can run the MCMRSimulator command line interface simply by typing mcmr in the terminal. If it is not working, you might want to redo step 4 above and pay attention to any warning messages. With this alias set up, you can now follow the command line tutorial.","category":"page"},{"location":"installation/#Updating-MCMRSimulator","page":"Installation","title":"Updating MCMRSimulator","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"First check the changelog to find a list of changes since your current version. If you decide to update:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Start the julia REPL again in a terminal ($ julia --project=<project_dir>)\nEnter the package manager by pressing \"]\"\nUpdate all installed packages using by typing update and pressing enter (pkg> update).","category":"page"},{"location":"installation/#Sharing-your-MCMRSimulator-installation","page":"Installation","title":"Sharing your MCMRSimulator installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To share the exact environment used by your installation of MCMRSimulator, simply go to the <project_dir> directory and locate the files named \"Project.toml\" and \"Manifest.toml\". Transfer these files to any other computer, to ensure that they install the exact same version of all Julia packages used (see https://pkgdocs.julialang.org/v1/environments/ for more details).","category":"page"},{"location":"tutorial_julia/#tutorial_julia","page":"Tutorial (Julia)","title":"Tutorial","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"This tutorial will walk through an example of modelling the MRI signal evolution for a diffusion-weighted sequence. The spins in this simulation will be constrained by regularly packed cylinders. This tutorial will use the programatic Julia interface, which you can run in the Julia REPL or in a Jupyter notebook. If you would prefer to use the command line interface, you can find a tutorial doing the same analysis here.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"After installation we can load MCMRSimulator.jl using","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"using MCMRSimulator\nusing CairoMakie  # used for plotting; use GLMakie or WGLMakie for interactive plots\nupdate_theme!(Theme(Axis=(xgridvisible=false, ygridvisible=false))) # hide grid lines","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"In general, running a simulation will consist of the following three steps:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Defining the microstructure and one or more sequences by creating an appropriate Simulation object.\nInitialising Snapshot with one or more Spin objects.\nSimulating a random walk of the spins through the microstructure and the MR signal produced by those spins.\nPlotting the MR signal or storing it to disk.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"We will look through each of these steps below.","category":"page"},{"location":"tutorial_julia/#Defining-the-simulation","page":"Tutorial (Julia)","title":"Defining the simulation","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The first step is to define the environment through which the spins will evolve. We will do so by creating an appropriate Simulation object. This Simulation will contain information on the microstructure, how spins interact with that microstructure, and the enabled sequence(s).","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"These different steps are described in more detail in other sections of this documentation:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"How to define the microstrutural geometry\nControlling spin behaviour","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"For a discussion on sequence generation see MRIBuilder.jl.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"First we will define a geometry formed of regularly packed axons. This is represented by a single cylinder with a radius of 1 micrometer that repeats itself every 2.5 micrometer (in both the x-, and y-direction).","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"import Random; Random.seed!(1) # hide\ngeometry = Cylinders(radius=1., repeats=[2.5, 2.5])\n\nf = plot(PlotPlane(size=5), geometry)\nxlims!(f.axis, -2.5, 2.5)\nylims!(f.axis, -2.5, 2.5)\nf\nsave(\"tutorial_geometry.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"More complicated geometries can be generated as described here. More details on plotting geometries can be found in the plot_geometry documentation.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The next step is to define a sequence using MRIBuilder.jl.  Here we will adopt a single diffusion-weighted MRI sequence.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"using MRIBuilder\nsequence = DWI(bval=2., TE=80, TR=300, scanner=Siemens_Prisma)\nf = plot_sequence(sequence)\nf\nsave(\"tutorial_sequence.png\", f); # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: ) More details on plotting sequences can be found in the plot_sequence documentation.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Once we have both a geometry and one or more sequences, we can put them together in a Simulation object:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"simulation = Simulation(sequence, R2=0.012, R1=3e-3, diffusivity=2., off_resonance=0.1, geometry=geometry)\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"By default there is no T1 or T2 relaxation and a diffusivity of 3 um^2/ms. Enabling spin relaxation and diffusion requires setting the appropriate parameters in the Simulation as seen here. The spin relaxation rates can be different in different compartments as described here.","category":"page"},{"location":"tutorial_julia/#Initialising-the-simulation","page":"Tutorial (Julia)","title":"Initialising the simulation","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The current state of the simulation at any time is given by a Snapshot object. This is essentially a vector of Spin objects with a time stamp. Each Spin represents a single diffusing particle. Besides containing its current position, it also contains its contribution to the MR signal for each of the sequences in the simulation and whether it is stuck on any surfaces.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The recommended way to initialise is to call Snapshot(<number of spins>, <simulation>, [bounding_box]). This will create randomly distributed spins within some BoundingBox. By default this bounding box is an isotropic voxel with a size of 1 mm centered on the origin.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"After initialisation or after running the simulation, the Snapshot can be later filtered to include only spins inside/outside specific compartments or only include free/bound spins using [get_subset].","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The simulation can also be initialised explicitly using a sequence of positions (i.e., length-3 vectors) with the initial spin positions.  Note that such a simulation will start with all spins free and not necessarily randomly distributed, which means it might take some time to reach an equilibrium.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"For each of these initialisations the initial magnetisation can be explicitly set using the transverse, longitudinal, and phase flags. The default is for spins to start in equilibrium (i.e., transverse magnetisation of 0 and longitudinal magnetisation of 1).","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Finally, one could start a simulation using a Snapshot from a previous simulation.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"note: Deterministic spins\nEach Spin is assigned a random number state at creation, which will be used for its future evolution. This means that after creation of a spin or a Snapshot its future is fully determined. This ensures that when a spin is evolved through the same simulation multiple times, it sill follow the same path each time. This allows improved comparisons between simulations with the same geometry, but different sequences/physics. However, it can lead to confusing results (e.g., a simulation initialised with fill(Spin(), 500) will contain 500 spins all following the exact same path).","category":"page"},{"location":"tutorial_julia/#Running-the-simulation","page":"Tutorial (Julia)","title":"Running the simulation","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The main way to run a simulation is by calling readout. This function takes a Snapshot and a Simulation as input (or a number of spins, which will be used to generate a new Snapshot on the fly). There are various ways to define when the output will be read out (as described in the readout documentation).","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Here, we will illustrate various examples of using this function:","category":"page"},{"location":"tutorial_julia/#Simple-signal-readouts","page":"Tutorial (Julia)","title":"Simple signal readouts","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Most sequences will contain one or more MRIBuilder.SingleReadout or MRIBuilder.ADC objects, which define when the sequence will be read out during each repetition time (TR). To get the signal at this time, we can simply call:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"readout(1000, simulation)","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"This signal is not truely representative from what we expect in a true diffusion-weighted MRI sequence, because the longitudinal signal has not had a chance to relax across multiple repetition times. To see what the signal will look like after such equilibriation, we can delay our readout with several TRs:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"readout(1000, simulation, skip_TR=5)","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"In addition, to the total signal, we can also get the signal associated with individual compartments:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"readout(1000, simulation, subset=[Subset(inside=true), Subset(inside=false)])","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Note that we now get two signal outputs. The first respresents the signal within the cylinders, which is very close to number of spins,  indicating that there has been very little dephasing due to the diffusion weighting inside the cylinders. On the other hand, we did lose most of the signal outside of the cylinders. All the spins are either inside or outside the cylinders, so in this case the first row is simply the sum of the next two.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Instead of just running the simulation for multiple TRs without readouts,  we could also visualise the equilibriation process by outputting the signal for multiple TRs:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"signals = readout(1000, simulation, nTR=6)\nf = lines(longitudinal.(signals))\nlines!(transverse.(signals))\nf\nsave(\"tutorial_equil.png\") # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"At each timepoint readout by default will return the total MR signal (for each sequence) as a SpinOrientation object. From this one can estimate the transverse component, the longitudinal component, and the phase. The longitudinal and transverse functions are used above to get those respective components.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"We can also override, when the signal will be read out, by passing on the readout times as a third argument to readout. Here we use this to plot the actual transverse signal evolution.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"times = 0:0.1:100\n# simulate 3000 spins for a single repetition time\naverage_signals = readout(3000, simulation, times, skip_TR=5)\nf = lines(times, transverse.(average_signals)/3000.)\nxlims!(0, 100)\nf\nsave(\"tutorial_transverse.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Note that by plotting the Sequence as well, we make the signal evolution a lot easier to interpret.","category":"page"},{"location":"tutorial_julia/#Reading-out-the-full-snapshot","page":"Tutorial (Julia)","title":"Reading out the full snapshot","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Instead of returning just the total signal readout can also return the full spin state in a Snapshot object by setting the return_snapshot keyword to true. Note that this is very memory intensive, so is only recommended when you only output a small number of timepoints or a small number of spins.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Here, we use this to visualise the trajectory of spins through the geometry. To plot the trajectory we first need to output the state of the all spins at a high temporal resolution:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"# Simulate 2 spins with given starting positions for 3 ms\nsnapshots = readout([[0, 0, 0], [1, 1, 0]], simulation, 0:0.01:3., return_snapshot=true)\n\npp = PlotPlane(size=5.)\nf = plot(pp, geometry)\nplot(pp, snapshots)\nf\nsave(\"tutorial_trajectory2D.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: ) In this plot the color at each timepoint encodes the spin orientation. The brightness of the spin indicates the size of the transverse component with purely longitudinal spins being in black. The color of the spin encodes the phase of the MR signal in the transverse plane.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The trajectories can also be plotted in 3D:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"f = plot(snapshots)\nsave(\"tutorial_trajectory3D.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: ) More details on plotting trajectories can be found in the plot_trajectory documentation.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"We can also use this future to plot the complete Snapshot at a specific time.  In this example we do not set this time explicitly, so it will default to the time of the sequence MRIBuilder.SingleReadout/MRIBuilder.ADC as discussed above:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"snapshot = readout(3000, simulation, return_snapshot=true)\npp = PlotPlane(size=2.5)\nf = plot(pp, snapshot)\nplot!(pp, geometry)\nf\nsave(\"tutorial_snapshot.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: ) We can see that the spins within the cylinder stay far more in-sync with each other (i.e., they have a more uniform colour), than those outside of the cylinder.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Note that object returned when return_snapshot=true is the same Snapshot object as was used to initialise this simulation. This means that it can be used as an initialisation for future simulations.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"One complication with this occurs when running a Simulation with multiple sequences. Often, these different sequences will readout at different times. So, each Snapshot object returned by readout will only contain the spin magnetisation of the sequence that is readout at that particular time. To get a Snapshot object with the spin states for all sequences, you can use the evolve function instead.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"More details on plotting snapshots can be found in the plot_snapshot documentation. For example, the same snapshot can also be plotted using dyads or as an image:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"f = plot(pp, snapshot, kind=:dyad)\nplot!(pp, geometry)\nf\nsave(\"tutorial_snapshot_dyad.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"f = plot(pp, snapshot, kind=:image)\nplot!(pp, geometry)\nf\nsave(\"tutorial_snapshot_image.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MCMRSimulator.jl allows simulation of MR signal generation using Monte Carlo simulations. The spin evolution of randomly diffusing particles is tracked under influence of one or more MR sequences. At present, the simulator allows to model","category":"page"},{"location":"","page":"Home","title":"Home","text":"Free diffusion and diffusion restricted by Walls, Cylinders, Spheres, and/or a triangular Mesh.\nR1 and R2 relaxation using global or local R1/R2 parameters.\nMR sequences consisting of arbitrary RF pulses, gradients, and readouts (built using MRIBuilder or read from pulseq files).\nOff-resonance magnetic field generation by myelinated cylinders or meshes.\nMagnetisation transfer between liquid spins and bound spins in membranes.\nMembrane permeability (i.e., exchange)\nSurface relaxation\nSurface tension of membranes causing spins to get temporarily \"stuck\" when they hit a membrane","category":"page"},{"location":"","page":"Home","title":"Home","text":"Future (potential) features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Macromolecular pool not bound to the membrane\nOff-resonance field by iron particles\nContribution from metabolites (i.e., spectroscopy)","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: beta\nThis MR simulator is still under very active development and the API might still change substantially at any time!","category":"page"},{"location":"","page":"Home","title":"Home","text":"We use the following units throughout (unless otherwise noted):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Times are in ms. Equivalently, RF pulse amplitudes and off-resonance magnetic fields are in kHz (i.e., 1/ms).\nPositions are in um. So, gradients are in kHz/um (not mT/m).\nAngles are in degrees (not radians). These are used for phases (of spins and RF pulses) as well as RF pulse flip angles. \nMagnetic susceptibilities are in parts per million (ppm).","category":"page"},{"location":"#How-to-get-started?","page":"Home","title":"How to get started?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If MCMRSimulator is not yet installed, follow the installation instructions.\nLook through one of the tutorials. There are two available, depending on which interface you prefer to use:\nFor the command line interface: CLI tutorial.\nFor the julia interface: Julia tutorial.\nIf you want more information on a specific topic, you can check one of the more dedicated sections:\nGeometry.\nMRI & collision properties.\nFor sequences see MRIBuilder.jl.\nFull API.","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The original simulator was written by Michiel Cottaar.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other contributors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Zhiyu Zheng","category":"page"},{"location":"#Movie-of-spins-moving-through-cylinders","page":"Home","title":"Movie of spins moving through cylinders","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<iframe src=\"https://ox.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=b6211751-2743-4bb8-b65a-af5d011a8684&autoplay=true&offerviewer=false&showtitle=false&showbrand=false&captions=false&interactivity=none\" style=\"border: 1px solid #464646;\" allowfullscreen allow=\"autoplay\"></iframe>","category":"page"}]
}
