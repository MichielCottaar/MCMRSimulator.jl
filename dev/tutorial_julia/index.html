<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial (Julia) · MCMRSimulator.jl</title><meta name="title" content="Tutorial (Julia) · MCMRSimulator.jl"/><meta property="og:title" content="Tutorial (Julia) · MCMRSimulator.jl"/><meta property="twitter:title" content="Tutorial (Julia) · MCMRSimulator.jl"/><meta name="description" content="Documentation for MCMRSimulator.jl: a Monte Carlo MRI simulator in Julia"/><meta property="og:description" content="Documentation for MCMRSimulator.jl: a Monte Carlo MRI simulator in Julia"/><meta property="twitter:description" content="Documentation for MCMRSimulator.jl: a Monte Carlo MRI simulator in Julia"/><meta property="og:url" content="https://open.win.ox.ac.uk/pages/ndcn0236/mcmrsimulator.jl/stable/tutorial_julia/"/><meta property="twitter:url" content="https://open.win.ox.ac.uk/pages/ndcn0236/mcmrsimulator.jl/stable/tutorial_julia/"/><link rel="canonical" href="https://open.win.ox.ac.uk/pages/ndcn0236/mcmrsimulator.jl/stable/tutorial_julia/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MCMRSimulator.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li class="is-active"><a class="tocitem" href>Tutorial (Julia)</a><ul class="internal"><li><a class="tocitem" href="#Defining-the-simulation"><span>Defining the simulation</span></a></li><li><a class="tocitem" href="#Initialising-the-simulation"><span>Initialising the simulation</span></a></li><li><a class="tocitem" href="#Running-the-simulation"><span>Running the simulation</span></a></li><li><a class="tocitem" href="#Simple-signal-readouts"><span>Simple signal readouts</span></a></li><li><a class="tocitem" href="#Reading-out-the-full-snapshot"><span>Reading out the full snapshot</span></a></li></ul></li><li><a class="tocitem" href="../tutorial_cli/">Tutorial (CLI)</a></li><li><a class="tocitem" href="../geometry/">Geometry</a></li><li><a class="tocitem" href="../sequence/">Sequence</a></li><li><a class="tocitem" href="../properties/">MRI/collision properties</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial (Julia)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial (Julia)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl" title="View the repository"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-navbar-link" href="https://git.fmrib.ox.ac.uk/ndcn0236/MCMRSimulator.jl/-/tree/main/docs/src/tutorial_julia.md" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial_julia"><a class="docs-heading-anchor" href="#tutorial_julia">Tutorial</a><a id="tutorial_julia-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial_julia" title="Permalink"></a></h1><p>This tutorial will walk through an example of modelling the MRI signal evolution for a diffusion-weighted sequence. The spins in this simulation will be constrained by regularly packed cylinders. This tutorial will use the programatic Julia interface, which you can run in the Julia REPL or in a Jupyter notebook. If you would prefer to use the command line interface, you can find a tutorial doing the same analysis <a href="../tutorial_cli/#tutorial_cli">here</a>.</p><p>After <a href="../installation/#installation">installation</a> we can load MCMRSimulator.jl using</p><pre><code class="language-julia hljs">using MCMRSimulator
using CairoMakie  # used for plotting; use GLMakie or WGLMakie for interactive plots
update_theme!(Theme(Axis=(xgridvisible=false, ygridvisible=false))) # hide grid lines</code></pre><p>In general, running a simulation will consist of the following three steps:</p><ul><li>Defining the microstructure and one or more sequences by creating an appropriate <a href="../api/#MCMRSimulator.Simulations.Simulation"><code>Simulation</code></a> object.</li><li>Initialising <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a> with one or more <a href="../api/#MCMRSimulator.Spins.Spin"><code>Spin</code></a> objects.</li><li>Simulating a random walk of the spins through the microstructure and the MR signal produced by those spins.</li><li>Plotting the MR signal or storing it to disk.</li></ul><p>We will look through each of these steps below.</p><h2 id="Defining-the-simulation"><a class="docs-heading-anchor" href="#Defining-the-simulation">Defining the simulation</a><a id="Defining-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-simulation" title="Permalink"></a></h2><p>The first step is to define the environment through which the spins will evolve. We will do so by creating an appropriate <a href="../api/#MCMRSimulator.Simulations.Simulation"><code>Simulation</code></a> object. This <code>Simulation</code> will contain information on the microstructure, how spins interact with that microstructure, and the enabled sequence(s).</p><p>These different steps are described in more detail in other sections of this documentation:</p><ul><li><a href="../geometry/#geometry">How to define the microstrutural geometry</a></li><li><a href="../properties/#properties">Controlling spin behaviour</a></li><li><a href="../sequence/#sequence">Sequence generation</a></li></ul><p>First we will define a geometry formed of regularly packed axons. This is represented by a single cylinder with a radius of 1 micrometer that repeats itself every 2.5 micrometer (in both the x-, and y-direction).</p><pre><code class="language-julia hljs">geometry = Cylinders(radius=1., repeats=[2.5, 2.5])

f = plot(PlotPlane(size=5), geometry)
xlims!(f.axis, -2.5, 2.5)
ylims!(f.axis, -2.5, 2.5)
f</code></pre><p><img src="../tutorial_geometry.png" alt/></p><p>More complicated geometries can be generated as described <a href="../geometry/#geometry">here</a>. More details on plotting geometries can be found in the <a href="../api/#MCMRSimulator.Plot.plot_geometry-Tuple"><code>plot_geometry</code></a> documentation.</p><p>The next step is to define a sequence (see <a href="../sequence/#sequence">here</a> for more details).  Here we will adopt a single diffusion-weighted MRI sequence.</p><pre><code class="language-julia hljs">sequence = dwi(bval=2., TR=1000, TE=80, scanner=Siemens_Prisma)  # default gradient orientation in the x-direction
f = plot(sequence)
hideydecorations!(f.axis)
hidespines!(f.axis, :l, :r, :t)
xlims!(f.axis, -10, 110)
f</code></pre><p><img src="../tutorial_sequence.png" alt/> More details on plotting sequences can be found in the <a href="../api/#MCMRSimulator.Plot.plot_sequence-Tuple"><code>plot_sequence</code></a> documentation.</p><p>Once we have both a geometry and one or more sequences, we can put them together in a <a href="../api/#MCMRSimulator.Simulations.Simulation"><code>Simulation</code></a> object:</p><pre><code class="language-julia hljs">simulation = Simulation(sequence, R2=0.012, R1=3e-3, diffusivity=2., off_resonance=0.1, geometry=geometry)</code></pre><p>By default there is no T1 or T2 relaxation and a diffusivity of 3 um^2/ms. Enabling spin relaxation and diffusion requires setting the appropriate parameters in the <a href="../api/#MCMRSimulator.Simulations.Simulation"><code>Simulation</code></a> as seen here. The spin relaxation rates can be different in different compartments as described <a href="../properties/#properties">here</a>.</p><h2 id="Initialising-the-simulation"><a class="docs-heading-anchor" href="#Initialising-the-simulation">Initialising the simulation</a><a id="Initialising-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Initialising-the-simulation" title="Permalink"></a></h2><p>The current state of the simulation at any time is given by a <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a> object. This is essentially a vector of <a href="../api/#MCMRSimulator.Spins.Spin"><code>Spin</code></a> objects with a time stamp. Each <a href="../api/#MCMRSimulator.Spins.Spin"><code>Spin</code></a> represents a single diffusing particle. Besides containing its current position, it also contains its contribution to the MR signal for each of the sequences in the simulation and whether it is stuck on any surfaces.</p><p>The recommended way to initialise is to call <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a><code>(&lt;number of spins&gt;, &lt;simulation&gt;, [bounding_box])</code>. This will create randomly distributed spins within some <a href="../api/#MCMRSimulator.Geometries.Internal.BoundingBoxes.BoundingBox"><code>BoundingBox</code></a>. By default this bounding box is an isotropic voxel with a size of 1 mm centered on the origin.</p><p>After initialisation or after running the simulation, the <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a> can be later filtered to include only spins inside/outside specific compartments or only include free/bound spins using [<code>get_subset</code>].</p><p>The simulation can also be initialised explicitly using a sequence of positions (i.e., length-3 vectors) with the initial spin positions.  Note that such a simulation will start with all spins free and not necessarily randomly distributed, which means it might take some time to reach an equilibrium.</p><p>For each of these initialisations the initial magnetisation can be explicitly set using the <a href="../api/#MCMRSimulator.Spins.transverse"><code>transverse</code></a>, <a href="../api/#MCMRSimulator.Spins.longitudinal"><code>longitudinal</code></a>, and <a href="../api/#MCMRSimulator.Methods.phase"><code>phase</code></a> flags. The default is for spins to start in equilibrium (i.e., transverse magnetisation of 0 and longitudinal magnetisation of 1).</p><p>Finally, one could start a simulation using a <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a> from a previous simulation.</p><div class="admonition is-info"><header class="admonition-header">Deterministic spins</header><div class="admonition-body"><p>Each <a href="../api/#MCMRSimulator.Spins.Spin"><code>Spin</code></a> is assigned a random number state at creation, which will be used for its future evolution. This means that after creation of a spin or a <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a> its future is fully determined. This ensures that when a spin is evolved through the same simulation multiple times, it sill follow the same path each time. This allows improved comparisons between simulations with the same geometry, but different sequences/physics. However, it can lead to confusing results (e.g., a simulation initialised with <code>fill(Spin(), 500)</code> will contain 500 spins all following the exact same path).</p></div></div><h2 id="Running-the-simulation"><a class="docs-heading-anchor" href="#Running-the-simulation">Running the simulation</a><a id="Running-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-simulation" title="Permalink"></a></h2><p>The main way to run a simulation is by calling <a href="../api/#MCMRSimulator.Evolve.readout-Union{Tuple{N}, Tuple{Any, Simulation{N, NG} where NG}, Tuple{Any, Simulation{N, NG} where NG, Any}} where N"><code>readout</code></a>. This function takes a <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a> and a <a href="../api/#MCMRSimulator.Simulations.Simulation"><code>Simulation</code></a> as input (or a number of spins, which will be used to generate a new <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a> on the fly). There are various ways to define when the output will be read out (as described in the <a href="../api/#MCMRSimulator.Evolve.readout-Union{Tuple{N}, Tuple{Any, Simulation{N, NG} where NG}, Tuple{Any, Simulation{N, NG} where NG, Any}} where N"><code>readout</code></a> documentation).</p><p>Here, we will illustrate various examples of using this function:</p><h2 id="Simple-signal-readouts"><a class="docs-heading-anchor" href="#Simple-signal-readouts">Simple signal readouts</a><a id="Simple-signal-readouts-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-signal-readouts" title="Permalink"></a></h2><p>Most sequences will contain one or more <a href="../api/#MCMRSimulator.Sequences.Instants.Readout"><code>Readout</code></a> objects, which define when the sequence will be read out during each repetition time (TR). To get the signal at this time, we can simply call:</p><pre><code class="language-julia hljs">readout(1000, simulation)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SpinOrientationSum(longitudinal=12.786987632238388, transverse=218.38849616609053, phase=1.4837522835743144°, nspins=1000)</code></pre><p>This signal is not truely representative from what we expect in a true diffusion-weighted MRI sequence, because the longitudinal signal has not had a chance to relax across multiple repetition times. To see what the signal will look like after such equilibriation, we can delay our readout with several TRs:</p><pre><code class="language-julia hljs">readout(1000, simulation, skip_TR=5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SpinOrientationSum(longitudinal=12.786732673812214, transverse=208.74526063222356, phase=-2.0623074789086218°, nspins=1000)</code></pre><p>In addition, to the total signal, we can also get the signal associated with individual compartments:</p><pre><code class="language-julia hljs">readout(1000, simulation, subset=[Subset(inside=true), Subset(inside=false)])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{MCMRSimulator.Spins.SpinOrientationSum}:
 SpinOrientationSum(longitudinal=6.099393100577688, transverse=182.59683783171212, phase=-0.03517828534666023°, nspins=477)
 SpinOrientationSum(longitudinal=6.687594531660684, transverse=34.13726207256824, phase=-1.5167325114214236°, nspins=523)</code></pre><p>Note that we now get two signal outputs. The first respresents teh signal within the cylinders, which is very close to number of spins,  indicating that there has been very little dephasing due to the diffusion weighting inside the cylinders. On the other hand, we did lose most of the signal outside of the cylinders. All the spins are either inside or outside the cylinders, so in this case the first row is simply the sum of the next two.</p><p>Instead of just running the simulation for multiple TRs without readouts,  we could also visualise the equilibriation process by outputting the signal for multiple TRs:</p><pre><code class="language-julia hljs">signals = readout(1000, simulation, nTR=6)
f = lines(longitudinal.(signals))
lines!(transverse.(signals))
f</code></pre><p>At each timepoint <a href="../api/#MCMRSimulator.Evolve.readout-Union{Tuple{N}, Tuple{Any, Simulation{N, NG} where NG}, Tuple{Any, Simulation{N, NG} where NG, Any}} where N"><code>readout</code></a> by default will return the total MR signal (for each sequence) as a <a href="../api/#MCMRSimulator.Spins.SpinOrientation"><code>SpinOrientation</code></a> object. From this one can estimate the <a href="../api/#MCMRSimulator.Spins.transverse"><code>transverse</code></a> component, the <a href="../api/#MCMRSimulator.Spins.longitudinal"><code>longitudinal</code></a> component, and the <a href="../api/#MCMRSimulator.Methods.phase"><code>phase</code></a>. The <a href="../api/#MCMRSimulator.Spins.longitudinal"><code>longitudinal</code></a> and <a href="../api/#MCMRSimulator.Spins.transverse"><code>transverse</code></a> functions are used above to get those respective components.</p><p>We can also override, when the signal will be read out, by passing on the readout times as a third argument to <a href="../api/#MCMRSimulator.Evolve.readout-Union{Tuple{N}, Tuple{Any, Simulation{N, NG} where NG}, Tuple{Any, Simulation{N, NG} where NG, Any}} where N"><code>readout</code></a>. Here we use this to plot the actual transverse signal evolution.</p><pre><code class="language-julia hljs">times = 0:0.1:100
# simulate 3000 spins for a single repetition time
average_signals = readout(3000, simulation, times, skip_TR=5)
f = lines(times, transverse.(average_signals)/3000.)
xlims!(0, 100)
f</code></pre><p><img src="../tutorial_transverse.png" alt/></p><p>Note that by plotting the <a href="../api/#MCMRSimulator.Sequences.Main.Sequence"><code>Sequence</code></a> as well, we make the signal evolution a lot easier to interpret.</p><h2 id="Reading-out-the-full-snapshot"><a class="docs-heading-anchor" href="#Reading-out-the-full-snapshot">Reading out the full snapshot</a><a id="Reading-out-the-full-snapshot-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-out-the-full-snapshot" title="Permalink"></a></h2><p>Instead of returning just the total signal <a href="../api/#MCMRSimulator.Evolve.readout-Union{Tuple{N}, Tuple{Any, Simulation{N, NG} where NG}, Tuple{Any, Simulation{N, NG} where NG, Any}} where N"><code>readout</code></a> can also return the full spin state in a <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a> object by setting the <code>return_snapshot</code> keyword to <code>true</code>. Note that this is very memory intensive, so is only recommended when you only output a small number of timepoints or a small number of spins.</p><p>Here, we use this to visualise the trajectory of spins through the geometry. To plot the trajectory we first need to output the state of the all spins at a high temporal resolution:</p><pre><code class="language-julia hljs"># Simulate 2 spins with given starting positions for 3 ms
snapshots = readout([[0, 0, 0], [1, 1, 0]], simulation, 0:0.01:3., return_snapshot=true)

pp = PlotPlane(size=5.)
f = plot(pp, geometry)
plot(pp, snapshots)
f</code></pre><p><img src="../tutorial_trajectory2D.png" alt/> In this plot the color at each timepoint encodes the spin orientation. The brightness of the spin indicates the size of the transverse component with purely longitudinal spins being in black. The color of the spin encodes the phase of the MR signal in the transverse plane.</p><p>The trajectories can also be plotted in 3D:</p><pre><code class="language-julia hljs">f = plot(snapshots)</code></pre><p><img src="../tutorial_trajectory3D.png" alt/> More details on plotting snapshots can be found in the <a href="../api/#MCMRSimulator.Plot.plot_snapshot-Tuple"><code>plot_snapshot</code></a> documentation.</p><p>We can also use this future to plot the complete <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a> at a specific time.  In this example we do not set this time explicitly, so it will default to the time of the sequence <a href="../api/#MCMRSimulator.Sequences.Instants.Readout"><code>Readout</code></a> as discussed above:</p><pre><code class="language-julia hljs">snapshot = readout(3000, simulation, return_snapshot=true)
pp = PlotPlane(size=2.5)
f = plot(pp, snapshot)
plot!(pp, geometry)
f</code></pre><p><img src="../tutorial_snapshot.png" alt/> The color encoding is the same as for the trajectory plot above. The brightness encodes the size of the transverse component, while the color encodes the phase of the MR signal in the transverse plane. We can see that outside of the cylinder the signal contribution is significantly reduced. The black arrows show the transverse spin for some random subset of spins.</p><p>Note that object returned when <code>return_snapshot=true</code> is the same <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a> object as was used to initialise this simulation. This means that it can be used as an initialisation for future simulations.</p><p>One complication with this occurs when running a <a href="../api/#MCMRSimulator.Simulations.Simulation"><code>Simulation</code></a> with multiple sequences. Often, these different sequences will readout at different times (because of different <a href="../api/#MCMRSimulator.Sequences.Instants.Readout"><code>Readout</code></a> objects and/or different TRs). So, each <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a> object returned by <a href="../api/#MCMRSimulator.Evolve.readout-Union{Tuple{N}, Tuple{Any, Simulation{N, NG} where NG}, Tuple{Any, Simulation{N, NG} where NG, Any}} where N"><code>readout</code></a> will only contain the spin magnetisation of the sequence that is readout at that particular time. To get a <a href="../api/#MCMRSimulator.Spins.Snapshot"><code>Snapshot</code></a> object with the spin states for all sequences, you can use the <a href="../api/#MCMRSimulator.Evolve.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N, NG} where NG}, Tuple{Any, Simulation{N, NG} where NG, Any}} where N"><code>evolve</code></a> function instead.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../installation/">« Installation</a><a class="docs-footer-nextpage" href="../tutorial_cli/">Tutorial (CLI) »</a><div class="flexbox-break"></div></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 10 January 2024 18:58">Wednesday 10 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
