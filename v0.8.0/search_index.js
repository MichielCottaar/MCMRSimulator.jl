var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<div class=\"citation canonical\"><ul><li>\n<div id=\"fan22_MappingHumanConnectome\">Fan, Q.; Eichner, C.; Afzali, M.; Mueller, L.; Tax, C. M.; Davids, M.; Mahmutovic, M.; Keil, B.; Bilgic, B.; Setsompop, K.; Lee, H.-H.; Tian, Q.; Maffei, C.; {Ramos-Llord{\\'e}n}, G.; Nummenmaa, A.; Witzel, T.; Yendiki, A.; Song, Y.-Q.; Huang, C.-C.; Lin, C.-P.; Weiskopf, N.; Anwander, A.; Jones, D. K.; Rosen, B. R.; Wald, L. L. and Huang, S. Y. (2022). <a href='https://www.sciencedirect.com/science/article/pii/S1053811922000878'><i>Mapping the {{Human Connectome}} Using {{Diffusion MRI}} at 300 {mT}/m {{Gradient Strength}}: {{Methodological Advances}} and {{Scientific Impact}}</i></a>. <a href='https://doi.org/10.1016/j.neuroimage.2022.118958'>NeuroImage, 118958</a>.</div>\n</li><li>\n<div id=\"rubeckAnalyticalCalculationMagnet2013\">Rubeck, C.; Yonnet, J.-P.; Allag, H.; Delinchant, B. and Chadebec, O. (2013). <a href='https://hal.science/hal-00982164'><i>Analytical {Calculation} of {{Magnet Systems}}: {{Magnetic Field Created}} by {{Charged Triangles}} and {Polyhedra}</i></a>. <a href='https://doi.org/10.1109/TMAG.2012.2219511'>IEEE Transactions on Magnetics <b>49</b>, 144–147</a>.</div>\n</li><li>\n<div id=\"Wharton_2012\">Wharton, S. and Bowtell, R. (2012). <i>Fiber Orientation-Dependent White Matter Contrast in Gradient Echo MRI.</i> <a href='https://doi.org/10.1073/pnas.1211075109'>Proceedings of the National Academy of Sciences of the United States of America <b>109</b>, 18559–64</a>.</div>\n</li>\n</ul></div>","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = MCMRSimulator","category":"page"},{"location":"api/#api","page":"API","title":"MCMRSimulator.jl API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This is the API for MCMRSimulator. For a more user-friendly introduction, click here.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [\n    MCMRSimulator,\n    MCMRSimulator.Constants,\n    MCMRSimulator.Methods,\n    MCMRSimulator.Scanners,\n    MCMRSimulator.Properties,\n    MCMRSimulator.Geometries,\n    MCMRSimulator.Geometries.User,\n    MCMRSimulator.Geometries.User.Obstructions,\n    MCMRSimulator.Geometries.User.Obstructions.Fields,\n    MCMRSimulator.Geometries.User.Obstructions.ObstructionTypes,\n    MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups,\n    MCMRSimulator.Geometries.User.Fix,\n    MCMRSimulator.Geometries.User.FixSusceptibility,\n    MCMRSimulator.Geometries.User.LoadMesh,\n    MCMRSimulator.Geometries.User.RandomDistribution,\n    MCMRSimulator.Geometries.User.SplitMesh,\n    MCMRSimulator.Geometries.User.JSON,\n    MCMRSimulator.Geometries.Internal,\n    MCMRSimulator.Geometries.Internal.RayGridIntersection,\n    MCMRSimulator.Geometries.Internal.BoundingBoxes,\n    MCMRSimulator.Geometries.Internal.Obstructions,\n    MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections,\n    MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions,\n    MCMRSimulator.Geometries.Internal.Obstructions.Walls,\n    MCMRSimulator.Geometries.Internal.Obstructions.Rounds,\n    MCMRSimulator.Geometries.Internal.Obstructions.Triangles,\n    MCMRSimulator.Geometries.Internal.Obstructions.Shifts,\n    MCMRSimulator.Geometries.Internal.Gridify,\n    MCMRSimulator.Geometries.Internal.Intersections,\n    MCMRSimulator.Geometries.Internal.Reflections,\n    MCMRSimulator.Geometries.Internal.FixedObstructionGroups,\n    MCMRSimulator.Geometries.Internal.Properties,\n    MCMRSimulator.Geometries.Internal.Susceptibility,\n    MCMRSimulator.Geometries.Internal.Susceptibility.Base,\n    MCMRSimulator.Geometries.Internal.Susceptibility.Parent,\n    MCMRSimulator.Geometries.Internal.Susceptibility.Cylinder,\n    MCMRSimulator.Geometries.Internal.Susceptibility.Annulus,\n    MCMRSimulator.Geometries.Internal.Susceptibility.Triangle,\n    MCMRSimulator.Geometries.Internal.IsInsideMesh,\n    MCMRSimulator.Spins,\n    MCMRSimulator.Sequences,\n    MCMRSimulator.Sequences.Methods,\n    MCMRSimulator.Sequences.Instants,\n    MCMRSimulator.Sequences.Shapes,\n    MCMRSimulator.Sequences.Gradients,\n    MCMRSimulator.Sequences.RadioFrequency,\n    MCMRSimulator.Sequences.Main,\n    MCMRSimulator.Sequences.PulseQ,\n    MCMRSimulator.Sequences.JSON,\n    MCMRSimulator.SequenceBuilder,\n    MCMRSimulator.SequenceBuilder.BuildingBlocks,\n    MCMRSimulator.SequenceBuilder.DefineSequence,\n    MCMRSimulator.SequenceBuilder.Diffusion,\n    MCMRSimulator.SequenceBuilder.Sequences,\n    MCMRSimulator.SequenceBuilder.Sequences.GradientEcho,\n    MCMRSimulator.SequenceBuilder.Sequences.SpinEcho,\n    MCMRSimulator.Timestep,\n    MCMRSimulator.Relax,\n    MCMRSimulator.Simulations,\n    MCMRSimulator.Subsets,\n    MCMRSimulator.Evolve,\n    MCMRSimulator.Plot,\n    MCMRSimulator.Plot.Utils,\n    MCMRSimulator.Plot.PlotPlanes,\n    MCMRSimulator.Plot.Sequences,\n    MCMRSimulator.Plot.Geometries,\n    MCMRSimulator.Plot.OffResonance,\n    MCMRSimulator.Plot.Snapshots,\n    MCMRSimulator.Plot.Trajectory,\n    MCMRSimulator.Plot.Movie,\n    MCMRSimulator.CLI,\n    MCMRSimulator.CLI.Geometry,\n    MCMRSimulator.CLI.Sequence,\n    MCMRSimulator.CLI.Run,\n]","category":"page"},{"location":"api/#MCMRSimulator.MCMRSimulator","page":"API","title":"MCMRSimulator.MCMRSimulator","text":"This package supports the running of MR Monte Carlo simulations.\n\nIn these simulations hundreds of thousands or millions of Spin particles randomly diffuse through some tissue microstructure. At each timepoint these spins are represented as a Snapshot object. The spin diffusion is constrained by an ObstructionGroup (represented internally as FixedGeometry) The spins of these particles will be evolved based on the Bloch equations with the field strength and relaxation rates set by the local geometry and the effect of one or more Sequence objects. All these variables are combined into a single Simulation object.  See Simulation for how to run the simulation.\n\nPlotting support for the sequence and resulting signal is also available based on Makie.jl.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Constants.gyromagnetic_ratio","page":"API","title":"MCMRSimulator.Constants.gyromagnetic_ratio","text":"gyromagnetic ratio of a proton (1H) in water in kHz/T\n\n\n\n\n\n","category":"constant"},{"location":"api/#MCMRSimulator.Methods","page":"API","title":"MCMRSimulator.Methods","text":"Defines methods shared across multiple sub-modules.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Methods.B0","page":"API","title":"MCMRSimulator.Methods.B0","text":"B0(scanner)\nB0(sequence)\n\nReturns the magnetic field strength of the scanner in Tesla.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Methods.get_rotation-Tuple{Rotations.Rotation, Int64}","page":"API","title":"MCMRSimulator.Methods.get_rotation","text":"get_rotation(rotation_mat, ndim)\n\nReturns a (3, ndim) rotation matrix, that is the relevant part of the full 3x3 rotation_mat to map to the x-axis (if ndim is 1) or the x-y plance (if ndim is 2). If ndim is 3, the full rotation matrix rotation_mat is returned.\n\nget_rotation(vector, ndim; reference_dimension)\n\nReturns the (3, ndim) rotation matrix mapping the vector to the reference_dimension. By default, the reference_dimension is the x-direction (ifndimis 1 or 3) or the z-direction (ifndimis 2).vectorandreference_dimension` can be a length 3 array or one of the symbols :x, :y, or :z (representing vectors in those cardinal directions).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Methods.get_time","page":"API","title":"MCMRSimulator.Methods.get_time","text":"get_time(snapshot)\nget_time(sequence_component)\nget_time(sequence, sequence_index)\n\nReturns the time in milliseconds that a snapshot was taken or that a sequence component will have effect.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Methods.norm_angle-Tuple{Any}","page":"API","title":"MCMRSimulator.Methods.norm_angle","text":"norm_angle(angle)\n\nNormalises an angle in degrees, so that it is between it is in the range (-180, 180]\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Scanners","page":"API","title":"MCMRSimulator.Scanners","text":"Define general Scanner type and methods as well as some concrete scanners.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Scanners.Siemens_Connectom","page":"API","title":"MCMRSimulator.Scanners.Siemens_Connectom","text":"Siemens 3T Connectom MRI scanner ((Fan *et al.*, 2022)).\n\n\n\n\n\n","category":"constant"},{"location":"api/#MCMRSimulator.Scanners.Siemens_Prisma","page":"API","title":"MCMRSimulator.Scanners.Siemens_Prisma","text":"Siemens MAGNETOM 3T Prisma MRI scanner (https://www.siemens-healthineers.com/en-uk/magnetic-resonance-imaging/3t-mri-scanner/magnetom-prisma).\n\n\n\n\n\n","category":"constant"},{"location":"api/#MCMRSimulator.Scanners.Siemens_Terra","page":"API","title":"MCMRSimulator.Scanners.Siemens_Terra","text":"Siemens MAGNETOM 7T Terra MRI scanner (https://www.siemens-healthineers.com/en-uk/magnetic-resonance-imaging/7t-mri-scanner/magnetom-terra)\n\n\n\n\n\n","category":"constant"},{"location":"api/#MCMRSimulator.Scanners.Scanner","page":"API","title":"MCMRSimulator.Scanners.Scanner","text":"Scanner(;B0=3., gradient=Inf, slew_rate=Inf, units=:kHz)\n\nProperties of an MRI scanner relevant for the MR signal simulations.\n\nB0: magnetic field strength (in Tesla)\nmax_gradient: maximum gradient strength long each axis.\nmax_slew_rate: maximum rate of change in the gradient strength\n\nBy default gradient and slew_rate are expected to be provided in units of, respectively, kHz/um and kHz/um/ms. However, if the keyword units=:Tesla is set, the gradient and slew_rate should be provided in units of, respectively, mT/m and T/m/s.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Methods.B0-Tuple{Scanner}","page":"API","title":"MCMRSimulator.Methods.B0","text":"B0(scanner)\nB0(sequence)\n\nReturns the magnetic field strength of the scanner in Tesla.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Scanners.max_gradient","page":"API","title":"MCMRSimulator.Scanners.max_gradient","text":"max_gradient(scanner[, units])\n\nReturns the maximum magnetic field gradient of the scanner in kHz/um. By setting units to :Tesla, the gradient strength can be returned in mT/m instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Scanners.max_slew_rate","page":"API","title":"MCMRSimulator.Scanners.max_slew_rate","text":"max_slew_rate(scanner[, units])\n\nReturns the maximum magnetic field slew rate of the scanner in kHz/um/ms. By setting units to :Tesla, the slew rate can be returned in T/m/s instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Properties","page":"API","title":"MCMRSimulator.Properties","text":"Types:\n\nGlobalProperties\n\nMethods:\n\nR1\nR2\noff_resonance\ncorrect_for_timestep\nstick_probability\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Properties.GlobalProperties","page":"API","title":"MCMRSimulator.Properties.GlobalProperties","text":"GlobalProperties(; R1=0, R2=0, off_resonance=0, permeability=0, dwell_time=0, surface_density=0, surface_relaxivity=0)\n\nStores global MRI and collision properties.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Properties.correct_for_timestep-Tuple{Any, Any}","page":"API","title":"MCMRSimulator.Properties.correct_for_timestep","text":"correct_for_timestep(surface_relaxivity/permeability, timestep)\n\nCorrects the surface relaxivity or permeability for the variability in the timestep during the simulation.\n\nIn Monte Carlo simulations the rate of collisions depends on the size of the timestep. This means that as the timestep changes, the effect of surface relaxivity and permeability will depend on the timestep. This function corrects the surface relaxivity and permeability values, so that their effect does not depend on timestep. The user-provided surface relaxivity and permeability will be used unaltered if the timestep is 1 milliseconds.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Properties.stick_probability-NTuple{4, Number}","page":"API","title":"MCMRSimulator.Properties.stick_probability","text":"stick_probability(surface_density, dwell_time, diffusivity, timestep)\nstick_probability(properties, diffusivity, timestep)\n\nComputes the probability of a spin getting stuck at the surface given a surface_density and dwell_time as well as the diffusivity (in um^2/ms) and the timestep (in ms).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries","page":"API","title":"MCMRSimulator.Geometries","text":"Defines the microstructural environment with which the spins interact.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User","page":"API","title":"MCMRSimulator.Geometries.User","text":"User interface for defining geometry.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Annuli","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Annuli","text":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup{:Annuli})(; fields...)\n\nCreates a set of Annulus objects. Fields can be set using keyword arguments. The following fields are available:\n\ninner: Radius of the inner cylinder. Field is required. Expected type: Float64.\nouter: Radius of the outer cylinder. Field is required. Expected type: Float64.\nmyelin: Whether the annulus is myelinated. Field is required. Expected type: Bool.  default value: false\nrotation: Rotation applied to all obstructions in group. Can be set to a matrix or one of :x, :y, or, :z (see get_rotation). Field is required. Expected type: StaticArraysCore.SMatrix{3, 2, Float64, 6}.  default value: [1.0 0.0; 0.0 1.0; 0.0 0.0]\ngrid_resolution: Resolution of the grid that the volume is split up into (um). Field is required. Expected type: Float64.  default value: 1.0\nR1_inner_surface: Additional longitudinal relaxation rate (kHz). Inner_surface property. Field is required. Expected type: Float64.  default value: 0.0\nR1_outer_surface: Additional longitudinal relaxation rate (kHz). Outer_surface property. Field is required. Expected type: Float64.  default value: 0.0\nR1_inner_volume: Additional longitudinal relaxation rate (kHz). Inner_volume property. Field is required. Expected type: Float64.  default value: 0.0\nR1_outer_volume: Additional longitudinal relaxation rate (kHz). Outer_volume property. Field is required. Expected type: Float64.  default value: 0.0\nR2_inner_surface: Additional transverse relaxation rate (kHz). Inner_surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2_outer_surface: Additional transverse relaxation rate (kHz). Outer_surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2_inner_volume: Additional transverse relaxation rate (kHz). Inner_volume property. Field is required. Expected type: Float64.  default value: 0.0\nR2_outer_volume: Additional transverse relaxation rate (kHz). Outer_volume property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_inner_surface: Additional off-resonance field offset (kHz). Inner_surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_outer_surface: Additional off-resonance field offset (kHz). Outer_surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_inner_volume: Additional off-resonance field offset (kHz). Inner_volume property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_outer_volume: Additional off-resonance field offset (kHz). Outer_volume property. Field is required. Expected type: Float64.  default value: 0.0\nposition: Spatial offset of obstruction from origin. Field is required. Expected type: StaticArraysCore.MVector{2, Float64}.  default value: [0.0, 0.0]\nsusceptibility_iso: Isotropic component of the myelin susceptibility (in ppm). Field can be null. Expected type: Float64.  default value: -0.1\nsusceptibility_aniso: Ansotropic component of the myelin susceptibility (in ppm). Field can be null. Expected type: Float64.  default value: -0.1\nlorentz_radius: Only compute field explicitly for a annuli with this Lorentz radius. Field can be null. Expected type: Float64.  default value: 5.0\nrepeats: Length scale on which the obstructions are repeated (um). Field can be null. Expected type: StaticArraysCore.MVector{2, Float64}.\nuse_boundingbox: Use bounding boxes for an initial filtering of possible intersections. Field can be null. Expected type: Bool.  default value: true\ndwell_time_inner_surface: Average time a particle stays stuck to the surface (ms). Inner_surface property. Field can be null. Expected type: Float64.\ndwell_time_outer_surface: Average time a particle stays stuck to the surface (ms). Outer_surface property. Field can be null. Expected type: Float64.\ndensity_inner_surface: Surface density of stuck particles relative to the volume density (um). Inner_surface property. Field can be null. Expected type: Float64.\ndensity_outer_surface: Surface density of stuck particles relative to the volume density (um). Outer_surface property. Field can be null. Expected type: Float64.\npermeability_inner_surface: Probability of particle passing through the obstruction. Inner_surface property. Field can be null. Expected type: Float64.\npermeability_outer_surface: Probability of particle passing through the obstruction. Outer_surface property. Field can be null. Expected type: Float64.\nrelaxivity_inner_surface: Fraction of transverse spin lost each time it hits the obstruction. Inner_surface property. Field can be null. Expected type: Float64.\nrelaxivity_outer_surface: Fraction of transverse spin lost each time it hits the obstruction. Outer_surface property. Field can be null. Expected type: Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Cylinders","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Cylinders","text":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup{:Cylinders})(; fields...)\n\nCreates a set of Cylinder objects. Fields can be set using keyword arguments. The following fields are available:\n\nradius: Radius of the cylinder. Field is required. Expected type: Float64.\nrotation: Rotation applied to all obstructions in group. Can be set to a matrix or one of :x, :y, or, :z (see get_rotation). Field is required. Expected type: StaticArraysCore.SMatrix{3, 2, Float64, 6}.  default value: [1.0 0.0; 0.0 1.0; 0.0 0.0]\ngrid_resolution: Resolution of the grid that the volume is split up into (um). Field is required. Expected type: Float64.  default value: 1.0\nR1_surface: Additional longitudinal relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR1_inside: Additional longitudinal relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nR2_surface: Additional transverse relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2_inside: Additional transverse relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_surface: Additional off-resonance field offset (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_inside: Additional off-resonance field offset (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nposition: Spatial offset of obstruction from origin. Field is required. Expected type: StaticArraysCore.MVector{2, Float64}.  default value: [0.0, 0.0]\ng_ratio: Inner/outer radius used for susceptibility calculation Field can be null. Expected type: Float64.  default value: 1.0\nsusceptibility_iso: Isotropic component of the susceptibility (in ppm). Field can be null. Expected type: Float64.  default value: -0.1\nsusceptibility_aniso: Ansotropic component of the susceptibility (in ppm). Field can be null. Expected type: Float64.  default value: -0.1\nlorentz_radius: Only compute field explicitly for cylinders with this Lorentz radius. Field can be null. Expected type: Float64.  default value: 5.0\nrepeats: Length scale on which the obstructions are repeated (um). Field can be null. Expected type: StaticArraysCore.MVector{2, Float64}.\nuse_boundingbox: Use bounding boxes for an initial filtering of possible intersections. Field can be null. Expected type: Bool.  default value: true\ndwell_time: Average time a particle stays stuck to the surface (ms). Surface property. Field can be null. Expected type: Float64.\ndensity: Surface density of stuck particles relative to the volume density (um). Surface property. Field can be null. Expected type: Float64.\npermeability: Probability of particle passing through the obstruction. Surface property. Field can be null. Expected type: Float64.\nrelaxivity: Fraction of transverse spin lost each time it hits the obstruction. Surface property. Field can be null. Expected type: Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Mesh","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Mesh","text":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup{:Mesh})(; fields...)\n\nCreates a set of Triangle objects. Fields can be set using keyword arguments. The following fields are available:\n\ntriangles: Each triangle is defined by 3 vertices into the mesh. Field is required. Expected type: StaticArraysCore.MVector{3, Int64}.\nvertices: Positions of the corners of the triangular mesh. Field is required. Expected type: Vector{StaticArraysCore.MVector{3, Float64}}.\nmyelin: Whether the mesh is myelinated. Field is required. Expected type: Bool.  default value: false\nsave_memory: If true the internal triangle representation will contain the indices of the vertices rather than the actual corner coordinates. This will save memory, but slow down the algorithm as more memory lookups will have to take place. Field is required. Expected type: Bool.  default value: true\nrotation: Rotation applied to all obstructions in group. Can be set to a matrix or one of :x, :y, or, :z (see get_rotation). Field is required. Expected type: StaticArraysCore.SMatrix{3, 3, Float64, 9}.  default value: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]\ngrid_resolution: Resolution of the grid that the volume is split up into (um). Field is required. Expected type: Float64.  default value: 1.0\nR1_surface: Additional longitudinal relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR1_inside: Additional longitudinal relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nR2_surface: Additional transverse relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2_inside: Additional transverse relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_surface: Additional off-resonance field offset (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_inside: Additional off-resonance field offset (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nsusceptibility_iso: Isotropic component of the myelin susceptibility (in ppm). Field can be null. Expected type: Float64.  default value: -0.1\nsusceptibility_aniso: Ansotropic component of the myelin susceptibility (in ppm). Field can be null. Expected type: Float64.  default value: -0.1\nlorentz_radius: Only compute field explicitly for triangles with this Lorentz radius. Field can be null. Expected type: Float64.  default value: 5.0\nrepeats: Length scale on which the obstructions are repeated (um). Field can be null. Expected type: StaticArraysCore.MVector{3, Float64}.\nuse_boundingbox: Use bounding boxes for an initial filtering of possible intersections. Field can be null. Expected type: Bool.  default value: true\ndwell_time: Average time a particle stays stuck to the surface (ms). Surface property. Field can be null. Expected type: Float64.\ndensity: Surface density of stuck particles relative to the volume density (um). Surface property. Field can be null. Expected type: Float64.\npermeability: Probability of particle passing through the obstruction. Surface property. Field can be null. Expected type: Float64.\nrelaxivity: Fraction of transverse spin lost each time it hits the obstruction. Surface property. Field can be null. Expected type: Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Spheres","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Spheres","text":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup{:Spheres})(; fields...)\n\nCreates a set of Sphere objects. Fields can be set using keyword arguments. The following fields are available:\n\nradius: Radius of the cylinder. Field is required. Expected type: Float64.\nrotation: Rotation applied to all obstructions in group. Can be set to a matrix or one of :x, :y, or, :z (see get_rotation). Field is required. Expected type: StaticArraysCore.SMatrix{3, 3, Float64, 9}.  default value: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]\ngrid_resolution: Resolution of the grid that the volume is split up into (um). Field is required. Expected type: Float64.  default value: 1.0\nR1_surface: Additional longitudinal relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR1_inside: Additional longitudinal relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nR2_surface: Additional transverse relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2_inside: Additional transverse relaxation rate (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_surface: Additional off-resonance field offset (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance_inside: Additional off-resonance field offset (kHz). Inside property. Field is required. Expected type: Float64.  default value: 0.0\nposition: Spatial offset of obstruction from origin. Field is required. Expected type: StaticArraysCore.MVector{3, Float64}.  default value: [0.0, 0.0, 0.0]\nrepeats: Length scale on which the obstructions are repeated (um). Field can be null. Expected type: StaticArraysCore.MVector{3, Float64}.\nuse_boundingbox: Use bounding boxes for an initial filtering of possible intersections. Field can be null. Expected type: Bool.  default value: true\ndwell_time: Average time a particle stays stuck to the surface (ms). Surface property. Field can be null. Expected type: Float64.\ndensity: Surface density of stuck particles relative to the volume density (um). Surface property. Field can be null. Expected type: Float64.\npermeability: Probability of particle passing through the obstruction. Surface property. Field can be null. Expected type: Float64.\nrelaxivity: Fraction of transverse spin lost each time it hits the obstruction. Surface property. Field can be null. Expected type: Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Walls","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Walls","text":"MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup{:Walls})(; fields...)\n\nCreates a set of Wall objects. Fields can be set using keyword arguments. The following fields are available:\n\nrotation: Rotation applied to all obstructions in group. Can be set to a matrix or one of :x, :y, or, :z (see get_rotation). Field is required. Expected type: StaticArraysCore.SMatrix{3, 1, Float64, 3}.  default value: [1.0; 0.0; 0.0;;]\ngrid_resolution: Resolution of the grid that the volume is split up into (um). Field is required. Expected type: Float64.  default value: 1.0\nR1: Additional longitudinal relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nR2: Additional transverse relaxation rate (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\noff_resonance: Additional off-resonance field offset (kHz). Surface property. Field is required. Expected type: Float64.  default value: 0.0\nposition: Spatial offset of obstruction from origin. Field is required. Expected type: Float64.  default value: 0.0\nrepeats: Length scale on which the obstructions are repeated (um). Field can be null. Expected type: StaticArraysCore.MVector{1, Float64}.\nuse_boundingbox: Use bounding boxes for an initial filtering of possible intersections. Field can be null. Expected type: Bool.  default value: true\ndwell_time: Average time a particle stays stuck to the surface (ms). Surface property. Field can be null. Expected type: Float64.\ndensity: Surface density of stuck particles relative to the volume density (um). Surface property. Field can be null. Expected type: Float64.\npermeability: Probability of particle passing through the obstruction. Surface property. Field can be null. Expected type: Float64.\nrelaxivity: Fraction of transverse spin lost each time it hits the obstruction. Surface property. Field can be null. Expected type: Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Fields.Field","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Fields.Field","text":"Field{T}(name::Symbol[, description::String[, default_value::T]]; per_surface=false, per_volume=false, only_group=false, required=false)\n\nRepresents a property of an obstruction with:\n\nType: type of the property value (can also be Nothing unless required is true).\nname: name of the property.\ndescription: describes the property to the user.\ndefault_value: what the value is set to if not provided by the user.\nper_surface: can have a different value for each surface in the obstruction.\nper_volume: can have a different value within each enclosed volume of the obstruction.\nrequired: if true, the user has to provide a value, which cannot be nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Fields.FieldValue","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Fields.FieldValue","text":"FieldValue(field::Field{T}, n_obstructions, [, category::Symbol][, value])\n\nRepresents the value for a specific field across a vector of obstructions. For fields with multiple values (one per volume or surface), category is required to set this. The current value is given by value. This has to be type T or a vector of type T. For a non-required field, it can also be nothing (or a vector containing nothings).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.Fields.convert_value-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.Fields.convert_value","text":"convert_value(T, value, required::Bool)\n\nConvert value into type T or a vector of T. If required is false value can also be nothing or a vector containing T and nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.ObstructionTypes","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.ObstructionTypes","text":"Types:\n\nObstructionType\n\nMethods:\n\nfields\nkey_value_pairs\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.ObstructionTypes.ObstructionType","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.ObstructionTypes.ObstructionType","text":"Defines individual obstruction types\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.User.Obstructions.ObstructionTypes.key_value_pairs","page":"API","title":"MCMRSimulator.Geometries.User.Obstructions.ObstructionTypes.key_value_pairs","text":"key_value_pairs(obstruction_type, n_obstructions)\n\nDefines a mapping from symbols to FieldValue objects.\n\nReturns a type with:\n\na sub-set of symbols that are enough to set all unique field values.\na mapping from symbols to field values.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.User.Fix.apply_properties-Tuple{MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup, Vector{<:MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.FixedObstruction}, Int64, Int64}","page":"API","title":"MCMRSimulator.Geometries.User.Fix.apply_properties","text":"apply_properties(user_obstructions, internal_obstructions, index; surface, volume)\n\nApply the generic obstruction properties defined in user_obstruction to internal_obstructions. This function applies (if appropriate):\n\npositional shifts\nvolumetic and surface-bound MRI properties\ncollision properties\nrotation\nrepeats\nmesh vertices\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.Fix.fix-Tuple{AbstractVector}","page":"API","title":"MCMRSimulator.Geometries.User.Fix.fix","text":"fix(user_geometry; permeability=0., density=0., dwell_time=0., relaxivity=0.)\n\nCreates a fixed version of the user-created geometry that will be used internally by the simulator.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.Fix.fix_type","page":"API","title":"MCMRSimulator.Geometries.User.Fix.fix_type","text":"fix_type(group::ObstructionGroup, index)\n\nReplace user ObstructionGroup objects with a FixedGeometry.\n\nThis needs to be defined for each sub-type of ObstructionGroup,     e.g. Spheres, Annuli, Mesh.\n\nShifts, collision properties, and volumetric and surface MRI properties can be added using apply_properties.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.User.FixSusceptibility.fix_susceptibility-Tuple{AbstractVector}","page":"API","title":"MCMRSimulator.Geometries.User.FixSusceptibility.fix_susceptibility","text":"fix_susceptibility(geometry)\n\nCreate a new FixedSusceptibility based on the user-defined geometry settings.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.LoadMesh.load_mesh-Tuple{IO}","page":"API","title":"MCMRSimulator.Geometries.User.LoadMesh.load_mesh","text":"load_mesh(file)\n\nLoads a Mesh from a file.\n\nCurrently only PLY files are supported (see ply_from_mesh)\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.LoadMesh.ply_from_mesh-Tuple{Any}","page":"API","title":"MCMRSimulator.Geometries.User.LoadMesh.ply_from_mesh","text":"ply_from_mesh(file)\n\nLoads a Mesh from a PLY file. PLY stands for Polygon File Format (http://paulbourke.net/dataformats/ply/). PLY IO is handled by PlyIO.jl (https://github.com/JuliaGeometry/PlyIO.jl).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.RandomDistribution.random_positions_radii-Tuple{Any, Real, Int64}","page":"API","title":"MCMRSimulator.Geometries.User.RandomDistribution.random_positions_radii","text":"random_positions_radii(box_size, target_density, n_dimensions; distribution=Gamma, mean=1., variance=1., max_iter=1000, min_radius=0.1, max_radius=Inf)\n\nRandomly distributes circles or spheres in space.\n\nArguments:\n\nbox_size: Size of the infinitely repeating box of random positions\ntarget_density: Final density of the circles/spheres. This density will only be approximately reached\nn_dimensions: dimensionality of the space (2 for cicles; 3 for spheres)\ndistribution: distribution from which the radii are drawn (from Distributions.jl)\nmean: mean of the gamma distribution (ignored if distribution explicitly set)\nvariance: variance of the gamma distribution (ignored if distribution explicitly set)\nmax_iter: maximum number of iterations to try to prevent the circles/spheres from overlapping. An error is raised if they still overlap after this number of iterations.\nmin_radius: samples from the distribution below this radius will be rejected (in um).\nmax_radius: samples from the distribution above this radius will be rejected (in um).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.SplitMesh","page":"API","title":"MCMRSimulator.Geometries.User.SplitMesh","text":"Mesh-specific operations to normalise and split a mesh.\n\nsplit_mesh: applies all the normalisations and splitting\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.SplitMesh.connected_components","page":"API","title":"MCMRSimulator.Geometries.User.SplitMesh.connected_components","text":"connected_components(triangles)\n\nSplits the mesh represented by triangles into a sequences of meshes that are actually internally connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.User.SplitMesh.connected_components-Tuple{SparseArrays.SparseMatrixCSC}","page":"API","title":"MCMRSimulator.Geometries.User.SplitMesh.connected_components","text":"connected_components(connectivity_matrix)\n\nReturns a vector of indices, where each connected component has been given a unique index (starting with 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.SplitMesh.connectivity_matrix","page":"API","title":"MCMRSimulator.Geometries.User.SplitMesh.connectivity_matrix","text":"connectivity_matrix(triangles, nvertices)\n\nCreate a nverticesxnvertices sparse boolean matrix, which is true for any connected vertices.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.User.SplitMesh.curvature-NTuple{4, Any}","page":"API","title":"MCMRSimulator.Geometries.User.SplitMesh.curvature","text":"curvature(triangles, vertices[index1, index2])\n\nComputes the curvature between two neighbouring triangles (index1 and index2). If no indices are provided computes the curvature between any neighbouring triangles.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.SplitMesh.make_normals_consistent!-Tuple{AbstractVector}","page":"API","title":"MCMRSimulator.Geometries.User.SplitMesh.make_normals_consistent!","text":"make_normals_consistent!(triangles)\n\nAdjust the triangles to all point outwards or all point inwards. Assumes that all the triangles are connected (can be enforced using connected_components).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.SplitMesh.neighbours-Tuple{AbstractVector}","page":"API","title":"MCMRSimulator.Geometries.User.SplitMesh.neighbours","text":"neighbours(triangles)\n\nReturn pairs of indices of triangles that share an edge.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.SplitMesh.split_mesh-Tuple{MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup{:Mesh}}","page":"API","title":"MCMRSimulator.Geometries.User.SplitMesh.split_mesh","text":"split_mesh(mesh::Mesh)\n\nReturns a vector of meshes that have been adjusted in the following ways:\n\nthe complete mesh has been split into its connected components.\nthe order of the indices in the triangles has been fixed, so that all normals point outwards.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.JSON","page":"API","title":"MCMRSimulator.Geometries.User.JSON","text":"Supports I/O to and from json\n\nFunctions:\n\nwrite_geometry\nread_geometry\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.User.JSON.read_geometry-Tuple{IO}","page":"API","title":"MCMRSimulator.Geometries.User.JSON.read_geometry","text":"read_geometry(filename/io)\n\nRead geometry from a JSON file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.User.JSON.write_geometry-Tuple{Any}","page":"API","title":"MCMRSimulator.Geometries.User.JSON.write_geometry","text":"write_geometry([io, ]geometry)\n\nWrites the user-defined geometry as a JSON file. If no IO is provided, the geometry is written to stdout.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal","page":"API","title":"MCMRSimulator.Geometries.Internal","text":"Internal representation of the tissue geometry.\n\nAll objects are immutable and optimised for both memory usage and computational speed.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.RayGridIntersection","page":"API","title":"MCMRSimulator.Geometries.Internal.RayGridIntersection","text":"Methods:\n\nray_grid_intersections\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.RayGridIntersection.ray_grid_intersections-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Float64}, StaticArraysCore.SVector{N, Float64}}} where N","page":"API","title":"MCMRSimulator.Geometries.Internal.RayGridIntersection.ray_grid_intersections","text":"ray_grid_intersections(origin, destination)\n\nComputes all voxels crossed by a ray between origin and destination with an inifinitely extending 1x1x1 grid. Both origin and destination are length-3 vectors. The returned object is an iterator returning a tuple with:\n\nN-length vector with the voxel that we are crossing through\nFloat with the time the ray entered voxel (0=origin, 1=destination)\nN-length vector with position within voxel that the ray entered (i.e., numbers between 0 and 1)\nFloat with the time the ray left the voxel (0=origin, 1=destination)\nN-length vector with position within voxel that the ray left (i.e., numbers between 0 and 1)\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.BoundingBoxes","page":"API","title":"MCMRSimulator.Geometries.Internal.BoundingBoxes","text":"Types:\n\nBoundingBox: N-dimensional box fully containing an obstruction.\n\nMethods:\n\nisinside: returns whether point/spin is inside of bounding box\ncould_intersect: returns whether spin trajectory could intersect with obstruction in bounding box\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.BoundingBoxes.BoundingBox","page":"API","title":"MCMRSimulator.Geometries.Internal.BoundingBoxes.BoundingBox","text":"BoundingBox(lower::Vector, upper::Vector)\nBoundingBox([center::Vector, ]radius::Number)\n\nRepresents a box in N-dimensional space.\n\nCheck whether particles are inside using isinside.\n\nThe main usage in the simulator is using could_intersect,  which checks whether a spin trajectory could intersect with the obstruction in the bounding box.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.BoundingBoxes.could_intersect-Tuple{BoundingBox{1}, AbstractVector, AbstractVector}","page":"API","title":"MCMRSimulator.Geometries.Internal.BoundingBoxes.could_intersect","text":"could_intersect(bounding_box, start, dest)\n\nReturns true if a line connecting start to dest could intersect with an obstruction in bounding_box. This function only does some very fast, high-level checks. Just because it returns true does not mean that there is an interesection of the obstruction (or even the bounding box) with the line. However, if it returns false, there is guaranteed to be no intersection.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions","text":"Defines all the base obstructions supported by MCMRSimulator.\n\nThey are all sub-types of FixedObstruction.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections","text":"Types:\n\nObstructionIntersection\n\nAttributes:\n\nempty_obstruction_intersections\n\nMethods:\n\nhas_intersection\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections.empty_obstruction_intersections","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections.empty_obstruction_intersections","text":"ObstructionIntersection objects that indicate that no intersection was found.\n\nThis is a tuple with the ObstructionIntersection for 1, 2, or 3 dimensions.\n\n\n\n\n\n","category":"constant"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections.ObstructionIntersection","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections.ObstructionIntersection","text":"ObstructionIntersection{N}(distance, normal)\n\nRepresents an intersection with a [FixedObstruction]{N}. Distance should be between 0 and 1 indicating where the obstruction intersects.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections.has_intersection-Tuple{MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections.ObstructionIntersection}","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections.has_intersection","text":"has_intersection(intersection)\n\nReturn true if the intersection object represents a true intersection.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions","text":"Types:\n\nFixedObstruction\n\nMethods:\n\ndetect_intersection\nhas_inside\nisinside\nradius\nBoundingBox\nobstruction_type\nrandom_surface_positions\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.BoundingBoxes.BoundingBox-Union{Tuple{MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.FixedObstruction{N}}, Tuple{N}} where N","page":"API","title":"MCMRSimulator.Geometries.Internal.BoundingBoxes.BoundingBox","text":"BoundingBox(obstruction[, vertices])\n\nReturns the smallest bounding box that fully encloses the FixedObstruction.\n\nvertices will only be provided for the [IndexTriangle] type.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.FixedObstruction","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.FixedObstruction","text":"Parent type of all individual obstructions.\n\nN represents the intrinsic dimensionality of the obstruction (e.g., 1 for walls, 2 for cylinders, 3 for spheres/meshes)\n\nRequired interface for each obstruction:\n\ndetect_intersection(obstruction, start, dest) -> ObstructionIntersection\nhas_inside(obstruction_type) -> Boolean\nisinside(obstruction, position) -> Boolean\nAt least one of these two:\nradius(obstruction): returns the radius of the obstruc\nBoundingBox(obstruction): returns a Bounding box surrounding the obstruction\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.BoundingBoxes.isinside-Union{Tuple{N}, Tuple{MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.FixedObstruction{N}, AbstractVector}} where N","page":"API","title":"MCMRSimulator.Geometries.Internal.BoundingBoxes.isinside","text":"isinside(obstruction, position)\n\nReturns true if the position is inside the obstruction. This will be inaccurate if the particle with that position is stuck on the surface of the obstruction.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.detect_intersection","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.detect_intersection","text":"detect_intersection(obstruction, start, dest[, inside])\n\nDetermines whether the line from start to dest intersects with obstruction. If no intersection is found, empty_obstruction_intersection is returned. Otherwise a ObstructionIntersection object is returned.\n\nIf inside is set, the last collision in the trajectory was with this obstruction. inside indicates whether this previous collision was with the inside of the obstruction. This is passed on to prevent the particle from colliding with the same obstruction multiple times without any intermediate movement.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.has_inside","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.has_inside","text":"has_inside(obstruction_type)\n\nReturns true if a particular sub-type of FixedObstruction has an inside.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.obstruction_type-Union{Tuple{Type{O}}, Tuple{O}} where O<:MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.FixedObstruction","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.obstruction_type","text":"obstruction_type(obstruction/geometry)\n\nReturns the type of the obstruction that this geometry is built up out of\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.radius","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.radius","text":"radius(cylinder/sphere...)\n\nReturns the radius of an obstruction.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.random_surface_positions","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.random_surface_positions","text":"random_surface_positions(obstruction, surface_density)\n\nReturns a vector of positions and normals on the normals of a specific obstruction. Normals should always assume that the particle is on the inside.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.size_scale-Tuple{MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.FixedObstruction}","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.size_scale","text":"size_scale(obstruction/geometry)\n\nReturns the size scale of the smallest object within the geometry (typically the radius or the repeating length scale).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.Triangles.detect_intersection_partial-Union{Tuple{N}, Tuple{MCMRSimulator.Geometries.Internal.Obstructions.Triangles.FullTriangle, StaticArraysCore.SVector{N}, StaticArraysCore.SVector{N}}, Tuple{MCMRSimulator.Geometries.Internal.Obstructions.Triangles.FullTriangle, StaticArraysCore.SVector{N}, StaticArraysCore.SVector{N}, Any}} where N","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.Triangles.detect_intersection_partial","text":"Computes the intersection for a triangle in a mesh (returned by detect_intersection). This function also returns an additional bool. This bool will be true if the intersection is exactly at the edge of the triangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.Triangles.normal-Tuple{AbstractVector, AbstractVector, AbstractVector}","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.Triangles.normal","text":"normal(p1, p2, p3)\n\nComputes the normal of a triangle formed by the three points\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.Triangles.triangle_size-Tuple{Any, Any, Any}","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.Triangles.triangle_size","text":"triangle_size(p1, p2, p3)\n\nComputes the size of a triangle formed by three points\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.Shifts.Shift","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.Shifts.Shift","text":"Shifts the obstruction base from the origin to shift.\n\nThe resulting object itself behaves like the base obstruction.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Gridify.Grid","page":"API","title":"MCMRSimulator.Geometries.Internal.Gridify.Grid","text":"Grid(obstructions, vertices, grid_resolution[, repeats])\n\nPredetermines the interactions between the obstructions and the grid. This is determined purely based on the bounding boxes (could be improved by considering the shape of each obstruction).\n\nAttributes:\n\nlower: lower left coordinate of the final grid (in um).\nsize: size of the grid (in um).\nresolution: resolution of each element in the grid.\nindices: Vector of pairs of indices for each element in the grid. The first index indicates the index of the obstruction intersecting with the grid. The second index indicates the shift that should be applied to that obstruction (zero if there is no shift).\nshifts: Vector of the shifts that should be applied to obstructions to create a valid repeating grid.\nrepeating: true if the grid is repeating.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Gridify.get_indices-Tuple{MCMRSimulator.Geometries.Internal.Gridify.Grid, AbstractVector}","page":"API","title":"MCMRSimulator.Geometries.Internal.Gridify.get_indices","text":"get_indices(grid, position)\n\nGet the indices of obstructions that contain the position.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Reflections","page":"API","title":"MCMRSimulator.Geometries.Internal.Reflections","text":"Types:\n\nReflection\n\nMethods:\n\ndirection\nhas_hit\nprevious_hit\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Reflections.Reflection","page":"API","title":"MCMRSimulator.Geometries.Internal.Reflections.Reflection","text":"Reflection(intersection, direction, timestep, ratio_displaced, time_moved, distance_moved, permeable=false)\n\nRepresents a reflection of a particle after colliding.\n\nParameters:\n\nintersection: Intersection represents the intersection of the trajectory with an obstruction. This will supply:\ngeometry_index: index of the geometry that got hit.\nobstruction_index: index of the obstruction that got hit within the geometry.\ninside: whether the inside of the obstruction was hit.\ndirection: this is stored in an updated form if the obstruction is not permeable (i.e., we have an actual reflection) as indicated by the permeable parameter.\nratio_displaced: how large the displacement drawn from the Gaussian distribution was relative to that expected for the timestep.   This is calculated as \"step_size / sqrt(timestep)\".\ntime_moved: how long the particle has already been moving since the last time it was free at the start of a timestep (in ms).\ndistance_moved: how far the particle has already moved (in um).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Reflections.Reflection-Tuple{Any}","page":"API","title":"MCMRSimulator.Geometries.Internal.Reflections.Reflection","text":"Reflection(ratio_displaced)\n\nCreates a \"virtual\" Reflection that represents the movement of a free particle as drawn at the start of a timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections.has_intersection-Tuple{MCMRSimulator.Geometries.Internal.Reflections.Reflection}","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.ObstructionIntersections.has_intersection","text":"has_intersection(reflection)\n\nReturns true if this reflection is not empty, i.e., it represents a real collision with an obstruction.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Reflections.direction-Tuple{MCMRSimulator.Geometries.Internal.Reflections.Reflection, Any, Any}","page":"API","title":"MCMRSimulator.Geometries.Internal.Reflections.direction","text":"direction(reflection, remaining_time)\n\nReturns the displacement that the spin should end up if it has remaining_time ms left in this timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Reflections.has_hit-Tuple{MCMRSimulator.Geometries.Internal.Reflections.Reflection}","page":"API","title":"MCMRSimulator.Geometries.Internal.Reflections.has_hit","text":"has_hit(reflection)\n\nReturns a tuple with the indices of the obstruction that the particle is reflecting off.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Reflections.previous_hit-Tuple{MCMRSimulator.Geometries.Internal.Reflections.Reflection}","page":"API","title":"MCMRSimulator.Geometries.Internal.Reflections.previous_hit","text":"previous_hit(reflection)\n\nReturns a tuple with the details of the previous reflection relevant for detect_intersection.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.FixedObstructionGroups","page":"API","title":"MCMRSimulator.Geometries.Internal.FixedObstructionGroups","text":"Types:\n\nFixedGeometry\nFixedObstructionGroup\n\nMethods:\n\nhas_inside\nisinside\ndetect_intersection\nsize_scale\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.BoundingBoxes.BoundingBox-Tuple{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup}","page":"API","title":"MCMRSimulator.Geometries.Internal.BoundingBoxes.BoundingBox","text":"BoundingBox(obstruction_group)\n\nFinds the bounding box containing all the obstructions in the FixedObstructionGroup ignoring any repeats or rotation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedGeometry","page":"API","title":"MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedGeometry","text":"FixedGeometry([obstruction_groups...])\n\nA collection of FixedObstructionGroup objects each reperesenting part of the geometry.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup","page":"API","title":"MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup","text":"Collection of L base FixedObstruction objects.\n\nThis is the main internal representation of a group of identical FixedObstruction objects.\n\nProperties:\n\nobstructions: vector of the actual FixedObstruction objects.\nparent_index: Index of this group within the larger FixedGeometry.\noriginal_index: Index of this group within the original user-provided geometry.\nrotation: rotation from global 3-dimensional space to the 1, 2, or 3-dimensional space of the obstructions.\ninv_rotation: inverse of the rotation above\ngrid: Grid object on which the obstruction intersections have been precomputed. This speeds up the detection of intersections.\nbounding_boxes: vector of BoundingBox objects for each obstruction. These are used to predect whether a spin could intersect with the obstruction.\nvolume: R1, R2, and off-resonance properties of the spins inside the obstructions.\nsurface: R1, R2, off-resonance, surfacedensity and dwelltime properties of particles stuck to the surface. Also, contains the permeability and surface relaxivity to process collsions.\nvertices: vector of vertices (only used for a mesh).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.BoundingBoxes.isinside","page":"API","title":"MCMRSimulator.Geometries.Internal.BoundingBoxes.isinside","text":"isinside(geometry, position[, stuck_reflection])\n\nReturns a vector of pairs of indices with all the obstructions in FixedGeometry containing the position (in order). The first index indicates the index of the FixedObstructionGroup within the geometry. The second index is the index of the specific FixedObstruction within the obstruction group.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.Internal.BoundingBoxes.isinside-Union{Tuple{L}, Tuple{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup{L, N} where N, StaticArraysCore.SVector{3}}, Tuple{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup{L, N} where N, StaticArraysCore.SVector{3}, MCMRSimulator.Geometries.Internal.Reflections.Reflection}} where L","page":"API","title":"MCMRSimulator.Geometries.Internal.BoundingBoxes.isinside","text":"isinside(obstruction_group, position[, stuck_to])\n\nReturns a vector of indices with all the obstructions in FixedObstructionGroup containing the position (in order). For obstructions with only a single inside, will return an empty vector (\"[]\") if the particle is outside and a \"[0]\" if inside.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.detect_intersection-Union{Tuple{N}, Tuple{L}, Tuple{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup{L, N, R, O, B} where {R, O<:MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.FixedObstruction{N}, B<:Union{Nothing, Array{BoundingBox{N}, 1}}}, StaticArraysCore.SVector{3}, StaticArraysCore.SVector{3}}, Tuple{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup{L, N, R, O, B} where {R, O<:MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.FixedObstruction{N}, B<:Union{Nothing, Array{BoundingBox{N}, 1}}}, StaticArraysCore.SVector{3}, StaticArraysCore.SVector{3}, Tuple{Int64, Int64, Bool}}} where {L, N}","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.detect_intersection","text":"detect_intersection(obstruction_group/geometry, start, dest[, previous_intersection])\n\nFind the closest intersection between the line from start to dest and an obstruction in the geometry(ies).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.random_surface_positions-Union{Tuple{N}, Tuple{L}, Tuple{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup{L, N, R, O, B} where {R, O<:MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.FixedObstruction{N}, B<:Union{Nothing, Array{BoundingBox{N}, 1}}}, BoundingBox{3}, Number}} where {L, N}","page":"API","title":"MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.random_surface_positions","text":"random_surface_positions(group/geometry, bounding_box, volume_density)\n\nRandomly draws positions on the surface within the BoundingBox. The density of points will be equal to surface_density * volume_density, where surface_density is either set by the group itself or by default_surface_density (which should come from GlobalProperties).\n\nFor each drawn position will return a tuple with:\n\nposition: 3D in um\nsurface normal: 3D, normalised (always pointing inwards)\ngeometry_index: index of the group\nobstruction_index: index of the obstruction within the group that the position is on the surface of\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Properties","page":"API","title":"MCMRSimulator.Geometries.Internal.Properties","text":"Methods to extract properties from the FixedGeometry.\n\nMRI properties (using MRIProperties):\n\nR1\nR2\noff_resonance\n\nCollision properties:\n\npermeability\nsurface_relaxivity\nsurface_density\ndwell_time\n\nOthers:\n\nmax_timestep_sticking\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Properties.MRIProperties","page":"API","title":"MCMRSimulator.Geometries.Internal.Properties.MRIProperties","text":"MRIProperties(R1, R2, off_resonance)\nMRIProperties(full_geometry, inside_geometry, global_properties, position, reflection)\n\nDetermines the R1, R2, and off-resonance of a particle at given position and bound at Reflection.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Properties.dwell_time-Tuple{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup, Int64}","page":"API","title":"MCMRSimulator.Geometries.Internal.Properties.dwell_time","text":"dwell_time(geometry, reflection)\n\nReturns the dwell_time experienced by the spin hitting the surface represented by a Reflection. The geometry has to be a FixedGeometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Properties.max_timestep_sticking-Tuple{Tuple{Vararg{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup, N}} where N, Number}","page":"API","title":"MCMRSimulator.Geometries.Internal.Properties.max_timestep_sticking","text":"max_timestep_sticking(geometry, diffusivity)\n\nReturns the maximum timestep that can be used while keeping stick_probability lower than 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Properties.permeability-Tuple{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup, Int64}","page":"API","title":"MCMRSimulator.Geometries.Internal.Properties.permeability","text":"permeability(geometry, reflection)\n\nReturns the permeability experienced by the spin hitting the surface represented by a Reflection. The geometry has to be a FixedGeometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Properties.surface_density-Tuple{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup, Int64}","page":"API","title":"MCMRSimulator.Geometries.Internal.Properties.surface_density","text":"surface_density(geometry, reflection)\n\nReturns the surface_density experienced by the spin hitting the surface represented by a Reflection. The geometry has to be a FixedGeometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Properties.surface_relaxivity-Tuple{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup, Int64}","page":"API","title":"MCMRSimulator.Geometries.Internal.Properties.surface_relaxivity","text":"surface_relaxivity(geometry, reflection)\n\nReturns the surface_relaxivity experienced by the spin hitting the surface represented by a Reflection. The geometry has to be a FixedGeometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Base","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Base","text":"Types:\n\nSusceptibility\n\nMethods:\n\nsingle_susceptibility\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Base.BaseSusceptibility","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Base.BaseSusceptibility","text":"BaseSusceptibility{N}\n\nParent type of all susceptibility sources. Each BaseSusceptibility object represents a single susceptibility source in N-dimensional space  (e.g., N=2 for CylinderSusceptibility or N=3 for PointSusceptibility).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Base.single_susceptibility","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Base.single_susceptibility","text":"single_susceptibility(source::BaseSusceptibility, offset, distance, stuck_to, b0_field)\n\nComputes the off-resonance field contribution from a BaseSusceptibility source given:\n\noffset vector from spin position to the centre of the source\ndistance of the spin from the source (which is the norm of offset)\nstuck_to tuple with the pair of indices that the particle is stuck to as well as a boolean indicating whether it is stuck to the inside.\nb0_field N-length vector with the magnetic field within the coordinate system of the susceptibility source\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Base.single_susceptibility_gradient","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Base.single_susceptibility_gradient","text":"single_susceptibility_gradient(source::BaseSusceptibility)\n\nMaximal off-resonance gradient in ppm/um produced by a single susceptibility source.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Parent.FixedSusceptibility","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Parent.FixedSusceptibility","text":"Tuple containing all susceptibility sources\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Parent.ParentSusceptibility","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Parent.ParentSusceptibility","text":"ParentSusceptibility(base::BaseSusceptibility, rotation, repeats, lorentz_radius)\n\nGroup of L BaseSusceptibility susceptibility sources.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Parent.off_resonance_gradient-Tuple{MCMRSimulator.Geometries.Internal.Susceptibility.Parent.ParentSusceptibility, Any}","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Parent.off_resonance_gradient","text":"off_resonance_gradient(susceptibility, B0)\n\nMaximum gradient of the off-resonance field in kHz/um due to the local susceptibility sources. Internally, computed for each susceptibility sources using single_susceptibility_gradient. The maximum out of these is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Parent.susceptibility_off_resonance-Union{Tuple{N}, Tuple{L}, Tuple{MCMRSimulator.Geometries.Internal.Susceptibility.Parent.ParentSusceptibility{L, N, O, R} where {O<:MCMRSimulator.Geometries.Internal.Susceptibility.Base.BaseSusceptibility{N}, R<:Union{Nothing, StaticArraysCore.SVector{N, Float64}}}, StaticArraysCore.SVector{3, Float64}}, Tuple{MCMRSimulator.Geometries.Internal.Susceptibility.Parent.ParentSusceptibility{L, N, O, R} where {O<:MCMRSimulator.Geometries.Internal.Susceptibility.Base.BaseSusceptibility{N}, R<:Union{Nothing, StaticArraysCore.SVector{N, Float64}}}, StaticArraysCore.SVector{3, Float64}, Union{Nothing, Bool}}} where {L, N}","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Parent.susceptibility_off_resonance","text":"susceptibility_off_resonance(susceptibility/geometry, position[, inside])\n\nComputes the susceptibility off-resonance caused by a single BaseSusceptibility  or all the susceptibility sources in a FixedGeometry at the given position.\n\nThe field is computed in ppm. Knowledge of the scanner B0 is needed to convert it into KHz.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Cylinder.CylinderSusceptibility","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Cylinder.CylinderSusceptibility","text":"CylinderSusceptibility(radius, g_ratio, chi_I, chi_A, b0_field)\n\nCreates a cylindrical susceptibility source, which produces the intra- and extra-axonal field expected for a myelin sheath. More realistic myelin sheaths with a finite width can be modeled using AnnulusSusceptibility.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Base.single_susceptibility-Tuple{MCMRSimulator.Geometries.Internal.Susceptibility.Cylinder.CylinderSusceptibility, AbstractVector, Number, Union{Nothing, Bool}, StaticArraysCore.SVector{2, Float64}}","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Base.single_susceptibility","text":"single_susceptibility(cylinder, position, distance, stuck_to, b0_field)\n\nComputed by the hollow cylinder fiber model from (Wharton and Bowtell, 2012). The myelin sheath is presumed to be an infinitely thin cylinder.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Annulus.AnnulusSusceptibility","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Annulus.AnnulusSusceptibility","text":"AnnulusSusceptibility(inner_radius, outer_radius, chi_I, chi_A, b0_field)\n\nCreates an annular susceptibility source, which computes the off-resonance field expected for a myelin sheath.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Base.single_susceptibility-Tuple{MCMRSimulator.Geometries.Internal.Susceptibility.Annulus.AnnulusSusceptibility, AbstractVector, Number, Union{Nothing, Bool}, StaticArraysCore.SVector{2, Float64}}","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Base.single_susceptibility","text":"single_susceptibility(annulus, position, distance, stuck_inside, b0_field)\n\nComputed by the hollow cylinder fiber model from (Wharton and Bowtell, 2012).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Triangle","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Triangle","text":"Computes the off-resonance field produced by a triangular mesh:\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Triangle.TriangleSusceptibility","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Triangle.TriangleSusceptibility","text":"TriangleSusceptibility(full_triangle, chi_I, chi_A, b0_field)\n\nComputes the field produced by a triangular susceptibility source One triangle vertex is assumed to be at the origin.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Base.single_susceptibility-Tuple{MCMRSimulator.Geometries.Internal.Susceptibility.Triangle.TriangleSusceptibility, AbstractVector, Number, Union{Nothing, Bool}, StaticArraysCore.SVector{3, Float64}}","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Base.single_susceptibility","text":"single_susceptibility(triangle, position, distance[, stuck_inside])\n\nComputed using the algorithm described in (Rubeck *et al.*, 2013).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.Susceptibility.Triangle.right_angle_triangle_field-Tuple{Number, Number, Number}","page":"API","title":"MCMRSimulator.Geometries.Internal.Susceptibility.Triangle.right_angle_triangle_field","text":"right_angle_triangle_field(a, b, c)\n\nReturns the magnetic field experienced at (0, 0, z) generated by a triangle with edges (0, 0, 0), (a, 0, 0), (a, b, 0). The susceptibility of the triangle is assumed to be sigma_m = 4 pi mu_0.\n\nThis uses equations 8-10 from (Rubeck *et al.*, 2013). Note that these equations assume a and b to be positive.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Geometries.Internal.IsInsideMesh","page":"API","title":"MCMRSimulator.Geometries.Internal.IsInsideMesh","text":"Special functions to determine if a particle is inside a mesh.\n\nFunctions:\n\nisinside_grid\nisinside\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Geometries.Internal.IsInsideMesh.isinside_grid-Tuple{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup{L, 3, R, MCMRSimulator.Geometries.Internal.Obstructions.Triangles.IndexTriangle, B, V, S} where {L, R, B, V, S}}","page":"API","title":"MCMRSimulator.Geometries.Internal.IsInsideMesh.isinside_grid","text":"isinside_grid(mesh)\n\nDetermines for the centre of each voxel in mesh.grid, whether it lies inside or outside of the mesh. This function assumes that the mesh has been normalised (i.e., all normals point outwards).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Spins","page":"API","title":"MCMRSimulator.Spins","text":"Types:\n\nSnapshot\nSpin\nSpinOrientation\nFixedXoshiro\n\nMethods:\n\nlongitudinal\ntransverse\nphase\norientation\nisinside\nstuck\nstuck_to\nget_sequence\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Spins.FixedXoshiro","page":"API","title":"MCMRSimulator.Spins.FixedXoshiro","text":"Immutable version of the Xoshiro random number generator state\n\nUsed to store the current state in the Spin object. To evolve the spin in a predictable manner set the seed using copy!(spin.rng, Random.TaskLocalRNG).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Spins.Snapshot","page":"API","title":"MCMRSimulator.Spins.Snapshot","text":"Represents the positions and orientations of multiple Spin objects at a specific time.\n\nNote that times are in milliseconds and positions in micrometer.  The equilibrium longitudinal spin (after T1 relaxation) is always 1.\n\nUseful constructors\n\nSnapshot(positions; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)\nSnapshot(nspins[, bounding_box[, geometry]]; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)\nSnapshot(nspins, simulation[, bounding_box; time=0., longitudinal=1., transverse=0., phase=0., nsequences=1)\n\nCreates a new Snapshot at the given time with spins initialised for simulating nsequences sequences. All spins will start out in equilibrium, but that can be changed using the longitudinal, transverse, and/or phase flags. This initial spin locations are given by positions (Nx3 matrix or sequence of vectors of size 3). Alternatively the number of spins can be given in which case the spins are randomly distributed in the given bounding_box (default: 1x1x1 mm box centered on origin). The bounding_box can be a BoundingBox object, a tuple with the lower and upper bounds (i.e., two vectors of length 3) or a number r (resulting in spins filling a cube from -r to +r)\n\nSnapshot(snap::Snapshot{1}, nsequences)\n\nReplicates the positions and orientations for a single sequence in the input snapshot across nsequences.\n\nExtracting summary information\n\nlongitudinal(snapshot) to get the nsequences spin magnitudes in the z-direction (equilibrium of 1) averaged over all spins\ntransverse(snapshot) to get the nsequences spin magnitudes in the x-y-plane averaged over all spins\nphase(snapshot) to get the nsequences spin angles in x-y plane (in degrees) averaged over all spins\norientation(snapshot) to get a (nsequencesx3) matrix with the spin orientations in 3D space averaged over all spins\nSpinOrientation(snapshot) to get a nsequences vector of [SpinOrientation] objects with the average spin orientation across all spins\nposition.(snapshot) to get a the position for each spin in a vector (no averaging applied)\n\nInformation for a single sequence can be extracted by calling get_sequence first.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Spins.Spin","page":"API","title":"MCMRSimulator.Spins.Spin","text":"Spin particle with a position and nsequences spin orientations (stored as SpinOrientation).\n\nA random number generator is stored in the Spin object as well, which will be used for evolving the spin into the future in a reproducible manner.\n\nConstructors\n\nSpin(;nsequences=1, position=[0, 0, 0], longitudinal=1., transverse=0., phase=0.)\n\nCreates a new spin with nsequences identical spin orientations (given by longitudinal, transverse, and phase flags). The spin will start at given position.\n\nSpin(reference_spin::Spin{1}, nsequences)\n\nCreate a new spin with the same position as reference_spin with the orientation of reference_spin replicated nsequences times.\n\nExtracting spin information\n\nlongitudinal to get the nsequences spin magnitudes in the z-direction (equilibrium of 1)\ntransverse to get the nsequences spin magnitudes in the x-y-plane\nphase to get the nsequences spin angles in x-y plane (in degrees)\norientation to get a (nsequencesx3) matrix with the spin orientations in 3D space\nposition to get a length-3 vector with spin location\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Spins.SpinOrientation","page":"API","title":"MCMRSimulator.Spins.SpinOrientation","text":"SpinOrientation(longitudinal, transverse, phase)\n\nThe spin orientation. Usually created as part of a Spin object.\n\nSpinOrientation(snapshot::Snapshot)\n\nReturns the average spin orientations of all Spin objects in the Snapshot.\n\nThis information can be extracted using:\n\nlongitudinal to get the spin in the z-direction (equilibrium of 1)\ntransverse to get the spin in the x-y-plane\nphase to get the spin angle in x-y plane (in degrees)\norientation to get the spin orientation as a length-3 vector\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Spins.SpinOrientationSum","page":"API","title":"MCMRSimulator.Spins.SpinOrientationSum","text":"SpinOrientationSum(snapshot)\n\nComputes the total signal and the number of spins in a Snapshot. The number of spins can be found by running length(spin_orientation_sum). The spin orientation information can be found in the same way as for SpinOrientation, namely by calling transverse, longitudinal, or phase.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Geometries.Internal.BoundingBoxes.isinside-Tuple{Any, AbstractVector}","page":"API","title":"MCMRSimulator.Geometries.Internal.BoundingBoxes.isinside","text":"isinside([geometry, ]spin)\n\nReturns vector of obstructions that the spin is inside. If geometry is not provided, will return a vector of indices instead. If a non-fixed geometry is provided, will return the number of obstructions that the spin is inside.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Methods.phase","page":"API","title":"MCMRSimulator.Methods.phase","text":"phase(spin)\nphase(snapshot)\n\nReturns the phase in the x-y plane of the spin for a single particle (Spin) or averaged across a group of particles in a [Snapshot]. When orientations for multiple sequences are available  an array of phase values is returned with a value for each sequence.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Properties.R1","page":"API","title":"MCMRSimulator.Properties.R1","text":"R1(spin, geometry, global_properties)\nR1(position, geometry, global_properties[, stuck_to])\n\nReturns the R1 experienced by the Spin given the surface and volume properties of the FixedGeometry. Alternatively, the position of the spin can be provided. In this case the Reflection should also be returned for a bound spin.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Properties.R2","page":"API","title":"MCMRSimulator.Properties.R2","text":"R2(spin, geometry, global_properties)\nR2(position, geometry, global_properties[, stuck_to])\n\nReturns the R2 experienced by the Spin given the surface and volume properties of the FixedGeometry. Alternatively, the position of the spin can be provided. In this case the Reflection should also be returned for a bound spin.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Properties.off_resonance","page":"API","title":"MCMRSimulator.Properties.off_resonance","text":"off_resonance(spin, geometry, global_properties)\noff_resonance(position, geometry, global_properties[, stuck_to])\n\nReturns the off_resonance experienced by the Spin given the surface and volume properties of the FixedGeometry. Alternatively, the position of the spin can be provided. In this case the Reflection should also be returned for a bound spin.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Spins.get_sequence-Tuple{Spin, Any}","page":"API","title":"MCMRSimulator.Spins.get_sequence","text":"get_sequence(spin, sequence_index)\nget_sequence(snapshot, sequence_index)\n\nExtracts the spin orientation corresponding to a specific sequence, where the sequence index uses the order in which the sequences where provided in the Simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Spins.longitudinal","page":"API","title":"MCMRSimulator.Spins.longitudinal","text":"longitudinal(spin)\nlongitudinal(snapshot)\n\nReturns the longitudinal magnitude of the spin (i.e., magnitude aligned with the magnetic field) for a single particle (Spin) or averaged across a group of particles in a [Snapshot]. When orientations for multiple sequences are available an array of longitudinal values is returned with a value for each sequence.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Spins.orientation","page":"API","title":"MCMRSimulator.Spins.orientation","text":"orientation(spin)\norientation(snapshot)\n\nReturns the spin orientation as a length-3 vector for a single particle (Spin) or averaged across a group of particles in a [Snapshot]. When orientations for multiple sequences are available an array of vectors is returned with a value for each sequence.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Spins.position-Tuple{Snapshot}","page":"API","title":"MCMRSimulator.Spins.position","text":"position.(s::Snapshot)\n\nReturns all the positions of the spin particles as a vector of length-3 vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Spins.position-Tuple{Spin}","page":"API","title":"MCMRSimulator.Spins.position","text":"position(s::Spin)\n\nReturns the position of the spin particle as a vector of length 3.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Spins.stuck-Tuple{Spin}","page":"API","title":"MCMRSimulator.Spins.stuck","text":"stuck(spin)\n\nReturns true if the spin is stuck on the surface. This can be used to filter a Snapshot using:\n\nonly_stuck = filter(stuck, snapshot)\nonly_free = filter(s -> !stuck(s), snapshot)\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Spins.stuck_to-Tuple{Spin, Any}","page":"API","title":"MCMRSimulator.Spins.stuck_to","text":"stuck_to(spin, geometry)\n\nReturn the internal representation of the obstruction the spin is stuck to. Raises an error if the spin is free.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Spins.stuck_to-Tuple{Spin}","page":"API","title":"MCMRSimulator.Spins.stuck_to","text":"stuck_to(spin)\n\nReturn the indices of the obstruction the spin is stuck to. Will return (0, 0) for a free spin.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Spins.transverse","page":"API","title":"MCMRSimulator.Spins.transverse","text":"transverse(spin)\ntransverse(snapshot)\n\nReturns the transverse spin (i.e., magnitude in the plane perpendicular to the magnetic field) for a single particle (Spin) or averaged across a group of particles in a [Snapshot]. When orientations for multiple sequences are available an array of transverse values is returned with a value for each sequence.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Sequences.Methods","page":"API","title":"MCMRSimulator.Sequences.Methods","text":"Defines shared methods in the Sequence sub-module.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Sequences.Methods.add_TR","page":"API","title":"MCMRSimulator.Sequences.Methods.add_TR","text":"add_TR(shape/gradient/rf_pulse, TR)\n\nShifts the generic Shape, MRGradients, or RFPulse by a time TR.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Sequences.Methods.end_time","page":"API","title":"MCMRSimulator.Sequences.Methods.end_time","text":"end_time(gradient/pulse)\n\nFind the time that the MR gradient or pulse ends. For instantaneous gradients/pulses this will also be start_time.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Sequences.Methods.start_time","page":"API","title":"MCMRSimulator.Sequences.Methods.start_time","text":"start_time(gradient/pulse)\n\nFind the time that the MR gradient or pulse starts. For instantaneous gradients/pulses this will also be end_time.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Sequences.Instants.InstantGradient","page":"API","title":"MCMRSimulator.Sequences.Instants.InstantGradient","text":"InstantGradient(; qvec=[0, 0, 0], q_origin=0, origin=[0, 0, 0], time=0., apply_bvec=false)\n\nInfinitely short gradient pulse that encodes phase information given by qvec (units: rad/um) and q_origin (units: rad) or origin (units: um).\n\nThe number of time a spins at given position is rotated is given by qvec ⋅ position + q_origin or qvec ⋅ (position - origin).\n\nThe pulse is applied at given time (in milliseconds). Retrieve this time using get_time.\n\nIf apply_bvec is set to true, the gradients will be rotated with the user-provided bvecs file (using rotate_bvec). This should be true for diffusion-weighted gradients, but will typically be false for crusher gradients.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Sequences.Instants.InstantRFPulse","page":"API","title":"MCMRSimulator.Sequences.Instants.InstantRFPulse","text":"InstantRFPulse(;time=0., flip_angle=0., phase=0.)\n\nInstantaneous radio-frequency pulse that flips the spins by flip_angle degrees in a plane perpendicular to an axis in the x-y plane with an angle of phase degrees with respect to the x-axis at given time. Angles are in degrees and the time is in milliseconds. Angles can be retrieved using flip_angle and phase. Time can be retrieved using get_time.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Sequences.Instants.Readout","page":"API","title":"MCMRSimulator.Sequences.Instants.Readout","text":"Readout(;time=0)\n\nReadout the spins at the given time (in milliseconds) each TR\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Sequences.Instants.apply!-Tuple{InstantRFPulse, SpinOrientation}","page":"API","title":"MCMRSimulator.Sequences.Instants.apply!","text":"apply!(sequence_component, spin_orientation[, position])\n\nApplies given sequence component to the spin orientation. This updates the existing spin orientation. Some pulses (e.g., InstantGradient) require positional information as well.\n\napply!(sequence_components, spin)\napply!(sequence_components, snapshot)\n\nApply all sequence components to the spin orientation in the Spin or to all the spins in Snapshot. Sequence components (see Sequence) can be nothing if there is no sequence component at this time.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Instants.flip_angle-Tuple{InstantRFPulse}","page":"API","title":"MCMRSimulator.Sequences.Instants.flip_angle","text":"flip_angle(instant_pulse)\n\nReturns the flip angle of the InstantRFPulse in degrees.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Instants.phase-Tuple{InstantRFPulse}","page":"API","title":"MCMRSimulator.Sequences.Instants.phase","text":"phase(instant_pulse)\n\nReturns the angle in the x-y plane of the axis around with the InstantRFPulse rotates in degrees.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Shapes.Shape","page":"API","title":"MCMRSimulator.Sequences.Shapes.Shape","text":"Shape(times, amplitudes; normalise=false)\n\nDefines a Shape profile for an RF pulse or gradient profile. The Shape is parametrised by the number of control points N and the type of the amplitude object T. This amplitude type will be Float64 for the amplitude and phase of the RFPulse. It will be SVector{3, Float64} for MRGradients.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Sequences.Shapes.ShapePart","page":"API","title":"MCMRSimulator.Sequences.Shapes.ShapePart","text":"ShapePart(shape, t0, t1)\n\nRepresents a small part of a Shape between t0 and t1 during which the amplitude varies linearly. This object is used to store the relevant part of the RF and gradient profiles within a single timestep (see SequencePart).\n\nLike the full shape values can be extracted using sample, sample_derivative, sample_integral. The time passed on to these functions should be between 0 (for t0) and 1 (for t1).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Sequences.Shapes.sample-Tuple{MCMRSimulator.Sequences.Shapes.Shape, Number, Number}","page":"API","title":"MCMRSimulator.Sequences.Shapes.sample","text":"sample(shape, t1, t2)\n\nReturns the average value of the shape between t1 and t2.  See sample_integral to get the full integral.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Shapes.sample-Union{Tuple{T}, Tuple{MCMRSimulator.Sequences.Shapes.Shape{T}, Number}} where T","page":"API","title":"MCMRSimulator.Sequences.Shapes.sample","text":"sample(shape, time)\n\nReturns the value of the shape at a given time using linear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Shapes.sample_derivative-Union{Tuple{T}, Tuple{MCMRSimulator.Sequences.Shapes.Shape{T}, Number}} where T","page":"API","title":"MCMRSimulator.Sequences.Shapes.sample_derivative","text":"sample_derivative(shape, time[, later_time])\n\nReturns the derivative of the shape value at the specific time. At control points the derivative is always assumed to be the slope of the next block.\n\nIf later_time is provided the average derivative between both timepoints is computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Shapes.sample_integral-Union{Tuple{MCMRSimulator.Sequences.Shapes.Shape{T}}, Tuple{T}, Tuple{MCMRSimulator.Sequences.Shapes.Shape{T}, Number}, Tuple{MCMRSimulator.Sequences.Shapes.Shape{T}, Number, Number}} where T","page":"API","title":"MCMRSimulator.Sequences.Shapes.sample_integral","text":"sample_integral(shape, t0, t1)\n\nIntegrate the shape value from t0 to t1.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Shapes.sample_integral-Union{Tuple{T}, Tuple{MCMRSimulator.Sequences.Shapes.Shape, T, AbstractVector{T}}} where T<:Number","page":"API","title":"MCMRSimulator.Sequences.Shapes.sample_integral","text":"sample_integral(shape, t0, times)\n\nIntegrate the shape value from t0 to all the times in times (all assumed to be larger than t0 and strictly increasing).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Shapes.sample_integral_step","page":"API","title":"MCMRSimulator.Sequences.Shapes.sample_integral_step","text":"sample_integral_step(shape, index, t0=`start of block`, t1=`end of block`)\n\nIntegrate the shape value from t0 to t1 assuming that both are within the single step (given by index). This is a helper function for sample_integral.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Sequences.Gradients.MRGradients","page":"API","title":"MCMRSimulator.Sequences.Gradients.MRGradients","text":"MRGradients(times, amplitudes; origin=[0, 0, 0], apply_bvec=false)\nMRGradients([(time0, amplitude0), (time1, amplitude1), ...]; origin=[0, 0, 0], apply_bvec=false)\n\nDefines a gradient profile with the gradients (unit: kHz/um) linearly interpolated between the given times (unit: ms). Amplitudes can be a 3D vector or a single value. In the latter case the gradients are assumed to point in the x-direction (can be rotated later using rotate_bvec if apply_bvec is set to true). The gradients are centered on given origin (unit: um). They can be sampled using gradient.\n\nIf apply_bvec is set to true, the gradients will be rotated with the user-provided bvecs file (using rotate_bvec). This should be true for diffusion-weighted gradients, but false for slice-selective, crusher, or readout gradients.\n\nMRGradients(Gx, Gy, Gz; origin=[0, 0, 0], apply_bvec=false)\n\nBuilds the MR gradients out of 3 Shape objects each describing the gradient profile in 1 dimension.\n\nAn instantaneous version of MRI gradients is available as InstantGradient.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Sequences.Gradients.gradient-Tuple{MRGradients, Number}","page":"API","title":"MCMRSimulator.Sequences.Gradients.gradient","text":"gradient([position, ]sequence/grad, time)\ngradient([position, ]sequence/grad, t1, t2)\n\nGet gradient strength generated by grad (MRGradients object) at a specific time or averaged over a period between t1 and t2. If no position is provided, the gradient is returned as a length-3 vector in units of mT/m. If a position is provided, the gradient is returned at that position as a float quantifying the off-resonance field in units of microTesla.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Instants.rotate_bvec-Tuple{MRGradients, Any}","page":"API","title":"MCMRSimulator.Sequences.Instants.rotate_bvec","text":"rotate_bvec(gradients, bvec)\n\nRotates the gradients in gradients by bvec. When rotate_bvec is called directly on an MRGradients or InstantGradient object the rotation is applied, whether apply_bvec is true or not.\n\nbvec can be a full rotation matrix or a vector. In the latter case the x-axis of the gradients will be rotated to the vector using a minimal rotation (see get_rotation).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.RadioFrequency.RFPulse","page":"API","title":"MCMRSimulator.Sequences.RadioFrequency.RFPulse","text":"RFPulse(times, amplitudes[, phases]; phase0=0, off_resonance=0)\n\nCreates a radio-frequency block between times t0 and t1. At time t0 the phase of the transverse B1 magnetic field is equal to phase0 (given in degrees).\n\nThe amplitude and frequency modulation profile of the RF pulse are provided as functions:\n\nThe amplitude represents the strength of the magnetic field in kHz within the transverse plane as a function of time (between t0 and t1). This should always be positive.\nThe phase represents the offset from the Larmor frequency in degrees as a function of time (between t0 and t1). If not provided explicitly, the phase is presumed to be a linear function starting with an initial phase0 (in degrees) and increasing by the off_resonance (in kHz).\n\nThe functions amplitude, phase, and off_resonance are used to get the value at a specific t or averaged between two times. flip_angle computes the total flip angle for particles perfectly in phase with the RF pulse.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Methods.off_resonance-Tuple{RFPulse, Vararg{Any}}","page":"API","title":"MCMRSimulator.Methods.off_resonance","text":"off_resonance(rf_pulse, t1[, t2])\n\nComputes the offresonance of the RFPulse at time t1 in kHz. If t2 is also provided, the average offresonance between times t1 and t2 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Methods.phase-Tuple{RFPulse, Vararg{Any}}","page":"API","title":"MCMRSimulator.Methods.phase","text":"phase(rf_pulse, t1[, t2])\n\nComputes the phase of the RFPulse at time t1 in degrees. If t2 is also provided, the average phase between times t1 and t2 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Instants.flip_angle-Tuple{RFPulse}","page":"API","title":"MCMRSimulator.Sequences.Instants.flip_angle","text":"flip_angle(pulse)\n\nComputes the total flip angle of a RFPulse for spins that are in phase with the pulse.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.RadioFrequency.amplitude-Tuple{RFPulse, Vararg{Any}}","page":"API","title":"MCMRSimulator.Sequences.RadioFrequency.amplitude","text":"amplitude(rf_pulse, t1[, t2])\n\nComputes the amplitude of the RFPulse at time t1 in kHz. If t2 is also provided, the average amplitude between times t1 and t2 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.RadioFrequency.constant_pulse-Tuple{Number, Number, Number}","page":"API","title":"MCMRSimulator.Sequences.RadioFrequency.constant_pulse","text":"constant_pulse([t0=0, ]t1, flip_angle; phase0=0., off_resonance=0.)\n\nCreates an RF pulse with a constant amplitude resulting in given flip_angle (for spins at off_resonance).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.RadioFrequency.effective_pulse-Tuple{RFPulse, Number, Number}","page":"API","title":"MCMRSimulator.Sequences.RadioFrequency.effective_pulse","text":"effective_pulse(RFPulse, t0, t1)\neffective_pulse(sequence, t0, t1)\n\nRepresents the effect of the RF pulse between times t0 and t1 as an InstantRFPulse.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Main.Sequence","page":"API","title":"MCMRSimulator.Sequences.Main.Sequence","text":"Sequence(;TR, components=[], scanner=Scanner(B0), B0=3.)\n\nAn MR sequence represented by a series of components repeated with a given repetition time (TR).\n\nPossible sequence components are:\n\nRFPulse: Radio-frequency pulse with user-provided amplitude and phase profile.\nInstantRFPulse: instantaneous approximation of a radio-frequency pulse flipping the spin orientations.\nMRGradients: MRI gradient profiles\nInstantGradient: instantaneous gradients encoding spatial patterns in the spin phase distribution.\nReadout: Store the spins at this timepoint.\n\nThe previous/current/next [RFPulse] at a specific time is given by previous_pulse, current_pulse, or next_pulse.  Equivalent functions are available to [MRGradients] called previous_gradient, current_gradient, or next_gradient. All of these will return nothing if there is no previous/current/next gradient/RF pulse.\n\nThe same functions exist for the previous/current/next instantaneous gradient/RF pulse (i.e., InstantRFPulse or InstantGradient), namely previous_instant, current_instant, or next_instant. \n\nNote that all gradients/pulses repeat every TR milliseconds.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Sequences.Main.SequencePart","page":"API","title":"MCMRSimulator.Sequences.Main.SequencePart","text":"SequencePart(sequence, t1, t2)\n\nRepresents a small part of a Sequence between times t1 and t2. During this time the RF pulse and gradients are assumed to change linearly and hence can be represented as ShapePart objects. This is used to guide the spin evolution during the timestep between times t1 and t2 in the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Sequences.Gradients.gradient-Tuple{AbstractVector, Sequence, Number}","page":"API","title":"MCMRSimulator.Sequences.Gradients.gradient","text":"gradient([position, ], sequence, t1)\n\nGets the off-resonance field (units: kHz) at given position at time t1. If position is not supplied the MR gradient is returned as a vector (units: kHz/um).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Instants.rotate_bvec-Union{Tuple{G}, Tuple{R}, Tuple{P}, Tuple{I}, Tuple{Sequence{I, P, R, G}, Any}} where {I, P, R, G}","page":"API","title":"MCMRSimulator.Sequences.Instants.rotate_bvec","text":"rotate_bvec(sequence, bvec)\n\nRotates diffusion-weighting gradients in sequence by bvec. The rotation is only applied to MRGradients and InstantGradient objects in the sequence for which apply_bvec is true. This should include any diffusion-weighted gradients, but not slice-selection, crusher, or readout gradients.\n\nbvec can be a full rotation matrix or a vector. In the latter case the x-axis of the gradients will be rotated to the vector using a minimal rotation (see get_rotation).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Main.can_rotate_bvec-Tuple{Sequence}","page":"API","title":"MCMRSimulator.Sequences.Main.can_rotate_bvec","text":"can_rotate_bvec(sequence)\n\nChecks whether rotate_bvec will have any effect on the sequence (i.e., apply_bvec has been set to true for any non-zero gradients in the sequence).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Main.current_gradient-Tuple{Any, Any}","page":"API","title":"MCMRSimulator.Sequences.Main.current_gradient","text":"current_gradient(sequence, time)\n\nReturns the current MRGradients in the Sequence relative to time. If there is no current gradient nothing is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Main.current_instant-Tuple{Any, Any}","page":"API","title":"MCMRSimulator.Sequences.Main.current_instant","text":"current_instant(sequence, time)\n\nReturns the current InstantGradient or InstantRFPulse in the Sequence relative to time. If there is no current instant nothing is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Main.current_pulse-Tuple{Any, Any}","page":"API","title":"MCMRSimulator.Sequences.Main.current_pulse","text":"current_pulse(sequence, time)\n\nReturns the current RFPulse in the Sequence relative to time. If there is no current pulse nothing is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Main.next_gradient-Tuple{Any, Any}","page":"API","title":"MCMRSimulator.Sequences.Main.next_gradient","text":"next_gradient(sequence, time)\n\nReturns the next MRGradients in the Sequence relative to time. If there is no next gradient nothing is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Main.next_instant-Tuple{Any, Any}","page":"API","title":"MCMRSimulator.Sequences.Main.next_instant","text":"next_instant(sequence, time)\n\nReturns the next InstantGradient or InstantRFPulse in the Sequence relative to time. If there is no next instant nothing is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Main.next_pulse-Tuple{Any, Any}","page":"API","title":"MCMRSimulator.Sequences.Main.next_pulse","text":"next_pulse(sequence, time)\n\nReturns the next RFPulse in the Sequence relative to time. If there is no next pulse nothing is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Main.previous_gradient-Tuple{Any, Any}","page":"API","title":"MCMRSimulator.Sequences.Main.previous_gradient","text":"previous_gradient(sequence, time)\n\nReturns the previous MRGradients in the Sequence relative to time. If there is no previous gradient nothing is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Main.previous_instant-Tuple{Any, Any}","page":"API","title":"MCMRSimulator.Sequences.Main.previous_instant","text":"previous_instant(sequence, time)\n\nReturns the previous InstantGradient or InstantRFPulse in the Sequence relative to time. If there is no previous instant nothing is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Main.previous_pulse-Tuple{Any, Any}","page":"API","title":"MCMRSimulator.Sequences.Main.previous_pulse","text":"previous_pulse(sequence, time)\n\nReturns the previous RFPulse in the Sequence relative to time. If there is no previous pulse nothing is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.RadioFrequency.effective_pulse-Tuple{Sequence, Number, Number}","page":"API","title":"MCMRSimulator.Sequences.RadioFrequency.effective_pulse","text":"effective_pulse(sequence, t1, t2)\n\nReturns the InstantRFPulse that has the same effect as the radio-frequency pulses (RFPulse) in the provided sequence will have between t1 and t2.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.Shapes.Shape-Tuple{MCMRSimulator.Sequences.PulseQ.CompressedPulseqShape}","page":"API","title":"MCMRSimulator.Sequences.Shapes.Shape","text":"Shape(shape::CompressedPulseqShape)\n\nCreate a Shape object based on the pulseq Shape format.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.PulseQ.read_pulseq-Tuple{Any}","page":"API","title":"MCMRSimulator.Sequences.PulseQ.read_pulseq","text":"read_pulseq(filename; scanner=Scanner(B0=B0), B0=3., TR=<sequence duration>)\n\nReads a sequence from a pulseq file (http://pulseq.github.io/). Pulseq files can be produced using matlab (http://pulseq.github.io/) or python (https://pypulseq.readthedocs.io/en/master/).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.JSON","page":"API","title":"MCMRSimulator.Sequences.JSON","text":"I/O for sequences using JSON format\n\nFunctions:\n\nwrite_sequence\nread_sequence\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Sequences.JSON.read_sequence-Tuple{IO}","page":"API","title":"MCMRSimulator.Sequences.JSON.read_sequence","text":"read_sequence(filename/io)\n\nRead sequence from a JSON file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Sequences.JSON.write_sequence-Tuple{Any}","page":"API","title":"MCMRSimulator.Sequences.JSON.write_sequence","text":"write_sequence([io, ]sequence)\n\nWrites the sequence as a JSON file. If no IO is provided, the sequence is written to stdout.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.SequenceBuilder.BuildingBlocks.BuildingBlock","page":"API","title":"MCMRSimulator.SequenceBuilder.BuildingBlocks.BuildingBlock","text":"BuildingBlock(; components=vector of pulses/gradients, duration=minimum)\n\nCreates a sequence building block by overlapping zero or more pulses/gradients.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.SequenceBuilder.BuildingBlocks.BuildingBlock-Tuple{AbstractVector}","page":"API","title":"MCMRSimulator.SequenceBuilder.BuildingBlocks.BuildingBlock","text":"BuildingBlock([building block like objects...])\n\nCreates a sequence building block by concatenating all the BuildingBlock-like objects in the vector. Each building block will play out sequenctially.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.SequenceBuilder.BuildingBlocks.BuildingBlock-Tuple{Number}","page":"API","title":"MCMRSimulator.SequenceBuilder.BuildingBlocks.BuildingBlock","text":"BuildingBlock(delay::Number)\n\nCreates an empty sequence building block representing a delay of delay ms.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.SequenceBuilder.BuildingBlocks.BuildingBlock-Tuple{Union{Readout, MRGradients, MCMRSimulator.Sequences.Instants.InstantComponent, RFPulse}}","page":"API","title":"MCMRSimulator.SequenceBuilder.BuildingBlocks.BuildingBlock","text":"BuildingBlock(pulse/gradient)\n\nCreates an building block containing just the RFPulse, InstantRFPulse, MRGradients, InstantGradient, or [Readout]. The duration will be set to the length of the pulse/gradient.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.SequenceBuilder.BuildingBlocks.duration-Tuple{AbstractVector}","page":"API","title":"MCMRSimulator.SequenceBuilder.BuildingBlocks.duration","text":"duration(building_block)\n\nReturns how long each sequence BuildingBlock lasts.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.SequenceBuilder.BuildingBlocks.isempty_block-Tuple{AbstractVector}","page":"API","title":"MCMRSimulator.SequenceBuilder.BuildingBlocks.isempty_block","text":"isempty_block(building_block)\n\nReturns whether a sequence BuildingBlock is empty (i.e., does not contain RF pulses, readouts or MRI gradients).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.SequenceBuilder.Diffusion.add_linear_diffusion_weighting-Tuple{Any, Any, Any}","page":"API","title":"MCMRSimulator.SequenceBuilder.Diffusion.add_linear_diffusion_weighting","text":"add_linear_diffusion_weighting(blocks, replace1, replace2, refocus=true, bval/qval/gradient_strength, diffusion_time=max, gradient_duration=max, scanner=3T, orientation=:x)\n\nReplaces two empty BuildingBlock-like objects with diffusion-weighting gradients. Both diffusion-weighted gradients are identical trapezia. The second one will be flipped if refocus is set to false.\n\nThe other flags control the timings and size of the diffusion weighting. The timings are determined by:\n\ndiffusion_time: defaults to time between the start of the two blocks\ngradient_duration: defaults to the largest value possible. Setting the gradient_duration to zero will cause [InstantGradient] objects to be used.\nramp_time: defaults to the maximum gradient / maximum slew rate of the scanner.\n\nThe gradient strength is set by bval (ms/um^2), qval (rad/um), or gradient_strength (kHz/um). At least one of these should be provided.\n\nBy default, the timings of the existing BuildingBlock objects are respected. If max_bval or max_qval are set these timings are adjusted to the minimum duration required to reach that b-value or q-value.\n\nIf the gradient orientation is not set during construction, it can be later applied using rotate_bvec.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.SequenceBuilder.Diffusion.fit_time-NTuple{6, Any}","page":"API","title":"MCMRSimulator.SequenceBuilder.Diffusion.fit_time","text":"fit_time(duration1, duration_wait, duration2, gradient_duration, diffusion_time, ramp_time)\n\nArranges the timing of gradients given the duration of gradient, diffusion time, ramp time, readout time and TE. By default it will try to arrange to gradients symmetrically arround the 180 degree pulse. If not feasible, it will make readout right after the rephasing gradient and calculate the dephasing gradient's timing based on the rephasing gradient.\n\nThis function is not supposed to be called individually! So no check for the arguments will happen, assuming all have been checked by get_diffusion_trapeziums and all will not be nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.SequenceBuilder.Diffusion.gen_crusher-Tuple{}","page":"API","title":"MCMRSimulator.SequenceBuilder.Diffusion.gen_crusher","text":"gen_crusher(qval=<maximum>, duration=<minimum>, scanner=<scanner with infinite gradients>)\n\nGenerate a crusher gradient with the user-defined q-value (rad/um) and duration (ms). If not provided, the q-value will be as large as possible, while the duration will be as small as possible given the constraints of the scanner (might be 0 for infinitely strong scanners). For scanners with infinitely strong gradients (default) or durations of 0 ms, the q-value is set to 1 rad/um.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.SequenceBuilder.Diffusion.trapezium_gradient-Tuple{}","page":"API","title":"MCMRSimulator.SequenceBuilder.Diffusion.trapezium_gradient","text":"trapezium_gradient(; qval, total_duration, δ, gradient_strength, ramp_time, scanner, origin, apply_bvec, orientation)\n\nDefines a MRI gradient shaped like a trapezium.\n\nThe resulting trapezium will obey the following properties:\n\ntotalduration = δ + ramptime\nqval = δ * gradient_strength\ngradientstrength < maxgradient(scanner)\ngradientstrength / ramptime < maxslewrate(scanner)\n\nIf the timings (total_duration or δ) are set, but the qval is not, then the qval will be the maximum possible within the gradient duration. If the qval is set, but the timings are not, then the gradient duration is minimised. In both cases the gradient_strength will be the maximum allowed by the scanner (if not explicitly set).\n\nIf the ramp_time is not explicitly set, it will be set to the slew rate over the gradient strength.\n\nAn InstantGradient is returned if δ or total_duration is set to zero (rather than an MRGradients)\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.SequenceBuilder.Sequences.GradientEcho.gradient_echo-Tuple{Any}","page":"API","title":"MCMRSimulator.SequenceBuilder.Sequences.GradientEcho.gradient_echo","text":"gradient_echo(TE; TR=<TE>, scanner=<3T scanner>, excitation_pulse=Instant, excitation_time=<half pulse duration>, readout_time=0, crusher=0.)\n\nCreates a gradient echo sequence consisting of:\n\nexcitation_pulse: by default this is an InstantRFPulse, but can be replaced with an RFPulse. If the excitation does not take place halfway the RF pulse, excitation_time should be set as well.\na delay\na readout TE ms after the excitation.\na delay of readout_time/2\ncrusher gradient (default: instant with q-value of 1 rad/um). Set crusher to a positive number to change the duration or to any MR gradient (see gen_crusher).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.SequenceBuilder.Sequences.SpinEcho.dwi-Tuple{}","page":"API","title":"MCMRSimulator.SequenceBuilder.Sequences.SpinEcho.dwi","text":"dwi(; \n    TE=80., TR=<TE>, scanner=<3T scanner>, \n    excitation_pulse=Instant, excitation_time=<half pulse duration>, \n    refocus_pulse=Instant, refocus_time=<half pulse duration>,\n    readout_time=0, diffusion_time=<maximum>, gradient_duration=<maximum>,\n    bval/qval/gradient_strength=<one is required>, orientation=:x,\n    )\n\nCreates a gradient echo sequence consisting of:\n\nexcitation_pulse: by default this is an InstantRFPulse, but can be replaced with an RFPulse. If the excitation does not take place halfway the RF pulse, excitation_time should be set as well.\ndiffusion weighting\nrefocus_pulse: by default this is an InstantRFPulse, but can be replaced with an RFPulse. If the refocus does not take place halfway the RF pulse, refocus_time should be set as well.\nidentical diffusion weighting cancelling out the first one\na readout TE ms after the excitation.\n\nThe refocus time is always halfway the excitation time and the readout.\n\nThe timings of the RF pulses is set by TE and TR. The gradient timings will also be affected by gradient_duration, diffusion_time, scanner (which sets the ramp time) and readout_time:\n\nBy default the gradient durations are set to the maximum value possible within the echo time (TE) keeping in mind the time needed for the MR readout (readout_time) and the time needed to ramp to the maximum gradient strength (set by the scanner).\nWhen gradientduration is set to 0, the gradient pulses are assumed to be instanteneous (i.e., using InstantGradient). The time between these instant gradients can be set using diffusiontime (defaults to TE/2).\n\nThe strength of the diffusion gradients is set by one of bval (units: ms/um^2), qval (units: 1/um), or gradient_strength (units: kHz/um). If the resulting gradient strength exceeds the maximum allowed for the scanner an AssertionError is raised. \n\nThe gradient orientation is set by orientation.  If the gradient orientation is not set during construction, it can be later applied using rotate_bvec.\n\nFor more details of how the diffusion weighting is inserted in the spin_echo sequence, see add_linear_diffusion_weighting.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.SequenceBuilder.Sequences.SpinEcho.spin_echo-Tuple{Any}","page":"API","title":"MCMRSimulator.SequenceBuilder.Sequences.SpinEcho.spin_echo","text":"spin_echo(TE; TR=<TE>, scanner=<3T scanner>, excitation_pulse=Instant, excitation_time=<half pulse duration>, refocus_pulse=Instant, refocus_time=<half pulse duration>)\n\nCreates a gradient echo sequence consisting of:\n\nexcitation_pulse: by default this is an InstantRFPulse, but can be replaced with an RFPulse. If the excitation does not take place halfway the RF pulse, excitation_time should be set as well.\na delay\nrefocus_pulse: by default this is an InstantRFPulse, but can be replaced with an RFPulse. If the refocus does not take place halfway the RF pulse, refocus_time should be set as well.\na readout TE ms after the excitation.\na delay of readout_time/2\ncrusher gradient (default: instant with q-value of 1 rad/um). Set crusher to a positive number to change the duration or to any MR gradient (see gen_crusher).\n\nThe refocus time is always halfway the excitation time and the readout.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Timestep.TimeController","page":"API","title":"MCMRSimulator.Timestep.TimeController","text":"TimeController(geometry, B0, diffusivity; max_stepsize=<see docs>, gradient_precision=1, rf_rotation=1)\n\nStores the settings controlling the maximum timestep during the simulation, namely:\n\nmax_timestep: Generic maximum timestep that is considered throughout the simulation. By default this is set by the minimum of the following three options:\nDelta t_1 = l^2(2 D), where l is the size_scale of the geometry, and D is the diffusivity.\nDelta t_2 = D^-13 (360 * G)^-23  p, where p is the gradient_precision, and G is the maximum off-resonance gradient due to the geometry (see off_resonance_gradient).\nThe timestep required to keep the probability of the spins getting stuck on the surface at a collision below 1.\ngradient_precision: maximum error in the phase that a spin should incur while a gradient is active in any of the sequences (units: degrees).    If max_stepsize is not set by the user, it is also applied to any geometry-applied gradients (see point 2 above).\nrf_rotation: Maximum amount of rotation that an RF pulse should be able to apply in a single timestep (units: degrees).   This constraint is only active if there is an RF pulse active in any of the sequences.\n\nMore details about how these settings are used can be found in propose_times.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Timestep.propose_times-Tuple{TimeController, Number, Number, AbstractVector{<:Sequence}, Number}","page":"API","title":"MCMRSimulator.Timestep.propose_times","text":"propose_times(simulation, t_start, t_end)\npropose_times(time_controller, t_start, t_end, sequences, diffusivity)\n\nComputes the timepoints at which the simulation will be evaluated when running from t_start to t_end.\n\nThe following timepoints will always be included\n\nAny multiple of the TR\nAny RF pulse\nAny change in the gradient strength\n\nAdditional timepoints will be added to ensure that at any step the timestep is lower than the maximum timestep as described in TimeController:\n\nthe timestep needed to displace with the simulation.time_controller.max_stepsize.\nat any time the timestep is larger than D^-13 (360 * G gamma)^-23  p, where p is the simulation.time_controller.gradient_precision (given in degrees).   The gradient G is the maximum of the user-applied gradient or the maximum off-resonance field gradient.\nDuring an RFPulse the rotation around the maximum magnetic field will be at most simulation.time_controller.rf_rotation degrees. \n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Relax.relax!-Tuple{SpinOrientation, Real, Any, Any, Any}","page":"API","title":"MCMRSimulator.Relax.relax!","text":"relax!(spin_orientation, timestep, mri, additional_off_resonance=0)\n\nUpdates [SpinOrientation] after evolving for timestep with given R1 (1/ms), R2 (1/ms), and off_resonance (kHz).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Relax.transfer!-Tuple{SpinOrientation, Float64}","page":"API","title":"MCMRSimulator.Relax.transfer!","text":"transfer!(orientation, MT_fraction)\n\nLoses MT_fraction spin from orientation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Simulations.Simulation","page":"API","title":"MCMRSimulator.Simulations.Simulation","text":"Simulation(\n    sequences; geometry=[], diffusivity=0.,\n    R1=0, T1=Inf, R2=0, T2=Inf, off_resonance=0, MT_fraction=0, permeability=0,, \n    max_timestep=<geometry-based default>, gradient_precision=1, rf_rotation=1.,\n)\n\nDefines the setup of the simulation and stores the output of the run.\n\nArgument\n\nGeneral parameters:\n\nsequences: Vector of Sequence objects. During the spin random walk the simulation will keep track of the spin magnetisations for all of the provided sequences.\ngeometry: Set of obstructions, which can be used to restrict the diffusion, produce off-resonance fields, alter the local T1/T2 relaxation, and as sources of magnetisation transfer.\ndiffusivity: Rate of the random motion of the spins in um^2/ms.\n\nMRI properties\n\nThese parameters determine the evolution and relaxation of the spin magnetisation.\n\nR1/T1: sets the longitudinal relaxation rate (R1 in kHz) or relaxation time (T1=1/R1 in ms). This determines how fast the longitudinal magnetisation returns to its equilibrium value of 1.\nR2/T2: sets the transverse relaxation rate (R2 in kHz) or relaxation time (T2=1/R2 in ms). This determines how fast the transverse magnetisation is lost.\noff_resonance: Size of the off-resonance field in this voxel in kHz.\n\nThese MRI properties can be overriden for spins inside the ObstructionGroup objects of the geoemtry.\n\nCollision parameters\n\nThese parameters determine how parameters behave when hitting the ObstructionGroup objects of the geoemtry. They can be overriden for individual objects for each [ObstructionGroup].\n\nMT_fraction: the fraction of magnetisation transfered between the obstruction and the water spin at each collision.\npermeability: the probability that the spin will pass through the obstruction.\nsurface_density: Density of spins stuck on the surface relative to the volume density of hte free water.\ndwell_time: Typical time that spins will stay at the surface after getting stuck.\n\nNote that MT_fraction and permeability are internally adjusted to make their effect independent of the timestep (see correct_for_timestep).\n\nTimestep parameters\n\nThese parameters (max_timestep, gradient_precision, and rf_rotation) control the timepoints at which the simulation is evaluated. The default values should work well. For more details on how to adjust them, see TimeController.\n\nRunning the simulation\n\nTo run a Snapshot of spins through the simulations you can use one of the following functions:\n\nevolve: evolves the spins in the snapshot until a single given time and returns that state in a new Snapshot.\nreadout: evolves the spins to particular times in each TR and return the total signal at that time (or a Snapshot).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Subsets","page":"API","title":"MCMRSimulator.Subsets","text":"Support for selecting a subset of the total signal.\n\nTypes:\n\nSubset\n\nFunctions:\n\nget_subset\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Subsets.Subset","page":"API","title":"MCMRSimulator.Subsets.Subset","text":"Subset(; bound=nothing, inside=nothing, geometry_index=nothing, obstruction_index=nothing)\n\nThis creates a helper object to extract a subset of a Snapshot from the total snapshot. It defines which spins should be kept. This definition is determined by:\n\nbound: set to true to return only bound spins, to false to return only free spins (default: whether spins are bound is not relevant).\ninside: set to true to return only spins inside the geometry, to false to return only spins outside of the geometry (default: whether spins are inside or outside is not relevant).\ngeometry_index: set to an index to only consider that obstruction group within the total geometry (default: consider the full geometry).\nobstruction_index: set to an index to only consider that obstruction group within the total geometry (default: consider the full geometry).\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Subsets.get_subset-Tuple{Snapshot, Union{Tuple{Vararg{MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup, N}} where N, Simulation}}","page":"API","title":"MCMRSimulator.Subsets.get_subset","text":"get_subset(snapshot, simulation, subset)\nget_subset(snapshot, simulation; bound=nothing, inside=nothing, geometry_index=nothing, obstruction_index=nothing)\n\nReturns a subset of the Snapshot from the Simulation that obey some specific properties. These properties can be either defined by a Subset object or a set of keyword arguments.\n\nThese keyword arguments are:\n\nbound: set to true to return only bound spins, to false to return only free spins (default: whether spins are bound is not relevant).\ninside: set to true to return only spins inside the geometry, to false to return only spins outside of the geometry (default: whether spins are inside or outside is not relevant).\ngeometry_index: set to an index to only consider that obstruction group within the total geometry (default: consider the full geometry).\nobstruction_index: set to an index to only consider that obstruction group within the total geometry (default: consider the full geometry).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Evolve","page":"API","title":"MCMRSimulator.Evolve","text":"Defines the functions that run the actual simulation:\n\nreadout: get total signal or Snapshot at any Readout objects in the sequences.\nevolve: Return a single Snapshot with the state of the simulation at a given time. This snapshot can be used as initialisation for further runs.\n\nAll of these functions call evolve_to_time under the hood to actually run the simulation.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.Evolve.draw_step!-Union{Tuple{N}, Tuple{Spin{N}, Simulation{N, 0, G} where G<:Tuple{}, StaticArraysCore.SVector{N, MCMRSimulator.Sequences.Main.SequencePart}, Float64}} where N","page":"API","title":"MCMRSimulator.Evolve.draw_step!","text":"draw_step!(spin, simulation, sequence_parts, timestep)\n\nUpdates the spin based on a random movement through the given geometry for a given timestep:\n\ndraws the next location of the particle after timestep with given simulation.diffusivity.   This displacement will take into account the obstructions in simulation.geometry.\nThe spin orientation will be affected by relaxation (see relax!) and potentially by magnetisation transfer during collisions.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Evolve.evolve-Union{Tuple{N}, Tuple{Any, Simulation{N, NG} where NG}, Tuple{Any, Simulation{N, NG} where NG, Any}} where N","page":"API","title":"MCMRSimulator.Evolve.evolve","text":"evolve(snapshot, simulation[, new_time]; bounding_box=<1x1x1 mm box>)\n\nEvolves the Snapshot through the Simulation to a new time. Returns a Snapshot at the new time, which can be used as a basis for further simulation. If undefined new_time will be set to the start of the next TR.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Evolve.evolve_to_time-Union{Tuple{N}, Tuple{Snapshot{N}, Simulation{N, NG} where NG, Float64}} where N","page":"API","title":"MCMRSimulator.Evolve.evolve_to_time","text":"evolve_to_time(snapshot, simulation, new_time)\n\nEvolves the full Snapshot through the Simulation to the given new_time. Multi-threading is used to evolve multiple spins in parallel. This is used internally when calling any of the snapshot evolution methods (e.g., evolve).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Evolve.readout-Union{Tuple{N}, Tuple{Any, Simulation{N, NG} where NG}, Tuple{Any, Simulation{N, NG} where NG, Any}} where N","page":"API","title":"MCMRSimulator.Evolve.readout","text":"readout(spins, simulation[, readout_times]; bounding_box=<1x1x1 mm box>, skip_TR=0, nTR=1, return_snapshot=false, subset=<all>)\n\nEvolves a set of spins through the Simulation. Returns the total signal or a full Snapshot at every readout time in the simulated sequences over one or more repetition times (TRs).\n\nPositional arguments:\n\nspins: Number of spins to simulate or an already existing Snapshot.\nsimulation: Simulation object defining the environment, scanner, and sequence(s).\ntimes (optional): time of the readouts relative to the start of the TR (in ms). If not provided, the times of any Readout objects in the sequence will be used.\n\nKeyword arguments:\n\nbounding_box: size of the voxel in which the spins are initiated in um (default is 1000, corresponding to a 1x1x1 mm box centered on zero). Can be set to a BoundingBox object for more control.\nskip_TR: Number of repetition times to skip before starting the readout.    Even if set to zero (the default), the simulator will still skip the current TR before starting the readout    if the starting snapshot is from a time past one of the sequence readouts.\nnTR: number of TRs for which to store the output\nreturn_snapshot: set to true to output the state of all the spins as a Snapshot at each readout instead of a SpinOrientationSum with the total signal.\nsubset: Return the signal/snapshot for a subset of all spins. Can be set to a single or a vector of Subset objects. If set to a vector, this will add an attional dimension to the output.\n\nReturns\n\nThe function returns an up to 3-dimensional (KxLxMxN) array, with the following dimensions:\n\nK: the number of sequences. This dimension is not included if the simulation only contains a single sequencen (and this single sequence is not passed into the Simulation as a vector).\nL: the number of readout times with a single TR. This dimension is skipped if the readout_times is set to a scalar number. This dimension might contain nothings for sequences that contain fewer Readout objects than the maximum (M).\nM: the number of TRs (controlled by the nTR keyword). If nTR is not explicitly set by the user, this dimension is skipped.\nN: the number of subsets (controlled by the subset keyword). If subset is set to a single value (<all> by default), this dimension is skipped.\n\nBy default each element of this matrix is either a SpinOrientationSum with the total signal. If return_snapshot=true is set, each element is the full Snapshot instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Utils.color-Tuple{Union{Spin{1}, SpinOrientation}}","page":"API","title":"MCMRSimulator.Plot.Utils.color","text":"color(orient::SpinOrientation; saturation=1.)\n\nReturns a color representing the spin orientation in the transverse (x-y) plane. Brighter colors have a larger transverse component, so that spins with no transverse component are black. The actual color encodes the spin orientation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.PlotPlanes.PlotPlane","page":"API","title":"MCMRSimulator.Plot.PlotPlanes.PlotPlane","text":"Defines a finite plane in the 3D space used for plotting.\n\nConstructor\n\nPlotPlane(normal=[0, 0, 1], position=[0, 0, 0]; size=10., sizex=<size>, sizey=<size>, ngrid=100)\n\nArguments:\n\nnormal: length-3 vector with the orientation perpendicular to the plane (default to z-direction).\nposition: position of plane as a length-3 vector (defaults to origin).\nsizex: size of the plane in the x-direction (before rotating to normal).\nsizey: size of the plane in the y-direction (before rotating to normal).\nsize: set default value for sizex and sizey.\nngrid: number of grid elements to split the plane up into for plotting.\n\n\n\n\n\n","category":"type"},{"location":"api/#MCMRSimulator.Plot.PlotPlanes.project_on_grid-Tuple{PlotPlane, Snapshot{1}, Int64}","page":"API","title":"MCMRSimulator.Plot.PlotPlanes.project_on_grid","text":"project_on_grid(plot_plane, snap, ngrid)\n\nSpins from the Snapshot are projected onto the grid defined by PlotPlane in two ways:\n\nalong the normal spins are projected onto the plane from infinitely far (TODO: give finite extent)\nin the other directions any spins are projected onto the plane using mod(position[1], sizex) and mod(position[2], sizey).   This assumes that the geometry and field repeats itself ad infinitum beyond the PlotPlane (TODO: allow this assumption to be turned off).\n\nIn effect, this means that all spins are projected onto the PlotPlane. The average spin orientation in each grid cell is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Sequences.sequence_plot","page":"API","title":"MCMRSimulator.Plot.Sequences.sequence_plot","text":"plot(sequence)\nplot!(sequence)\nplot_sequence(sequence)\nplot_sequence!(sequence)\n\nCreates a visual representation of a Sequence diagram.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Plot.Geometries.plot_geometry!-Tuple","page":"API","title":"MCMRSimulator.Plot.Geometries.plot_geometry!","text":"plot(plot_plane, geometry)\nplot!(plot_plane, geometry)\nplot_geometry(plot_plane, geometry)\nplot_geometry!(plot_plane, geometry)\n\nPlots the intersections of geometry in the PlotPlane.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Geometries.plot_geometry-Tuple","page":"API","title":"MCMRSimulator.Plot.Geometries.plot_geometry","text":"plot(plot_plane, geometry)\nplot!(plot_plane, geometry)\nplot_geometry(plot_plane, geometry)\nplot_geometry!(plot_plane, geometry)\n\nPlots the intersections of geometry in the PlotPlane.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Geometries.project_geometry-Union{Tuple{N}, Tuple{L}, Tuple{PlotPlane, MCMRSimulator.Geometries.Internal.FixedObstructionGroups.FixedObstructionGroup{L, N, R, O, B} where {R, O<:MCMRSimulator.Geometries.Internal.Obstructions.FixedObstructions.FixedObstruction{N}, B<:Union{Nothing, Array{BoundingBox{N}, 1}}}}} where {L, N}","page":"API","title":"MCMRSimulator.Plot.Geometries.project_geometry","text":"project_geometry(plot_plane, transform)\n\nProjects the plane on the intrinsic plane of the obstructions deformed by transform.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.OffResonance.plot_off_resonance!-Tuple","page":"API","title":"MCMRSimulator.Plot.OffResonance.plot_off_resonance!","text":"plot_off_resonance(plot_plane, geometry)\nplot_off_resonance(plot_plane, geometry)\n\nPlots the off-resonance of geometry in the PlotPlane.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.OffResonance.plot_off_resonance-Tuple","page":"API","title":"MCMRSimulator.Plot.OffResonance.plot_off_resonance","text":"plot_off_resonance(plot_plane, geometry)\nplot_off_resonance(plot_plane, geometry)\n\nPlots the off-resonance of geometry in the PlotPlane.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Snapshots.dyad_snapshot!-Tuple","page":"API","title":"MCMRSimulator.Plot.Snapshots.dyad_snapshot!","text":"dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)\n\nPlots the spins in the Snapshot projected onto given PlotPlane as arrows.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Snapshots.dyad_snapshot-Tuple","page":"API","title":"MCMRSimulator.Plot.Snapshots.dyad_snapshot","text":"dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)\n\nPlots the spins in the Snapshot projected onto given PlotPlane as arrows.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Snapshots.image_snapshot!-Tuple","page":"API","title":"MCMRSimulator.Plot.Snapshots.image_snapshot!","text":"image_snapshot(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)\nimage_snapshot!(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)\n\nPlots the spins in the Snapshot projected onto given PlotPlane. The average spin orientation across the plot plane is plotted using the colour coding from color.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Snapshots.image_snapshot-Tuple","page":"API","title":"MCMRSimulator.Plot.Snapshots.image_snapshot","text":"image_snapshot(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)\nimage_snapshot!(plot_plane, snapshot; vectorlength=0.1, arrowsize=0.1, color=:black, sequence=1)\n\nPlots the spins in the Snapshot projected onto given PlotPlane. The average spin orientation across the plot plane is plotted using the colour coding from color.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Snapshots.plot_snapshot","page":"API","title":"MCMRSimulator.Plot.Snapshots.plot_snapshot","text":"plot(plot_plane, snapshot; kwargs...)\nplot!(plot_plane, snapshot; kwargs...)\nplot_snapshot(plot_plane, snapshot; kwargs...)\nplot_snapshot!(plot_plane, snapshot; kwargs...)\n\nPlots the spins in the Snapshot projected onto given PlotPlane. Each spin is represented by an arrow showing the transverse component of the spin (for a total of the first ndyads spins). The average spin orientation across the plot plane is plotted using the colour coding from color.\n\nThis combines the plotting from image_snapshot and dyad_snapshot.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.Plot.Snapshots.scatter_snapshot!-Tuple","page":"API","title":"MCMRSimulator.Plot.Snapshots.scatter_snapshot!","text":"plot(snapshot)\nplot!(snapshot)\nscatter_snapshot(snapshot)\nscatter_snapshot!(snapshot)\n\nPlots the spin positions in the Snapshot in 3D color coded by the spin's orientation (see color).\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Snapshots.scatter_snapshot-Tuple","page":"API","title":"MCMRSimulator.Plot.Snapshots.scatter_snapshot","text":"plot(snapshot)\nplot!(snapshot)\nscatter_snapshot(snapshot)\nscatter_snapshot!(snapshot)\n\nPlots the spin positions in the Snapshot in 3D color coded by the spin's orientation (see color).\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieCore.plot!-Tuple{MakieCore.Combined{MCMRSimulator.Plot.Snapshots.dyad_snapshot}}","page":"API","title":"MakieCore.plot!","text":"dyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)\ndyad_snapshot(plot_plane, snapshot; dyadlength=0.1, arrowsize=0.1, color=:black, sequence=1)\n\nPlots the spins in the Snapshot projected onto given PlotPlane. Each spin is represented by an arrow showing the transverse component of the spin.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Trajectory.plot_trajectory2d!-Tuple","page":"API","title":"MCMRSimulator.Plot.Trajectory.plot_trajectory2d!","text":"plot(snapshots)\nplot!(snapshots)\nplot_trajectory3d(snapshots)\nplot_trajectory3d!(snapshots)\n\nPlots trajectory of the spins in a sequence of Snapshot objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Trajectory.plot_trajectory2d-Tuple","page":"API","title":"MCMRSimulator.Plot.Trajectory.plot_trajectory2d","text":"plot(snapshots)\nplot!(snapshots)\nplot_trajectory3d(snapshots)\nplot_trajectory3d!(snapshots)\n\nPlots trajectory of the spins in a sequence of Snapshot objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Trajectory.plot_trajectory3d!-Tuple","page":"API","title":"MCMRSimulator.Plot.Trajectory.plot_trajectory3d!","text":"plot(snapshots)\nplot!(snapshots)\nplot_trajectory3d(snapshots)\nplot_trajectory3d!(snapshots)\n\nPlots trajectory of the spins in a sequence of Snapshot objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.Plot.Trajectory.plot_trajectory3d-Tuple","page":"API","title":"MCMRSimulator.Plot.Trajectory.plot_trajectory3d","text":"plot(snapshots)\nplot!(snapshots)\nplot_trajectory3d(snapshots)\nplot_trajectory3d!(snapshots)\n\nPlots trajectory of the spins in a sequence of Snapshot objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.CLI","page":"API","title":"MCMRSimulator.CLI","text":"Defines the command line interface to MCMRSimulator.jl (mcmr).\n\nFunctions:\n\nrun_main\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.CLI.run_main_docs-Tuple{AbstractString}","page":"API","title":"MCMRSimulator.CLI.run_main_docs","text":"run_main_test(cmd::AbstractString)\n\nReturns markdown with the stdout and stderr produced by running run_main on the given command. This is used for testing of the command line interface\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.CLI.run_main_test-Tuple{AbstractString}","page":"API","title":"MCMRSimulator.CLI.run_main_test","text":"run_main_test(cmd::AbstractString)\n\nReturns the stdout and stderr produced by running run_main on the given command. This is used for testing of the command line interface\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.CLI.Geometry","page":"API","title":"MCMRSimulator.CLI.Geometry","text":"Defines command line interface for mcmr geometry\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.CLI.Geometry.get_parser-Tuple{}","page":"API","title":"MCMRSimulator.CLI.Geometry.get_parser","text":"get_parser()\n\nReturns the parser of arguments for mcmr geometry\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.CLI.Geometry.parse_user_argument-Union{Tuple{T}, Tuple{MCMRSimulator.Geometries.User.Obstructions.Fields.FieldValue{T}, Any, Any}} where T","page":"API","title":"MCMRSimulator.CLI.Geometry.parse_user_argument","text":"parse_user_argument(field_value, value, n_objects)\n\nParse the user argument to something that can actually be used internally by Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.CLI.Geometry.run_main","page":"API","title":"MCMRSimulator.CLI.Geometry.run_main","text":"run_main([arguments])\n\nRuns the mcmr geometry command line interface. The supplied arguments can be provided as a sequence of strings (as provided by the terminal) or as a dictionary (as provided by ArgParse after parsing). By default it is set to ARGS.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.CLI.Sequence","page":"API","title":"MCMRSimulator.CLI.Sequence","text":"Defines the command line interface to mcmr sequence.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.CLI.Sequence.run_main","page":"API","title":"MCMRSimulator.CLI.Sequence.run_main","text":"run_main([arguments])\n\nRuns the mcmr sequence command line interface. Arguments are provided as a sequence of strings. By default it is set to ARGS.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMRSimulator.CLI.Run","page":"API","title":"MCMRSimulator.CLI.Run","text":"Defines the command line interface to mcmr run.\n\n\n\n\n\n","category":"module"},{"location":"api/#MCMRSimulator.CLI.Run.add_init_flags!-Tuple{Any}","page":"API","title":"MCMRSimulator.CLI.Run.add_init_flags!","text":"Add initialisation flags to an argument parser.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.CLI.Run.add_output_flags!-Tuple{Any}","page":"API","title":"MCMRSimulator.CLI.Run.add_output_flags!","text":"Add output flags to an argument parser.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.CLI.Run.add_readout_flags!-Tuple{Any}","page":"API","title":"MCMRSimulator.CLI.Run.add_readout_flags!","text":"Add readout flags to an argument parser.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.CLI.Run.add_simulation_definition!-Tuple{Any}","page":"API","title":"MCMRSimulator.CLI.Run.add_simulation_definition!","text":"Add simulation definition parameters to an argument parser.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.CLI.Run.get_parser-Tuple{}","page":"API","title":"MCMRSimulator.CLI.Run.get_parser","text":"get_parser()\n\nReturns the parser of arguments for mcmr run\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.CLI.Run.read_bvecs-Tuple{Any}","page":"API","title":"MCMRSimulator.CLI.Run.read_bvecs","text":"read_bvecs(filename)\n\nReads the bvecs into a Nx3 matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#MCMRSimulator.CLI.Run.run_main","page":"API","title":"MCMRSimulator.CLI.Run.run_main","text":"run_main([arguments])\n\nRuns the mcmr run command line interface. The supplied arguments can be provided as a sequence of strings (as provided by the terminal) or as a dictionary (as provided by ArgParse after parsing). By default it is set to ARGS.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#geometry","page":"Geometry","title":"Obstructions to free diffusion","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"MCMRSimulator.jl comes with a variety of basic components that can be used to represent various components in the tissue microstructure.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Component Constructor Dimensionality\ninfinite walls Walls 1\nhollow infinite cylinder Cylinders 2\nAnnulus with inner and outer cylinders Annuli 2\nhollow sphere Spheres 3\nmesh Mesh 3","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"The constructors for these components all have a similar interface. Some expect certain component-specific keyword arguments (e.g., radius for Spheres and Cylinders, or the keywords regarding the myelin-induced off-resonance field produced by Cylinders or Annuli). MRI relaxation properties within the obstruction and collision parameters (stuck spins, magnetisation transfer rate & permeability) can be set using keyword arguments as described in the properties section. Finally, these constructors expect a set of keyword arguments that control their location. These arguments are identicaly across all constructors (although the expected input depends on the dimensionality of the component as listed in the table above):","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"position: Set the positions for each generated components (not used in Mesh).\nrepeats: Set the distance with which all components should be repeated.\nrotation: Applies a single rotation to the whole system.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Components with a lower dimensionality are defined by default along the x-axis (for dimensionality of 1) or the x-y plane (for dimensionality of 2).  In other words, the normal of the Walls point in the x-axis by default, while the Cylinders point in the z-axis. Shifts and repeats should only be provided in this lower-dimensional space. The rotation keyword can be used to define these components along other lines/planes (see get_rotation).","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"From the command line all of these keywords are available as flags, which can be seen by running:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"mcmr geometry create walls/cylinders/annuli/spheres --help","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"In Julia, the easiest way to get the documentation for all keywords is to run:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"?Walls/Cylinders/Annuli/Spheres/Mesh","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"or by following the links in the table above.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"For example, we can create two base cylinders, which repeat infinitely by running:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"using MCMRSimulator\ngeometry = Cylinders(radius=sqrt(0.5), position=[[0, 0], [1, 1]], repeats=[2, 2])\nusing CairoMakie # hide\nf = plot(PlotPlane(size=4), geometry) # hide\nsave(\"regular_cylinders.png\", f) # hide\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"(Image: Plot showing two cylinders repeating ad infinitum)","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Alternatively, the same configuration could be produced with a single cylinder by providing a rotation.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"using MCMRSimulator\nrotation = [\n    sqrt(0.5) sqrt(0.5) 0.\n    -sqrt(0.5) sqrt(0.5) 0.\n    0. 0. 1.\n    ]\ngeometry = Cylinders(radius=sqrt(0.5), repeats=[sqrt(2), sqrt(2)], rotation=rotation)\nusing CairoMakie # hide\nf = plot(PlotPlane(size=4), geometry) # hide\nsave(\"regular_cylinders2.png\", f) # hide\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"(Image: Plot showing single cylinders repeating ad infinitum)","category":"page"},{"location":"geometry/#Randomly-distributed-cylinders/annuli/spirals","page":"Geometry","title":"Randomly distributed cylinders/annuli/spirals","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"A random set of positions and radii can be created using random_positions_radii. The user in this case sets a target density (70% in the example below) and over which length scale the configuration should repeat itself (20x20 micrometer in the example below).","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"using MCMRSimulator # hide\nusing Random; Random.seed!(1234) # hide\n(positions, outer_radii) = random_positions_radii((20, 20), 0.7, 2)\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"From the command line this functionality is available by running mcmr geometry create-random cylinders/annuli/spheres.","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"These can be used to produce randomly distributed cylinders:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"geometry = Cylinders(radius=outer_radii, position=positions, repeats=(20, 20))\nusing CairoMakie # hide\nf = plot(PlotPlane(size=20), geometry) # hide\nsave(\"random_cylinders.png\", f) # hide\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"(Image: Illustrating configuration of random cylinders)","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"When used as initialisation for annuli or spirals, an inner radius will also need to be computed:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"geometry = Annuli(inner=0.8 .* outer_radii, outer=outer_radii, position=positions, repeats=(20, 20))\nusing CairoMakie # hide\nf = plot(PlotPlane(size=20), geometry) # hide\nsave(\"random_annuli.png\", f) # hide\nnothing # hide","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"(Image: Illustrating configuration of random annuli)","category":"page"},{"location":"tutorial_cli/#tutorial_cli","page":"Tutorial (CLI)","title":"Tutorial","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"This tutorial will walk through an example of modelling the MRI signal evolution for a diffusion-weighted sequence. The spins in this simulation will be constrained by regularly packed cylinders. This tutorial will use the command line interface, which we assume is available through the mcmr command (see installation instructions). If you would prefer to interact with MCMRSimulator in Julia, you can find a tutorial doing the same analysis here.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"In general, running a simulation will consist of the following three steps:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"Creating a geometry using one or more calls to mcmr geometry (full description)\nDefining a sequence using mcmr sequence (full description)\nRunning the actual simulation using mcmr run","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We will look through each of these steps below.","category":"page"},{"location":"tutorial_cli/#Defining-the-geometry","page":"Tutorial (CLI)","title":"Defining the geometry","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"First we will define a geometry formed of regularly packed axons. This is represented by a single cylinder pointing in the z-direction with a radius of 1 micrometer that repeats itself every 2.5 micrometer (in both the x-, and y-direction).","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr geometry create cylinders 1 geometry.json --radius 1 --repeats 2.5 2.5","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"geometry create cylinders 1 geometry.json --radius 1 --repeats 2.5 2.5\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"This will create a JSON file with the full information on the geometry:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\ntext = read(\"geometry.json\", String)\nMarkdown.parse(\"```json\\n$(text)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"You can see how that the repeats and radius keywords have been set to our predefined values. You can alter these and other geometry properties by editing this JSON directly or using the flags when creating the geometry. For a full overview of these flags, you can run:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr geometry create cylinders --help","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"geometry create cylinders --help\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"How these various properties affect the simulation is described here.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The procedure to create Walls, Spheres, or Annuli is very similar as for the Cylinders illustrated above. Randomly distributed cylinders, annuli, and spheres can be created using mcmr geometry create-random.","category":"page"},{"location":"tutorial_cli/#Defining-the-sequence","page":"Tutorial (CLI)","title":"Defining the sequence","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The next step is to define a sequence (see here for more details).  There are several built-in sequences available, which you can see listed by running:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr sequence","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"sequence\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"Alternatively, you can skip this step and use a sequence defined using pulseq instead.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"Here, we will create a diffusion-weighted sequence:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr sequence dwi dwi.json --bval=2 --TR=1000 --TE=80 --B0=3","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"sequence dwi dwi.json --bval=2 --TR=1000 --TE=80 --B0=3\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"This produces another JSON:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\ntext = read(\"dwi.json\", String)\nMarkdown.parse(\"```json\\n$(text)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"This one is less readable or editable by users, but basically describes the sequence diagram.","category":"page"},{"location":"tutorial_cli/#Running-the-simulation","page":"Tutorial (CLI)","title":"Running the simulation","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"To get instructions on running the simulations, we can check the help message of mcmr run:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run --help","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run --help\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We can see that in addition to defining the geometry and the sequence, we can also control the simulation properties such as the --diffusivity, --R1, and --R2.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The simulation is initialised by randomly distributing a number of spins (set by --Nspins) uniformly across a bounding box with size given by --voxel-size. This initial state might also contain bound spins (if the --density flag was set to a non-zero value during the geometry generation).","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The DWI sequence defined above contains a Readout object at the echo time (80 ms). By default, this is used for readout:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run geometry.json dwi.json -o signal.csv","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run geometry.json dwi.json -o signal.csv --seed=1\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"This produces the CSV file, which looks like","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\ntext = read(\"signal.csv\", String)\nMarkdown.parse(\"```\\n$(text)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The columns in this file store the following information:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"\"sequence\": integer; index of the sequence (always 1 if only single sequence used)\n\"bvec\": integer; index of the gradient orientation (if a --bvec flag is provided)\n\"TR\": integer; index of the repetition time that this data was acquired (between 1 and the value of --nTR)\n\"readout\": integer; index of the readout within a TR.\n\"subset\": integer; index of the subset of the total signal (e.g., intra-axonal) that has been output (see the --subset flag). The total signal will always be included with \"subset\" of 0.\n\"nspins\": total number of spins contributing to the signal (might change for certain subsets of spins)\n\"longitudinal\": average longitudinal signal\n\"transverse\": average transverse signal\n\"phase\": average phase of the signal (in degrees)\n\"Sx\": signal strength in the x-direction\n\"Sy\": signal strength in the y-direction","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We can also output the signal of specific subsets of spins. For example, in the following we request to separately the output for just the spins inside the cylinders and just the spins outside of the cylinders.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run geometry.json dwi.json -o signal.csv --subset inside --subset outside","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run geometry.json dwi.json -o signal2.csv --subset inside --subset outside --seed=2\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We can see two additional rows in the output.  These new rows are the in same order as the --subset flags provided to mcmr run and can be distinguished based on the \"subset\" column.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\ntext = read(\"signal2.csv\", String)\nMarkdown.parse(\"```\\n$(text)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We can see in the second row that inside the cylinders the transverse signal is very close to the number of spins,  indicating that there has been very little dephasing due to the diffusion weighting inside the cylinders. On the other hand, we did lose most of the signal outside of the cylinders (i.e., the transverse signal is much lower than the number of spins in the third row). All the spins are either inside or outside the cylinders, so in this case the first row is simply the sum of the next two.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"A more complete state of all the spins can be produced using the --output-snapshot flag. For example, the command","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run geometry.json dwi.json --output-snapshot snapshot.csv","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run geometry.json dwi.json --output-snapshot snapshot.csv --seed=3\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"will produce a file named \"snapshot.csv\" with:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\nlines = split(read(\"snapshot.csv\", String), '\\n')\ntext = join(lines[1:5], '\\n')\nMarkdown.parse(\"```csv\\n$(text)\\n...\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"Each row corresponds to the state of a single spin. In addition to all the columns listed above, we now have 4 more columns:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"\"spin\": integer; index of the spin\n\"x\"/\"y\"/\"z\": floats; position of the spin at the time of the readout","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The readout times can be adjusted using the --nTR, --time, and --skip-TR flags.","category":"page"},{"location":"tutorial_cli/#Full-diffusion-weighted-MRI-acquisition","page":"Tutorial (CLI)","title":"Full diffusion-weighted MRI acquisition","text":"","category":"section"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"As a more involved example, we will run the simulations for a single-shell diffusion-weighted MRI sequence. We presume we have a set of gradient orientations for the single shell, which is stored in a file named \"bvecs\". This file contains:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\nbvecs = \"1  0  0  \n0.6745407374  -0.01795697854  -0.7380192006  \n0.7236803088  0.6359626605  -0.2680266875  \n-0.4393837408  0.7100360545  0.5502642362  \n0.6745407272  -0.7191533962  0.1667728998  \n0.2765856485  0.9281564296  0.2490502383  \n-0.01390244774  0.8653306796  -0.5010085198  \n-0.2765856448  -0.4727794531  -0.8366480561  \n-0.7236803023  0.1008527628  -0.6827265487  \n-0.01390247052  -0.2692289608  0.9629758502\"\nopen(\"bvecs\", \"w\") do f\n  write(f, bvecs)\nend\nMarkdown.parse(\"```\\n$(bvecs)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"We then define two sequences, one for the b0 and the other for the diffusion-weighted MRI:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr sequence dwi b0.json --bval=0 --TR=1000 --TE=80 --scanner=Siemens_Prisma\nmcmr sequence dwi dwi.json --bval=2 --TR=1000 --TE=80 --scanner=Siemens_Prisma","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"sequence dwi b0.json --bval=0 --TR=1000 --TE=80 --scanner=Siemens_Prisma\")\nrun_main_docs(\"sequence dwi dwi2.json --bval=2 --TR=1000 --TE=80 --scanner=Siemens_Prisma\")\nnothing","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"Here we set the scanner to Siemens_Prisma, which is used to set the B0 field as well as the maximum gradient and slew rate.","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"Let's evaluate these sequences for some randomly distributed cylinders:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr geometry create-random cylinders 0.6 random_cylinders.json --mean-radius=1. --var-radius=0.1 --repeats 5 5","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"geometry create-random cylinders 0.6 random_cylinders.json --mean-radius=1. --var-radius=0.1 --repeats 5 5 --seed=4\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"The resulting cylinder JSON file look like:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\ntext = read(\"random_cylinders.json\", String)\nMarkdown.parse(\"```json\\n$(text)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"And, finally run the simulation:","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"mcmr run random_cylinders.json b0.json dwi.json --bvecs=bvecs -o full_dwi.csv","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import MCMRSimulator.CLI: run_main_docs\nrun_main_docs(\"run random_cylinders.json b0.json dwi2.json --bvecs=bvecs -o full_dwi.csv --seed=5\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"import Markdown\ntext = read(\"full_dwi.csv\", String)\nMarkdown.parse(\"```\\n$(text)\\n```\")","category":"page"},{"location":"tutorial_cli/","page":"Tutorial (CLI)","title":"Tutorial (CLI)","text":"Note that the multiple gradient orientations are only applied to the sequence with diffusion-weighted gradients, not the b0 sequence. So, in total we have 11 sequences, one for the b0 sequence, and 10 for each bvec for the dwi sequence.","category":"page"},{"location":"properties/#properties","page":"MRI/collision properties","title":"Simulation properties","text":"","category":"section"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"How the spins behave is determined by the tissue geometry, the applied MRI sequences, and user-provided flags determining how the spin magnetisation evolves. Here we discuss how the spin magnetisation evolution can be affected by these user-provided flags.","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"For example, one such flag is the diffusivity, which can be set as a keyword argument while generating the Simulation.","category":"page"},{"location":"properties/#MRI-properties","page":"MRI/collision properties","title":"MRI properties","text":"","category":"section"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"MRI properties determine the spin evolution for free and stuck particles. They include:","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"the longitudinal relaxation rate R1\nthe transverse relaxation rate R2\nthe global off_resonance field (i.e., any off-resonance not caused by the sequence or the geometry)","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"At the Simulation level these parameters can be set by supplying the R1, R2, or off_resonance flags (see GlobalProperties), such as:","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"simulation = Simulation(sequences, R2=1/80)","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"These MRI properties can be locally altered when defining the geometry. In the geometry they can be seperately set for spins stuck to the geometry surface or those spins that are inside specific objects in the geometry. The total relaxation rate (and off-resonance field) is set by the sum of the global value, the value set for any surface the spin is stuck to, and the value set for any obstruction that the spin is inside of. A single spin might be inside of multiple obstructions at once, if they overlap. In that case, only the first one will be considered (in the order that the obstructions are supplied by the user). For the off-resonance field there might also be a contribution of the magnetic suscpetibility of any Cylinders, Annuli, or Mesh.","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"If not set at the global or local level, there will be no longitudinal or transverse relaxation and there will be no off-resonance field.","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"From the command line interface, the global parameters are set during the mcmr run command using --diffusivity, --R1, and --R2 keywords. Local parameters will already have been set at an earlier stage during the creation of the geometry using mcmr geometry create/create-random.","category":"page"},{"location":"properties/#Collision-properties","page":"MRI/collision properties","title":"Collision properties","text":"","category":"section"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"Collision properties determine the behaviour of spins at the time of a collision. Like MRI properties they can be set at the global level (while creating Simulation) or overwritten at the local level (geometry). There are four such properties:","category":"page"},{"location":"properties/","page":"MRI/collision properties","title":"MRI/collision properties","text":"MCMRSimulator.surface_relaxivity: the fraction of transverse signal lost (and longitudinal signal regained) at every collision. This fraction is adjusted to take into account the timestep (see MCMRSimulator.correct_for_timestep). Note that this is not the recommended way to model magnetisation transfer. Instead, we recommend using the surface_density as discussed below.\nMCMRSimulator.permeability: the probability of the spin passing through the surface. If the spins do not pass through, they will undergo regular reflection (or get stuck, see below). Like MT_fraction it will be adjusted to take into account the timestep (see MCMRSimulator.correct_for_timestep).\nMCMRSimulator.surface_density and MCMRSimulator.dwell_time: These control the density and dwell time of spins on the surface. Depending on the MRI properties assigned to these stuck particles (see above), these stuck particles can be used to represent water stuck at the membranes due to surface tension or spins in the membrane itself (which is in exchange with the free water through magnetisation transfer).","category":"page"},{"location":"installation/#installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"MCMRSimulator is an application written in the Julia language. You can run simulations either directly from the Julia REPL, in a Jupyter notebook, or using the command line interface.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"For now, it is only possible to install MCMRSimulator using the built-in Julia package manager.  In the future, we will also provide docker and singularity images to make it possible to run the command line interface without installing julia.","category":"page"},{"location":"installation/#global_julia","page":"Installation","title":"Global Julia installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"First install julia from the official website.\nChoose a directory, where you will install MCMRSimulator. If you want to install a single version of MCMRSimulator, this might just be any folder in your home directory. If you want to associate the MCMRSimulator with a specific project, you might want to select a directory within that project. We will refer to this chosen directory below as \"<project_dir>\".\nStart the julia REPL in a terminal ($ julia --project=<project_dir>).\nEnter the package manager by pressing \"]\"\nInstall MCMRSimulator.jl using pkg> add https://git.fmrib.ox.ac.uk/ndcn0236/mcmrsimulator.jl.git#v0.8.0.\nOptionally, install one of the Makie backends for plotting (e.g., pkg> add CairoMakie).\nIf you want to use a Jupyter notebook, you will also have to install IJulia. You can find instructions to do so at https://github.com/JuliaLang/IJulia.jl.\nPress \"[backspace]\" to leave the package manager.","category":"page"},{"location":"installation/#Running-MCMRSimulator","page":"Installation","title":"Running MCMRSimulator","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"After this installation process, you can run MCMRSimulator in one of the following ways:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia REPL: Start the REPL in a terminal by typing $ julia --project=<project_dir>. Afterwards type using MCMRSimulator to import the simulator. You can now follow the steps in the MCMRSimulator tutorial using Julia.\nJupyter notebook: Make sure that you install IJulia using the instructions above. This will allow you to start a notebook in jupyter running in Julia. Within this notebook, you can follow the steps in the MCMRSimulator tutorial using Julia.\nCommand line interface: You can now run the command line interface using julia --project=<project_dir> -e 'import MCMRSimulator.CLI: run_main; run_main()' -- [args]. This is a lot to type, so I would recommend adding an alias for this to your \".bashrc\" file (or equivalent): alias mcmr=\"julia --project=<project_dir> -e 'import MCMRSimulator.CLI: run_main; run_main()' -- \". With this alias set up, you can now follow the command line tutorial","category":"page"},{"location":"installation/#Updating-MCMRSimulator","page":"Installation","title":"Updating MCMRSimulator","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"First check the changelog to find a list of changes since your current version. If you decide to update:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Start the julia REPL again in a terminal ($ julia --project=<project_dir>)\nEnter the package manager by pressing \"]\"\nUpdate all installed packages using by typing update and pressing enter (pkg> update).","category":"page"},{"location":"installation/#Sharing-your-MCMRSimulator-installation","page":"Installation","title":"Sharing your MCMRSimulator installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To share the exact environment used by your installation of MCMRSimulator, simply go to the <project_dir> directory and locate the files named \"Project.toml\" and \"Manifest.toml\". Transfer these files to any other computer, to ensure that they install the exact same version of all Julia packages used (see https://pkgdocs.julialang.org/v1/environments/ for more details).","category":"page"},{"location":"sequence/#sequence","page":"Sequence","title":"MR sequences","text":"","category":"section"},{"location":"sequence/#Pulseseq-sequences","page":"Sequence","title":"Pulseseq sequences","text":"","category":"section"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"Pulseq sequences can be generated using matlab (http://pulseq.github.io/) or python (https://pypulseq.readthedocs.io/en/master/). They can be loaded into MCMRSimulator using read_sequence. On the command line they can be provided directly to any call of mcmr run, without calling mcmr sequence first. Developing your sequences in pulseq has the advantage that they can be used both in MCMRSimulator and on your MRI scanner.","category":"page"},{"location":"sequence/#Built-in-MR-sequences","page":"Sequence","title":"Built-in MR sequences","text":"","category":"section"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"Simple gradient_echo and spin_echo sequences are available. A pulsed-gradient spin-echo can be created using dwi.","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"From the command line these sequences can be generated using mcmr sequence gradient-echo/spin-echo/dwi.","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"In Julia, one can use:","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"using MCMRSimulator # hide\nsequence = dwi(TR=100., bval=3.)\nusing CairoMakie # hide\nf = plot(sequence) # hide\nsave(\"dwi_sequence.png\", f) # hide\nnothing # hide","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"(Image: DWI sequence diagram)","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"By setting the gradient_duration keyword to 0, InstantGradient objects can be inserted instead of MRGradients.","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"using MCMRSimulator # hide\nsequence = dwi(TR=100., bval=3., gradient_duration=0.)\nusing CairoMakie # hide\nf = plot(sequence) # hide\nsave(\"dwi_sequence_delta_0.png\", f) # hide\nnothing # hide","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"(Image: DWI sequence diagram with instanteneous gradients)","category":"page"},{"location":"sequence/#Custom-MR-sequences","page":"Sequence","title":"Custom MR sequences","text":"","category":"section"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"In MCMRSimulator.jl an MR Sequence describes the RF pulses and gradients applied by the MRI scanner.","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"This sequence contains of:","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"RF pulses, which can be instantaneous (InstantRFPulse) or be described more realistically as RF amplitude/phase profiles ([RFPulse])\nGradients. Like RF pulses they can be approximated as instanteneous (InstantGradient) or have a finite duration (MRGradients)\nReadouts (Readout). These are always instanteneous as realistic modelling of an actual MRI readout would require modelling the whole brain and receiver coil configuration, which is far beyond the scope of this simulator.","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"Each of these sequence components will play identically every repetition time (TR) of the sequence.","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"The simplest way to create these sequences is as a (possibly nested) vector of sequence BuildingBlock, which are played in sequence.  Each building block can be one of the following:","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"an RF pulse (InstantRFPulse or finite RFPulse)\na gradient (InstantGradient or finite MRGradients)\na number indicating a delay\na Readout\na BuildingBlock object, which can be used for when an RF pulse and gradient need to played simultaneously (e.g., for slice-selective pulses)","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"Such a (nested) vector can be passed on directly to the Sequence constructor.","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"Such custom sequences cannot be generated using the command line yet.","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"For example, a simple pulsed-gradient spin echo sequence could be generated in the following way (rather than call dwi):","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"using MCMRSimulator # hide\ntrapezium = MRGradients([\n    (0, 0),\n    (1, 0.01),  # 1 ms rise time to 0.01 kHz/um\n    (39, 0.01), # constant amplitude for 38 ms\n    (40, 0),    # total duration of 40 ms\n], apply_bvec=true  # allow rotation using a `bvec`\n)\n\nunrotated_sequence = Sequence([\n    constant_pulse(2, 90),          # start with 2 ms excitation pulse\n    trapezium,                      # followed immediated by MR gradients\n    2,                              # wait for 2 ms\n    constant_pulse(4, 180),         # refocus pulse (4 ms long)\n    trapezium,\n    3,\n    Readout(),                      # Readout 90 ms after middle of excitation pulse\n], TR=130, scanner=Scanner(B0=3.))\n\n# rotate any gradients in the sequence for which `apply_bvec` is true from the +x into the +y/+z axis.\nsequence = rotate_bvec(unrotated_sequence, [0, 0.5, 1])\n\nusing CairoMakie # hide\nf = plot(sequence) # hide\nsave(\"custom_dwi.png\", f) # hide\nnothing # hide","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"(Image: Sequence diagram of custom DWI)","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"Adding diffusion-weighting can be made easier using add_linear_diffusion_weighting:","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"using MCMRSimulator # hide\n\n# Build sequence without diffusion weighting\nbase_sequence = [\n    constant_pulse(2, 90),          \n    42,                      # to be replaced with gradient\n    constant_pulse(4, 180),          \n    23,                      # to be replaced with gradient\n    20,                      # kept empty to allow time for extended readout\n    Readout(),\n]\n# replace blocks 2 and 4 in the `base_sequence` with gradients that produce a b-value of 1 um^2/ms\nwith_dwi = add_linear_diffusion_weighting(base_sequence, 2, 4, bval=1.) \nsequence = Sequence(with_dwi; TR=100)\nusing CairoMakie # hide\nf = plot(sequence) # hide\nsave(\"custom_dwi_helped.png\", f) # hide\nnothing # hide","category":"page"},{"location":"sequence/","page":"Sequence","title":"Sequence","text":"(Image: Sequence diagram of custom DWI using add_linear_diffusion_weighting)","category":"page"},{"location":"tutorial_julia/#tutorial_julia","page":"Tutorial (Julia)","title":"Tutorial","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"This tutorial will walk through an example of modelling the MRI signal evolution for a diffusion-weighted sequence. The spins in this simulation will be constrained by regularly packed cylinders. This tutorial will use the programatic Julia interface, which you can run in the Julia REPL or in a Jupyter notebook. If you would prefer to use the command line interface, you can find a tutorial doing the same analysis here.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"After installation we can load MCMRSimulator.jl using","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"using MCMRSimulator\nusing CairoMakie  # used for plotting; use GLMakie or WGLMakie for interactive plots","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"In general, running a simulation will consist of the following three steps:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Defining the microstructure and one or more sequences by creating an appropriate Simulation object.\nInitialising Snapshot with one or more Spin objects.\nSimulating a random walk of the spins through the microstructure and the MR signal produced by those spins.\nPlotting the MR signal or storing it to disk.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"We will look through each of these steps below.","category":"page"},{"location":"tutorial_julia/#Defining-the-simulation","page":"Tutorial (Julia)","title":"Defining the simulation","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The first step is to define the environment through which the spins will evolve. We will do so by creating an appropriate Simulation object. This Simulation will contain information on the microstructure, how spins interact with that microstructure, and the enabled sequence(s).","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"These different steps are described in more detail in other sections of this documentation:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"How to define the microstrutural geometry\nControlling spin behaviour\nSequence generation","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"First we will define a geometry formed of regularly packed axons. This is represented by a single cylinder with a radius of 1 micrometer that repeats itself every 2.5 micrometer (in both the x-, and y-direction).","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"import Random; Random.seed!(1) # hide\ngeometry = Cylinders(radius=1., repeats=[2.5, 2.5])\n\nf = plot(PlotPlane(size=5), geometry)\nf\nsave(\"tutorial_geometry.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"More complicated geometries can be generated as described here.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The next step is to define a sequence (see here for more details).  Here we will adopt a single diffusion-weighted MRI sequence.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"sequence = dwi(bval=2., TR=1000, TE=80, scanner=Siemens_Prisma)  # default gradient orientation in the x-direction\nf = plot(sequence)\nf\nsave(\"tutorial_sequence.png\", f); # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Once we have both a geometry and one or more sequences, we can put them together in a Simulation object:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"simulation = Simulation(sequence, R2=0.012, R1=3e-3, diffusivity=2., off_resonance=0.1, geometry=geometry)\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"By default there is no T1 or T2 relaxation and a diffusivity of 3 um^2/ms. Enabling spin relaxation and diffusion requires setting the appropriate parameters in the Simulation as seen here. The spin relaxation rates can be different in different compartments as described here.","category":"page"},{"location":"tutorial_julia/#Initialising-the-simulation","page":"Tutorial (Julia)","title":"Initialising the simulation","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The current state of the simulation at any time is given by a Snapshot object. This is essentially a vector of Spin objects with a time stamp. Each Spin represents a single diffusing particle. Besides containing its current position, it also contains its contribution to the MR signal for each of the sequences in the simulation and whether it is stuck on any surfaces.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The recommended way to initialise is to call Snapshot(<number of spins>, <simulation>, [bounding_box]). This will create randomly distributed spins within some BoundingBox. By default this bounding box is an isotropic voxel with a size of 1 mm centered on the origin.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"After initialisation or after running the simulation, the Snapshot can be later filtered to include only spins inside/outside specific compartments or only include free/bound spins using [get_subset].","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The simulation can also be initialised explicitly using a sequence of positions (i.e., length-3 vectors) with the initial spin positions.  Note that such a simulation will start with all spins free and not necessarily randomly distributed, which means it might take some time to reach an equilibrium.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"For each of these initialisations the initial magnetisation can be explicitly set using the transverse, longitudinal, and phase flags. The default is for spins to start in equilibrium (i.e., transverse magnetisation of 0 and longitudinal magnetisation of 1).","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Finally, one could start a simulation using a Snapshot from a previous simulation.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"note: Deterministic spins\nEach Spin is assigned a random number state at creation, which will be used for its future evolution. This means that after creation of a spin or a Snapshot its future is fully determined. This ensures that when a spin is evolved through the same simulation multiple times, it sill follow the same path each time. This allows improved comparisons between simulations with the same geometry, but different sequences/physics. However, it can lead to confusing results (e.g., a simulation initialised with fill(Spin(), 500) will contain 500 spins all following the exact same path).","category":"page"},{"location":"tutorial_julia/#Running-the-simulation","page":"Tutorial (Julia)","title":"Running the simulation","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The main way to run a simulation is by calling readout. This function takes a Snapshot and a Simulation as input (or a number of spins, which will be used to generate a new Snapshot on the fly). There are various ways to define when the output will be read out (as described in the readout documentation).","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Here, we will illustrate various examples of using this function:","category":"page"},{"location":"tutorial_julia/#Simple-signal-readouts","page":"Tutorial (Julia)","title":"Simple signal readouts","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Most sequences will contain one or more Readout objects, which define when the sequence will be read out during each repetition time (TR). To get the signal at this time, we can simply call:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"readout(1000, simulation)","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"This signal is not truely representative from what we expect in a true diffusion-weighted MRI sequence, because the longitudinal signal has not had a chance to relax across multiple repetition times. To see what the signal will look like after such equilibriation, we can delay our readout with several TRs:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"readout(1000, simulation, skip_TR=5)","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"In addition, to the total signal, we can also get the signal associated with individual compartments:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"readout(1000, simulation, subset=[Subset(inside=true), Subset(inside=false)])","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Note that we now get two signal outputs. The first respresents teh signal within the cylinders, which is very close to number of spins,  indicating that there has been very little dephasing due to the diffusion weighting inside the cylinders. On the other hand, we did lose most of the signal outside of the cylinders. All the spins are either inside or outside the cylinders, so in this case the first row is simply the sum of the next two.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Instead of just running the simulation for multiple TRs without readouts,  we could also visualise the equilibriation process by outputting the signal for multiple TRs:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"signals = readout(1000, simulation, nTR=6)\nf = lines(longitudinal.(signals))\nlines!(transverse.(signals))\nf\nsave(\"tutorial_equil.png\") # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"At each timepoint readout by default will return the total MR signal (for each sequence) as a SpinOrientation object. From this one can estimate the transverse component, the longitudinal component, and the phase. The longitudinal and transverse functions are used above to get those respective components.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"We can also override, when the signal will be read out, by passing on the readout times as a third argument to readout. Here we use this to plot the actual transverse signal evolution.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"times = 0:0.1:100\n# simulate 3000 spins for a single repetition time\naverage_signals = readout(3000, simulation, times, skip_TR=5)\nf = plot(sequence)\nlines!(times, transverse.(average_signals)/3000.)\nxlims!(0, 100)\nf\nsave(\"tutorial_transverse.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Note that by plotting the Sequence as well, we make the signal evolution a lot easier to interpret.","category":"page"},{"location":"tutorial_julia/#Reading-out-the-full-snapshot","page":"Tutorial (Julia)","title":"Reading out the full snapshot","text":"","category":"section"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Instead of returning just the total signal readout can also return the full spin state in a Snapshot object by setting the return_snapshot keyword to true. Note that this is very memory intensive, so is only recommended when you only output a small number of timepoints or a small number of spins.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Here, we use this to visualise the trajectory of spins through the geometry. To plot the trajectory we first need to output the state of the all spins at a high temporal resolution:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"# Simulate 2 spins with given starting positions for 3 ms\nsnapshots = readout([[0, 0, 0], [1, 1, 0]], simulation, 0:0.01:3., return_snapshot=true)\n\npp = PlotPlane(size=5.)\nf = plot(pp, geometry)\nplot_trajectory2d!(pp, snapshots)\nf\nsave(\"tutorial_trajectory2D.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: ) In this plot the color at each timepoint encodes the spin orientation. The brightness of the spin indicates the size of the transverse component with purely longitudinal spins being in black. The color of the spin encodes the phase of the MR signal in the transverse plane.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"The trajectories can also be plotted in 3D:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"f = plot_trajectory3d(snapshots)\nsave(\"tutorial_trajectory3D.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: )","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"We can also use this future to plot the complete Snapshot at a specific time.  In this example we do not set this time explicitly, so it will default to the time of the sequence Readout as discussed above:","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"snapshot = readout(3000, simulation, return_snapshot=true)\npp = PlotPlane(size=2.5)\nf = plot(pp, snapshot)\nplot!(pp, geometry)\nf\nsave(\"tutorial_snapshot.png\", f) # hide\nnothing # hide","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"(Image: ) The color encoding is the same as for the trajectory plot above. The brightness encodes the size of the transverse component, while the color encodes the phase of the MR signal in the transverse plane. We can see that outside of the cylinder the signal contribution is significantly reduced. The black arrows show the transverse spin for some random subset of spins.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"Note that object returned when return_snapshot=true is the same Snapshot object as was used to initialise this simulation. This means that it can be used as an initialisation for future simulations.","category":"page"},{"location":"tutorial_julia/","page":"Tutorial (Julia)","title":"Tutorial (Julia)","text":"One complication with this occurs when running a Simulation with multiple sequences. Often, these different sequences will readout at different times (because of different Readout objects and/or different TRs). So, each Snapshot object returned by readout will only contain the spin magnetisation of the sequence that is readout at that particular time. To get a Snapshot object with the spin states for all sequences, you can use the evolve function instead.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MCMRSimulator.jl allows simulation of MR signal generation using Monte Carlo simulations. The spin evolution of randomly diffusing particles is tracked under influence of one or more MR sequences. At present, the simulator allows to model","category":"page"},{"location":"","page":"Home","title":"Home","text":"Free diffusion and diffusion restricted by Walls, Cylinders, Spheres, and/or a triangular Mesh.\nR1 and R2 relaxation using global or local R1/R2 parameters\nMR sequences consisting of arbitrary RF pulses, gradients, and readouts\nOff-resonance magnetic field generation by myelinated cylinders or meshes\nMagnetisation transfer between liquid spins and bound spins in membranes.\nMembrane permeability (i.e., exchange)\nSurface relaxation\nSurface tension of membranes causing spins to get temporarily \"stuck\" when they hit a membrane","category":"page"},{"location":"","page":"Home","title":"Home","text":"Future (potential) features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Off-resonance field by iron particles\nContribution from metabolites (i.e., spectroscopy)","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: beta\nThis MR simulator is still under very active development and the API might still change substantially at any time!","category":"page"},{"location":"","page":"Home","title":"Home","text":"We use the following units throughout (unless otherwise noted):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Times are in ms. Equivalently, RF pulse amplitudes and off-resonance magnetic fields are in kHz (i.e., 1/ms).\nPositions are in um. So, gradients are in kHz/um (not mT/m).\nAngles are in degrees (not radians). These are used for phases (of spins and RF pulses) as well as RF pulse flip angles. \nSusceptibilities are in parts per million (ppm).","category":"page"},{"location":"#How-to-get-started?","page":"Home","title":"How to get started?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If MCMRSimulator is not yet installed, follow the installation instructions.\nLook through one of the tutorials. There are two available, depending on which interface you prefer to use:\nFor the command line interface: CLI tutorial\nFor the julia interface: Julia tutorial\nIf you want more information on a specific topic, you can check one of the more dedicated sections:\nGeometry\nMRI & collision properties\nSequences\nFull API","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The original simulator was written by Michiel Cottaar.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other contributors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Zhiyu Zheng","category":"page"},{"location":"#Movie-of-spins-moving-through-cylinders","page":"Home","title":"Movie of spins moving through cylinders","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<iframe src=\"https://ox.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=b6211751-2743-4bb8-b65a-af5d011a8684&autoplay=true&offerviewer=false&showtitle=false&showbrand=false&captions=false&interactivity=none\" style=\"border: 1px solid #464646;\" allowfullscreen allow=\"autoplay\"></iframe>","category":"page"}]
}
