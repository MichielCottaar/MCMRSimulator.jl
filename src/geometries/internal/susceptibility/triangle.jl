"""
Computes the off-resonance field produced by a triangular mesh:
"""
module Triangle

import StaticArrays: SVector
import LinearAlgebra: norm, cross, ⋅, inv
import Rotations: MRP, Angle2d, RotMatrix2
import ..Base: BaseSusceptibility, single_susceptibility, single_susceptibility_gradient
import ...Obstructions.Triangles: FullTriangle, normal

"""
    TriangleSusceptibility(full_triangle, chi_I, chi_A, b0_field)

Computes the field produced by a triangular susceptibility source
One triangle vertex is assumed to be at the origin.
"""
struct TriangleSusceptibility <: BaseSusceptibility{3}
    rotation :: MRP{Float64}
    e2_shift :: Float64
    e3_shift :: SVector{2, Float64}
    susceptibility :: Float64
end


function TriangleSusceptibility(ft::FullTriangle, chi_I::Number, chi_A::Number, b0_field::AbstractVector)
    n = normal(ft)
    e1 = ft.b .- ft.a
    e1 = e1 ./ norm(e1)
    e2 = cross(e1, n)
    rot = inv(MRP(hcat(e2, e1, n)))
    if iszero(chi_A)
        susceptibility = chi_I / 4π
    else
        cos_thetasq = (n ⋅ b0_field)^2
        susceptibility = (chi_I + chi_A * (3 * cos_thetasq - 1)) / 4π
    end
    a = (rot * e1)[2]
    (b, c, _) = rot * (ft.c .- ft.a)
    return TriangleSusceptibility(rot, a, SVector{2}((b, c)), susceptibility)
end


"""
    right_angle_triangle_field(a, b, c)

Returns the magnetic field experienced at (0, 0, c) generated by a triangle with edges (0, 0, 0), (a, 0, 0), (a, b, 0).
The susceptibility of the triangle is assumed to be ``\\sigma_m = 4 \\pi \\mu_0``.

This uses equations 8-10 from [rubeckAnalyticalCalculationMagnet2013](@cite).
Note that these equations assume a and b to be positive.
"""
function right_angle_triangle_field(a::Number, b::Number, c::Number)
    flip_x = a < 0 ? -1 : 1
    flip_y = b < 0 ? -1 : 1
    a = abs(a)
    b = abs(b)
        
    D_abc = sqrt(a * a + b * b + c * c)
    D_ab = sqrt(a * a + b * b)
    D_ac = sqrt(a * a + c * c)
    log_Dabc_Dab = log((D_abc + D_ab) / (D_abc - D_ab))
    return SVector{3}((
        (-b / (2D_ab) * log_Dabc_Dab + log((D_abc + b) / (D_abc - b))/2) * flip_x,
        (a / (2D_ab) * log_Dabc_Dab - log((D_ac + a) / (D_ac - a))/2) * flip_y,
        atan((a * D_abc) / (b * c)) - sign(c) * atan(a/b)
    ))
end

"""
    single_susceptibility(triangle, position, distance[, stuck_inside])

Computed using the algorithm described in [rubeckAnalyticalCalculationMagnet2013](@cite).
"""
function single_susceptibility(triangle::TriangleSusceptibility, position::AbstractVector, distance::Number, stuck_inside::Union{Nothing, Bool}, b0_field::SVector{3, Float64})
    if iszero(triangle.susceptibility)
        return 0.
    end
    (x, y, height) = triangle.rotation * position
    if ~isnothing(stuck_inside) && abs(height) < 1e-6
        # Shift particle by 1 picometer, so that the field calculation is appropriate
        if stuck_inside
            height = -1e-6
        else
            height = 1e-6
        end
    end
    @assert ~iszero(height) "distance to mesh should not be exactly zero for free particles"

    (b0_x, b0_y, b0_z) = triangle.rotation * b0_field

    field = 0.

    function add_to_field!(a, b, c, positive)
        (fx, fy, fz) = right_angle_triangle_field(a, b, c)
        new_f = (b0_x * fx + b0_y * fy + b0_z * fz)
        if positive
            field += new_f
        else
            field -= new_f
        end
    end

    a = triangle.e2_shift
    (b, c) = triangle.e3_shift
    for dim in 1:3
        # compute contribution of triangle between origin, p2, and (x, y)
        inside_plane = sign(x) == sign(b)
        if ~iszero(x)
            # Note that whether the right triangle has a positive contribution is determined by
            # xor, not by an and statement as implied in the paper.
            add_to_field!(-x, a - y, height, xor(inside_plane, (y > a)))
            add_to_field!(-x, -y, height, xor(inside_plane, (y < 0)))
        end

        if dim != 3
            # rotate the triangle, so that we have new origin and p2
            shift = -a
            angle_rotate = atan(b, c + shift)
            rotate = RotMatrix2(Angle2d(angle_rotate))
            (x, y) = rotate * SVector{2}((x, y + shift))
            (b0_x, b0_y) = rotate * SVector{2}((b0_x, b0_y))
            (t, a) = rotate * SVector{2}((b, c + shift))
            (b, c) = rotate * SVector{2}((0, shift))
            @assert abs(t) < 1e-8
        end
    end
    return field * triangle.susceptibility
end


function single_susceptibility_gradient(triangle::TriangleSusceptibility) 
    a = triangle.e2_shift
    (b, c) = triangle.e3_shift
    return triangle.susceptibility / max(a * a, b * b + c * c)^(3//2)
end

end