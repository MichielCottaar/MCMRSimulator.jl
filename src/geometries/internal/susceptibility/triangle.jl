"""
Computes the off-resonance field produced by a triangular mesh:
"""
module Triangle

import StaticArrays: SVector
import LinearAlgebra: norm, cross, ⋅, inv, I
import Rotations: MRP, Angle2d, RotMatrix2
import ..Base: BaseSusceptibility, single_susceptibility, single_susceptibility_gradient
import ...Obstructions.Triangles: FullTriangle, normal

"""
Parent type for each triangle in a mesh with susceptibility.

Computes the field produced by a triangular susceptibility source
One triangle vertex is assumed to be at `vertex1`.
Within the coordinate system defined by `rotation` the other two points are at:
- (0, `e2_shift`, 0)
- (`e3_shift[1]`, `e3_shift[2]`, 0)

There are two versions:
- [`IsotropicTriangleSusceptibility`](@ref)
- [`AnisotropicTriangleSusceptibility`](@ref)
"""
abstract type TriangleSusceptibility <: BaseSusceptibility{3} end

"""
    IsotropicTriangleSusceptibility(full_triangle, chi_I)

Represents a triangle with isotropic magnetic susceptibility.

For more details on the internal representation, see [`TriangleSusceptibility`](@ref)
"""
struct IsotropicTriangleSusceptibility <: TriangleSusceptibility
    vertex1 :: SVector{3, Float64}
    rotation :: MRP{Float64}
    e2_shift :: Float64
    e3_shift :: SVector{2, Float64}
    susceptibility :: Float64
end

function get_base_properties(ft::FullTriangle)
    vertex1 = @. (2 * ft.a - ft.b - ft.c) / 3
    n = normal(ft)
    e1 = ft.b .- ft.a
    a = norm(e1)
    e1 = e1 ./ norm(e1)
    e2 = cross(e1, n)
    rot = inv(MRP(hcat(e2, e1, n)))
    (b, c, _) = rot * (ft.c .- ft.a)
    return vertex1, rot, a, SVector{2}((b, c))
end

function IsotropicTriangleSusceptibility(ft::FullTriangle, chi_I::Number)
    return IsotropicTriangleSusceptibility(get_base_properties(ft)..., chi_I / 4π)
end


"""
    AnisotropicTriangleSusceptibility(full_triangle, chi_I, chi_A, b0_field)

Represents a triangle with anisotropic magnetic susceptibility.

For more details on the internal representation, see [`TriangleSusceptibility`](@ref)
"""
struct AnisotropicTriangleSusceptibility <: TriangleSusceptibility
    vertex1 :: SVector{3, Float64}
    rotation :: MRP{Float64}
    e2_shift :: Float64
    e3_shift :: SVector{2, Float64}
    shift_direction :: SVector{3, Float64}
    susceptibility :: Float64
end

function AnisotropicTriangleSusceptibility(ft::FullTriangle, chi_I::Number, chi_A::Number, b0_field::SVector{3, Float64})
    mag = triangle_magnetisation(ft, chi_I, chi_A, b0_field)
    size_mag = norm(mag)
    return AnisotropicTriangleSusceptibility(get_base_properties(ft)..., mag ./ size_mag, size_mag / 4π)
end

function triangle_magnetisation(ft::FullTriangle, chi_I::Number, chi_A::Number, b0_field::SVector{3, Float64})
    n = normal(ft)
    full_mat = (
        1.5 .* chi_A .* (n * n') .+
        (chi_I - 0.5 * chi_A) .* I(3)
    )
    return full_mat * b0_field
end

"""
    right_angle_triangle_field(a, b, z)

Returns the magnetic field experienced at (0, 0, z) generated by a triangle with edges (0, 0, 0), (a, 0, 0), (a, b, 0).
The susceptibility of the triangle is assumed to be ``\\sigma_m = 4 \\pi \\mu_0``.

This uses equations 8-10 from [rubeckAnalyticalCalculationMagnet2013](@cite).
Note that these equations assume a and b to be positive.
"""
function right_angle_triangle_field(a::Number, b::Number, z::Number)
    flip_x = a < 0 ? -1 : 1
    flip_y = b < 0 ? -1 : 1
    a = abs(a)
    b = abs(b)
        
    D_abz = sqrt(a * a + b * b + z * z)
    D_ab = sqrt(a * a + b * b)
    D_az = sqrt(a * a + z * z)
    log_Dabz_Dab = log((D_abz + D_ab) / (D_abz - D_ab))
    return SVector{3}((
        (-b / (2D_ab) * log_Dabz_Dab + log((D_abz + b) / (D_abz - b))/2) * flip_x,
        (a / (2D_ab) * log_Dabz_Dab - log((D_az + a) / (D_az - a))/2) * flip_y,
        atan((a * D_abz) / (b * z)) - sign(z) * atan(a/b)
    ))
end

shift_direction(triangle::IsotropicTriangleSusceptibility, b0_field::SVector{3, Float64}) = b0_field
shift_direction(triangle::AnisotropicTriangleSusceptibility, b0_field::SVector{3, Float64}) = triangle.shift_direction

"""
    single_susceptibility(triangle, position, distance[, stuck_inside])

Computed using the algorithm described in [rubeckAnalyticalCalculationMagnet2013](@cite).
"""
function single_susceptibility(triangle::TriangleSusceptibility, position::AbstractVector, distance::Number, stuck_inside::Union{Nothing, Bool}, b0_field::SVector{3, Float64})
    (_, _, height) = triangle.rotation * position
    shift_size = abs(height) / 10
    shift = shift_direction(triangle, b0_field) .* shift_size
    return (
        single_susceptibility_helper(triangle, position - shift - triangle.vertex1, stuck_inside, b0_field) - 
        single_susceptibility_helper(triangle, position + shift - triangle.vertex1, stuck_inside, b0_field)
    ) / (shift_size * 2)
end

function single_susceptibility_helper(triangle::TriangleSusceptibility, position::AbstractVector, stuck_inside::Union{Nothing, Bool}, b0_field::SVector{3, Float64})
    if iszero(triangle.susceptibility)
        return 0.
    end
    (x, y, height) = triangle.rotation * position
    if ~isnothing(stuck_inside) && abs(height) < 1e-6
        # Shift particle by 1 picometer, so that the field calculation is appropriate
        if stuck_inside
            height = -1e-6
        else
            height = 1e-6
        end
    end
    @assert ~iszero(height) "distance to mesh should not be exactly zero for free particles"

    (b0_x, b0_y, b0_z) = triangle.rotation * b0_field

    field = 0.

    function add_to_field(a, b, c, positive, b0_x, b0_y)
        (fx, fy, fz) = right_angle_triangle_field(a, b, c)
        new_f = (b0_x * fx + b0_y * fy + b0_z * fz)
        return positive ? new_f : -new_f
    end

    a = triangle.e2_shift
    (b, c) = triangle.e3_shift
    for dim in 1:3
        # compute contribution of triangle between origin, p2, and (x, y)
        inside_plane = sign(x) == sign(b)
        if ~iszero(x)
            # Note that whether the right triangle has a positive contribution is determined by
            # xor, not by an and statement as implied in the paper.
            field += add_to_field(-x, a - y, height, xor(inside_plane, (y > a)), b0_x, b0_y)
            field += add_to_field(-x, -y, height, xor(inside_plane, (y < 0)), b0_x, b0_y)
        end

        if dim != 3
            # rotate the triangle, so that we have new origin and p2
            shift = -a
            angle_rotate = atan(b, c + shift)
            rotate = RotMatrix2(Angle2d(angle_rotate))
            (x, y) = rotate * SVector{2, Float64}(x, y + shift)
            (b0_x, b0_y) = rotate * SVector{2, Float64}(b0_x, b0_y)
            (t, a) = rotate * SVector{2, Float64}(b, c + shift)
            (b, c) = rotate * SVector{2, Float64}(0., shift)
            @assert abs(t) < 1e-8
        end
    end
    return field * triangle.susceptibility
end


function single_susceptibility_gradient(triangle::TriangleSusceptibility) 
    a = triangle.e2_shift
    (b, c) = triangle.e3_shift
    return triangle.susceptibility / max(a * a, b * b + c * c)^(3//2)
end

end