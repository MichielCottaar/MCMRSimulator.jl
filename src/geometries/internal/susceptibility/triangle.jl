"""
Computes the off-resonance field produced by a triangular mesh:
"""
module Triangle

import StaticArrays: SVector
import LinearAlgebra: norm, cross, ⋅
import Rotations: MRP, Angle2d
import ..Base: BaseSusceptibility, single_susceptibility, single_susceptibility_gradient
import ...Obstructions.Triangles: FullTriangle, normal

"""
    TriangleSusceptibility(full_triangle, chi_I, chi_A, b0_field)

Computes the field produced by a triangular susceptibility source
One triangle vertex is assumed to be at the origin.
"""
struct TriangleSusceptibility <: BaseSusceptibility{3}
    rotation :: MRP{Float64}
    e2_shift :: Float64
    e3_shift :: SVector{2, Float64}
    susceptibility :: Float64
end


function TriangleSusceptibility(ft::FullTriangle, chi_I::Number, chi_A::Number, b0_field::AbstractVector)
    n = normal(ft)
    e1 = ft.b .- ft.a
    e2 = cross(n, e1)
    rot = MRP(hcat(e1, e2, n))
    if iszero(chi_A)
        susceptibility = chi_I
    else
        b0_field = rot * b0_field
        cos_thetasq = b0_field[3] * b0_field[3]
        susceptibility = (chi_I + chi_A * (3 * cos_thetasq - 1)) / 4π
    end
    a = norm(e1)
    (b, c, _) = rot * (ft.c .- ft.a)
    return TriangleSusceptibility(rot, a, SVector{2}((b, c)), susceptibility)
end


"""
    right_angle_triangle_field(a, b, c)

Returns the magnetic field experienced at (0, 0, z) generated by a triangle with edges (0, 0, 0), (a, 0, 0), (a, b, 0).
The susceptibility of the triangle is assumed to be ``\\sigma_m = 4 \\pi \\mu_0``.

This uses equations 8-10 from [rubeckAnalyticalCalculationMagnet2013](@cite).
"""
function right_angle_triangle_field(a::Number, b::Number, c::Number)
    D_abc = sqrt(a * a + b * b + c * c)
    D_ab = sqrt(a * a + b * b)
    D_ac = sqrt(a * a + c * c)
    log_Dabc_Dab = log((D_abc + D_ab) / (D_abc - D_ab))
    return SVector{3}((
        -b / (2D_ab) * log_Dabc_Dab + log((D_abc + b) / (D_abc - b))/2,
        a / (2D_ab) * log_Dabc_Dab - log((D_ac + a) / (D_ac - a))/2,
        atan((a * D_abc) / (b * c)) - sign(c) * atan(a/b)
    ))
end

"""
    single_susceptibility(triangle, position, distance[, stuck_inside])

Computed using the algorithm described in [rubeckAnalyticalCalculationMagnet2013](@cite).
"""
function single_susceptibility(triangle::TriangleSusceptibility, position::AbstractVector, distance::Number, stuck_inside::Union{Nothing, Bool}, b0_field::SVector{3, Float64})
    if iszero(triangle.susceptibility)
        return 0.
    end
    (x, y, height) = triangle.rotation * position
    if ~isnothing(stuck_inside) && abs(height) < 1e-6
        # Shift particle by 1 picometer, so that the field calculation is appropriate
        if stuck_inside
            height = -1e-6
        else
            height = 1e-6
        end
    end

    (b0_x, b0_y, b0_z) = triangle.rotation * b0_field

    field = 0.

    function add_to_field!(a, b, c, positive)
        (fx, fy, fz) = right_angle_triangle_field(a, b, c)
        new_f = (b0_x * fx + b0_y * fy + b0_z * fz)
        if positive
            field += new_f
        else
            field -= new_f
        end
    end

    a = triangle.e2_shift
    (b, c) = triangle.e3_shift
    for _ in 1:3
        # compute contribution of triangle between origin, p2, and (x, y)
        inside_plane = sign(y) == sign(c)
        if ~iszero(y)
            add_to_field!(x, y, height, inside_plane && (x > 0))
            add_to_field!(x - a, y, height, inside_plane && (x < a))
        end

        # rotate the triangle, so that we have new origin and p2
        shift = -a
        angle_rotate = atan(c, b + shift)
        rotate = RotMatrix{2}(Angle2d(angle_rotate))
        (x, y) = rotate * SVector{2}((x + shift, y))
        (b0_x, b0_y) = rotate * SVector{2}((b0_x, b0_y))
        (b, c) = rotate * SVector{2}((shift, 0))
        (t, a) = rotate * SVector{2}((b + shift, c))
        @assert iszero(t)
    end
    return field * triangle.susceptibility
end


function single_susceptibility_gradient(t::TriangleSusceptibility) 
    a = triangle.e2_shift
    (b, c) = triangle.e3_shift
    return t.susceptibility / max(a * a, b * b + c * c)^(3//2)
end

end