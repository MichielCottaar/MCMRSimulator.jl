"""Base obstruction type hindering free diffusion.

These obstructions are always perfectly aligned with the main axes and centered at the origin (except for [`Mesh`](@ref)).
They can be moved/rotated/repeated by applying [`TransformObstruction`](@ref).

The dimensionality N indicates the dimensionality of the input data 
(1 for [`Wall`](@ref), 2 for [`Cylinder`](@ref), 3 for [`Sphere`](@ref) or [`Mesh`](@ref)).

Each obstruction needs to define the following interface:
- [`detect_collision`](@ref)(movement, obstruction, previous_collision): returns any interesection between the movement and the obstruction
- [`produces_off_resonance`](@ref)(obstruction), optional: whether the obstruction produces an off-resonance field (false by default). If true, the obstruction should also define:
    - [`lorentz_off_resonance`](@ref)(obstruction, position, ...): computes the off-resonance due to the obstruction at position
    - [`total_susceptibility`](@ref)(obstruction): computes total susceptibility caused by this obstruction
    - [`off_resonance_gradient`](@ref)(obstruction): computes the maximum off-resonance gradient induced by this obstruction
- [`isinside`](@ref)(obstruction, position): true if position is inside the obstruction
- [`BoundingBox`](@ref)(obstruction): returns a [`BoundingBox`] fully containing the obstruction
- [`size_scale`](@ref)(obstruction): returns a scale of the size of the object; used to estimate a maximum size step in the simulation
- [`random_surface_positions`](@ref)(obstruction, density): returns a set of random positions (and associated normals/indices) along the obstruction
"""
abstract type BaseObstruction{N} <: Obstruction{N} end

ObstructionProperties(obstruction :: BaseObstruction) = obstruction.properties

"""
    collided(o::BaseObstruction, c::Collision)

Returns true if the collision `c` hit the obstruction `o`.
"""
collided(o::BaseObstruction, c::Collision) = ObstructionProperties(o).id == ObstructionProperties(c).id

"""
    inside_MRI_properties(obstruction, position)

Returns the inside MRI properties of the obstruction only if the position is within the property.
For positions outside of the MRI properties an empty [`MRIProperties`](@ref) is returned.
"""
function inside_MRI_properties(obstruction::BaseObstruction{N}, position::SVector{N, Float}) where{N}
    if empty_mri_properties(obstruction.properties.inside) || (isinside(obstruction, position) > 0)
        return obstruction.properties.inside
    else
        return MRIProperties()
    end
end

# Base obstruction API
"""
    detect_collision(movement, base_obstruction, previous_collision)

Returns any intersection between the [`Movement`](@ref) and the [`BaseObstruction`].
"""
function detect_collision end

"""
    produces_off_resonance(base_obstruction)

Whether the obstruction produces an off-resonance field.
The field will be computed using [`lorentz_off_resonance`]
"""
produces_off_resonance(obstruction::BaseObstruction) = false


"""
    lorentz_off_resonance(base_obstruction, position, b0_field, repeat_dist, radius, nrepeats)

Computes the off-resonance field produced by the obstruction ([`BaseObstruction`](@ref)) at the given `position` given the `b0_field`.
The field generated by any repeats of the base obstruction within a distance of `radius` will also be considered (presuming the obstruction repeats every `repeat_dist`).
This maximum number of repeats that need to be considered is precomputed as `nrepeats`.
"""
function lorentz_off_resonance end


"""
    isinside(obstruction/geometry/bounding_box, position)
    isinside(obstructions/geometry/bounding_box, spin)
    isinside(obstructions/geometry/bounding_box, snapshot)

Test whether the particles are inside a [`BaseObstruction`](@ref), [`TransformObstruction`](@ref), [`Geometry`](@ref) or [`BoundingBox`](@ref) object.
"""
isinside(something, pos::AbstractVector) = isinside(something, SVector{length(pos)}(pos), empty_collision)

"""
    total_susceptibility(obstruction)

Computes total surface (for 2D) or volume (for 3D) susceptibility of a base obstruction.
"""
total_susceptibility(o::BaseObstruction) = zero(Float)

"""
    off_resonance_gradient(obstruction[, B0])
    off_resonance_gradient(geometry[, B0])

Computes the maximum off-resonance gradient produced by this obstruction.
For a geometry with multiple obstructions, the maximum value is returned.
If a B0 field is provided the result is returned in kHz/um, otherwise in ppm/um.
"""
off_resonance_gradient(obstruction::BaseObstruction) = zero(Float)
off_resonance_gradient(obstruction_or_geometry, B0::Number) = off_resonance_gradient(obstruction_or_geometry) * 1e-6 * B0 * gyromagnetic_ratio


"""
    size_scale(geometry)
    size_scale(obstruction)

Computes the minimum size scale of the obstructions in the geometry.

The size scale for each obstruction is defined as:
- [`cylinders`](@ref)/[`spheres`](@ref): minimum radius
- [`annuli`](@ref): minimum inner radius
- [`mesh`](@ref): square root of median triangle size
- [`wall`](@ref): distance between closest walls (infinite for single, non-repeating walls)
"""
function size_scale end

"""
    max_timestep_sticking(obstruction, default_properties, diffusivity)
    max_timestep_sticking(geometry, default_properties, diffusivity)

Computes the maximum timestep that a simulation can have before [`stick_probability`](@ref) goes above 1.
"""
function max_timestep_sticking(obstruction::BaseObstruction, default_properties::GlobalProperties, diffusivity::Number)
    s = surface_density(obstruction, default_properties)
    if iszero(s)
        return Inf
    end
    d = dwell_time(obstruction, default_properties)
    return stick_probability(s, d, diffusivity, 1)^-2
end

"""
    random_surface_spins(geometry, bounding_box, volume_density, repeats, default_surface_density, shift; longitudinal=1, transverse=0, phase=0, nsequences=1)

Randomly generate stuck spins on the surface of the obstruction with the given magnetisation.
For each obstruction in the geometry this will call [`random_surface_positions`](@ref).
"""
function random_surface_spins(obstruction::BaseObstruction{N}, bounding_box::BoundingBox{3}, volume_density::Number, repeats::SVector{N, Float}, default_surface_density::Number, shift::SVector{N, Float}; kwargs...) where {N}
    relative = surface_density(obstruction.properties)
    if isnan(relative)
        relative = default_surface_density
    end
    random_surface_spins(obstruction, bounding_box, relative*volume_density, repeats, shift; kwargs...)
end

function random_surface_spins(obstruction::BaseObstruction{N}, bounding_box::BoundingBox{3}, surface_density::Number, repeats::SVector{N, Float}, shift::SVector{N, Float}; kwargs...) where {N}
    (positions, normals, indices) = random_surface_positions(obstruction, bounding_box, surface_density, repeats, shift)
    function get_spin(position, normal, index)
        inside = rand(Bool)
        n = inside ? normal : -normal
        Spin(;
            position=position,
            stuck_to=Reflection(
                Collision(0, n, obstruction.properties, index, inside),
                0, 0, position, zero(PosVector)
            ),
            kwargs...
        )
    end
    return get_spin.(positions, normals, indices)
end

"""
    random_surface_positions(obstruction, bounding_box, surface_density[, repeats])

Generates a set of random positions on the obstruction.
It also returns the corresponding surface normals (pointing inwards!) and indices (for a mesh).
This has been implemented for each obstruction to allow [`random_surface_spins`](@ref) to work.
"""
function random_surface_positions(obstruction::BaseObstruction{2}, bounding_box::BoundingBox{3}, density::Number, repeats::SVector{2, Float}, shift::SVector{2, Float})
    u = upper(bounding_box)[3]
    l = lower(bounding_box)[3]
    height = u - l
    (positions, normals, indices) = random_surface_positions(obstruction, BoundingBox(lower(bounding_box)[1:2], upper(bounding_box)[1:2]), density * height, repeats, shift)
    return (
        [SVector{3}(p..., rand() * height + l) for p in positions],
        [SVector{3}(n..., zero(Float)) for n in normals],
        indices,
    )
end

function random_surface_positions(obstruction::BaseObstruction{1}, bounding_box::BoundingBox{3}, density::Number, repeats::SVector{1, Float}, shift::SVector{1, Float})
    u = upper(bounding_box)
    l = lower(bounding_box)
    full_density = (u[2] - l[2]) * (u[3] - l[3]) * density
    (positions, normals, indices) = random_surface_positions(obstruction, BoundingBox(l[1:1], u[1:1]), full_density, repeats, shift)
    return (
        [SVector{3}(
            p[1], 
            rand() * (u[2] - l[2]) + l[2],
            rand() * (u[3] - l[3]) + l[3],
            ) for p in positions],
        [SVector{3}(n[1], zero(Float), zero(Float)) for n in normals],
        indices
    )
end

function random_surface_positions(obstruction::BaseObstruction{N}, bounding_box::BoundingBox{N}, density::Number, repeats::SVector{N, Float}, shift::SVector{N, Float}) where {N}
    if any(isfinite.(repeats))
        lowest_repeat = Int.(div.(lower(bounding_box), repeats, RoundNearest)) .- 1
        highest_repeat = Int.(div.(upper(bounding_box), repeats, RoundNearest)) .+ 1
        nrepeats = highest_repeat .- lowest_repeat .+ 1
        total_density = prod(nrepeats) * density
        (positions, normals, indices) = random_surface_positions(obstruction, total_density)

        repeat_shift = [SVector{N, Float}([rand(l:h) * r for (l, h, r) in zip(lowest_repeat, highest_repeat, repeats)]) for _ in 1:length(positions)]
        return ([p .+ s .+ shift for (p, s) in zip(positions, repeat_shift)], normals, indices)
    else
        (positions, normals, indices) = random_surface_positions(obstruction, density)
        shifted = [p .+ shift for p in positions]
        return (shifted, normals, indices)
    end
end

for accessor in (:MT_fraction, :permeability, :surface_density, :dwell_time)
    @eval function $(accessor)(o::BaseObstruction, defaults) 
        value = $(accessor)(o.properties)
        if isnan(value)
            value = $(accessor)(defaults)
        end
        @assert !isnan(value)
        return value
    end
end



include("random_draws.jl")
include("cylinder.jl")
include("sphere.jl")
include("wall.jl")
include("mesh.jl")
include("annulus.jl")
include("spiral.jl")