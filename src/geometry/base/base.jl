"""Base obstruction type hindering free diffusion.

These obstructions are always perfectly aligned with the main axes and centered at the origin (except for [`Mesh`](@ref)).
They can be moved/rotated/repeated by applying [`TransformObstruction`](@ref).

The dimensionality N indicates the dimensionality of the input data 
(1 for [`Wall`](@ref), 2 for [`Cylinder`](@ref), 3 for [`Sphere`](@ref) or [`Mesh`](@ref)).

Each obstruction needs to define the following interface:
- [`detect_collision`](movement, obstruction, previous_collision): returns any interesection between the movement and the obstruction
- [`produces_off_resonance`](obstruction), optional: whether the obstruction produces an off-resonance field (false by default). If true, the obstruction should also define:
    - [`lorentz_off_resonance`](obstruction, position, ...): computes the off-resonance due to the obstruction at position
    - [`total_susceptibility`](obstruction): computes total susceptibility caused by this obstruction
- [`isinside`](obstruction, position): true if position is inside the obstruction
- [`BoundingBox`](obstruction): returns a [`BoundingBox`] fully containing the obstruction
"""
abstract type BaseObstruction{N} <: Obstruction{N} end

ObstructionProperties(obstruction :: BaseObstruction) = obstruction.properties

Base.copy(o::BaseObstruction) = @set o.properties.id = uuid1()


# Base obstruction API
"""
    detect_collision(movement, base_obstruction, previous_collision)

Returns any intersection between the [`Movement`](@ref) and the [`BaseObstruction`].
"""
function detect_collision end

"""
    produces_off_resonance(base_obstruction)

Whether the obstruction produces an off-resonance field.
The field will be computed using [`lorentz_off_resonance`]
"""
produces_off_resonance(obstruction::BaseObstruction) = false


"""
    lorentz_off_resonance(base_obstruction, position, b0_field, repeat_dist, radius, nrepeats)

Computes the off-resonance field produced by the obstruction ([`BaseObstruction`](@ref)) at the given `position` given the `b0_field`.
The field generated by any repeats of the base obstruction within a distance of `radius` will also be considered (presuming the obstruction repeats every `repeat_dist`).
This maximum number of repeats that need to be considered is precomputed as `nrepeats`.
"""
function lorentz_off_resonance end


"""
    isinside(obstruction/geometry/bounding_box, position)
    isinside(obstructions/geometry/bounding_box, spin)
    isinside(obstructions/geometry/bounding_box, snapshot)

Test whether the particles are inside a [`BaseObstruction`](@ref), [`TransformObstruction`](@ref), [`Geometry`](@ref) or [`BoundingBox`](@ref) object.
"""
isinside(something, spin::Spin) = isinside(something, spin.position)
isinside(something, snapshot::Snapshot) = [isinside(something, spin) for spin in snapshot]

produces_off_resonance(obstruction::BaseObstruction) = false

"""
    total_susceptibility(obstruction)

Computes total surface (for 2D) or volume (for 3D) susceptibility of a base obstruction.
"""
total_susceptibility(o::BaseObstruction) = zero(Float)


include("random_draws.jl")
include("cylinder.jl")
include("sphere.jl")
include("wall.jl")
include("mesh.jl")
include("annulus.jl")
include("spiral.jl")